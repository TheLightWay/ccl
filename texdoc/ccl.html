<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtHgold 4.05 (hacked by jacob navia)">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

        
<title> {A container library for C}</title>
 
<h1 align="center"><i>A container library for C</i> </h1>

<h3 align="center">Jacob Navia </h3>

<h3 align="center"> </h3> 




<div class="p"><!----></div>
     <span class="roman"><font face="helvetica"><font size="+4"><b>  </b></font></font></span>
  0pt
  [remember picture,overlay]
     at (current page.north west)
      [remember picture, overlay]
		 (0.0,0) - (15.5,0);
                         
              <font color="#000000">0&nbsp;#1</font>;
       
      ;
   
  
*
 <h1><a name="tth_chAp1">
Chapter 1 </a><br /></h1>0pt50pt-60pt

<div class="p"><!----></div>
  pgfid2049786951
 pgfid1558825441851066


 pgfid4049786951
 pgfid3558825441851883


 pgfid6049786951
 pgfid5558825441862167










 pgfid8049786951
 pgfid7558825441888698























































 pgfid10049786951
 pgfid9558825441892959






















































































































































































































































































































































































 pgfid12049786951
 pgfid11558825441892959
 pgfid14049786951
 pgfid13558825441863987



 pgfid16049786951
 pgfid15558825441892959














































































 pgfid18049786951
 pgfid17558825441892959

 pgfid20049786951
 pgfid19558825441892959










<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR><img src="Containers.png" alt="Figure">
<BR CLEAR=LEFT><BR><BR>


<div class="p"><!----></div>

<h1>Contents </h1>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1"
>1.1&nbsp; Design goals</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.1"
>1.1.1&nbsp; Error analysis</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.2"
>1.1.2&nbsp; Full feature set</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.3"
>1.1.3&nbsp; Abstraction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.4"
>1.1.4&nbsp; Performance</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.5"
>1.1.5&nbsp; Compile time checking</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.6"
>1.1.6&nbsp; Design choices</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.2"
>1.2&nbsp; How the functions are specified in this document.</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.3"
>1.3&nbsp; Which sections of this document are normative?</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; The two types of interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; The interface concept</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4"
>2.4&nbsp; Error handling</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.1"
>2.4.1&nbsp; Return code</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5"
>2.5&nbsp; Naming conventions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.1"
>2.5.1&nbsp; Container Names</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.2"
>2.5.2&nbsp; Interface object name</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6"
>2.6&nbsp; The different containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.1"
>2.6.1&nbsp;  Single and double linked lists</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.2"
>2.6.2&nbsp; Flexible arrays (vector)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.3"
>2.6.3&nbsp; ValArray: Arrays of numbers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.4"
>2.6.4&nbsp; String collection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.5"
>2.6.5&nbsp; Bit-string</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.6"
>2.6.6&nbsp; Dictionary</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.7"
>2.6.7&nbsp; Hash Table</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.8"
>2.6.8&nbsp; AVL trees</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.9"
>2.6.9&nbsp; Scapegoat trees</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.10"
>2.6.10&nbsp; Bloom Filter</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.11"
>2.6.11&nbsp; Queue</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.12"
>2.6.12&nbsp; Deque</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.13"
>2.6.13&nbsp; Buffers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.14"
>2.6.14&nbsp; Priority Queues</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6.15"
>2.6.15&nbsp; At a glance</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; Creation of a container: Create</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; Destruction of a container: Clear and Finalize</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2.1"
>3.2.1&nbsp; Other creation functions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; Adding an element to a container: Add and AddRange</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; Removing elements from a container</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.1"
>3.4.1&nbsp; Using an element as key</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.2"
>3.4.2&nbsp; Removing at a given position</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.3"
>3.4.3&nbsp; Using a container as a stack</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.4"
>3.4.4&nbsp; Batch removing</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5"
>3.5&nbsp; Retrieving elements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.6"
>3.6&nbsp; Using masks</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.7"
>3.7&nbsp; Sorting a sequential container: Sort</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.8"
>3.8&nbsp; Copying a container: Copy</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.9"
>3.9&nbsp; Saving and loading a container to or from disk: Save and Load</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.10"
>3.10&nbsp; Inserting a container into another</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.10.1"
>3.10.1&nbsp; Sequential containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.10.2"
>3.10.2&nbsp; Associative containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.11"
>3.11&nbsp; Replace an element with another</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.11.1"
>3.11.1&nbsp; Sequential containers: ReplaceAt</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.11.2"
>3.11.2&nbsp; Associative containers: Replace</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.12"
>3.12&nbsp; Looping through all elements of a container</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.12.1"
>3.12.1&nbsp; Using a simple loop to iterate a container</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.12.2"
>3.12.2&nbsp; Using the Apply function.</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.12.3"
>3.12.3&nbsp; Using iterators</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.13"
>3.13&nbsp; Setting and retrieving the state: GetFlags and SetFlags</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.14"
>3.14&nbsp; Retrieving the number of elements stored: Size</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15"
>3.15&nbsp; Sizes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15.1"
>3.15.1&nbsp; Sizeof</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15.2"
>3.15.2&nbsp; SizeofIterator</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.16"
>3.16&nbsp; Memory management</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.16.1"
>3.16.1&nbsp; Memory manager objects</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.16.2"
>3.16.2&nbsp; Pooled memory management</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.16.3"
>3.16.3&nbsp; Heap of same size objects</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.16.4"
>3.16.4&nbsp; Garbage collection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.16.5"
>3.16.5&nbsp; Multi-threading</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.17"
>3.17&nbsp; At a glance</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; Masks</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.1"
>4.1.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.2"
>4.1.2&nbsp; The API</a><br />












&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; Memory management</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.1"
>4.2.1&nbsp; The default memory manager</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.2"
>4.2.2&nbsp; The Heap interface: iHeap</a><br />







&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp; Pooled memory interface: iPool</a><br />





&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4"
>4.4&nbsp; Error handling Interface: iError</a><br />






&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4.1"
>4.4.1&nbsp; Error codes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5"
>4.5&nbsp; The iterator interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5.1"
>4.5.1&nbsp; Error handling</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5.2"
>4.5.2&nbsp; The interface</a><br />







&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6"
>4.6&nbsp; The observer interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6.1"
>4.6.1&nbsp; Caveats</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6.2"
>4.6.2&nbsp; The interface</a><br />




&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6.3"
>4.6.3&nbsp; Notification messages</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7"
>4.7&nbsp; Types used by the library</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7.1"
>4.7.1&nbsp; CompareInfo</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7.2"
>4.7.2&nbsp; CompareFunction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7.3"
>4.7.3&nbsp; Save function</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7.4"
>4.7.4&nbsp; Read function</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7.5"
>4.7.5&nbsp; Error function</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7.6"
>4.7.6&nbsp; Destructor function</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; The List interfaces: iList, iDlist</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.1"
>5.1.1&nbsp; General remarks</a><br />


























































&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.2"
>5.1.2&nbsp; Specializations of linked lists</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; Double linked lists: iDlist</a><br />





&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3"
>5.3&nbsp; The Vector interface: iVector</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3.1"
>5.3.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3.2"
>5.3.2&nbsp; The API</a><br />





















































&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4"
>5.4&nbsp; The bit-string container: iBitString</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4.1"
>5.4.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4.2"
>5.4.2&nbsp; API</a><br />





















&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5"
>5.5&nbsp; The string collection container: istrCollection, iWstrCollection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5.1"
>5.5.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5.2"
>5.5.2&nbsp; API</a><br />















&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6"
>5.6&nbsp; The dictionary container: iDictionary</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6.1"
>5.6.1&nbsp; The dictionary interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6.2"
>5.6.2&nbsp; The API</a><br />































&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.7"
>5.7&nbsp; The TreeMap interface: iTreeMap</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.7.1"
>5.7.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8"
>5.8&nbsp; Hash Table: iHashTable</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8.1"
>5.8.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8.2"
>5.8.2&nbsp; The API</a><br />



















&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.9"
>5.9&nbsp; Queues: iQueue</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.9.1"
>5.9.1&nbsp; Interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.9.2"
>5.9.2&nbsp; The API</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.10"
>5.10&nbsp; Deque: iDeque</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.10.1"
>5.10.1&nbsp; Interface</a><br />

















&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.11"
>5.11&nbsp; Priority queues</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.11.1"
>5.11.1&nbsp; Interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.11.2"
>5.11.2&nbsp; A complete example</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.11.3"
>5.11.3&nbsp; The API</a><br />












&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.12"
>5.12&nbsp; Bloom filters</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.12.1"
>5.12.1&nbsp; The interface: iBloomFilter</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.12.2"
>5.12.2&nbsp; The API</a><br />






&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.13"
>5.13&nbsp; Suffix Trees</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.13.1"
>5.13.1&nbsp; The interface: iSuffixTree</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.13.2"
>5.13.2&nbsp; The API</a><br />





&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14"
>5.14&nbsp; Value arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14.1"
>5.14.1&nbsp; Operations</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14.2"
>5.14.2&nbsp; Slices and masks</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14.3"
>5.14.3&nbsp; The interface</a><br />







































































&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.15"
>5.15&nbsp; Buffers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.15.1"
>5.15.1&nbsp; Stream buffers</a><br />
















&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.15.2"
>5.15.2&nbsp; Circular buffers</a><br />











&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.16"
>5.16&nbsp; The generic interfaces</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.16.1"
>5.16.1&nbsp; Generic containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.16.2"
>5.16.2&nbsp; Sequential containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.16.3"
>5.16.3&nbsp; Associative containers</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; Adding conversions between containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; Infinite arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.1"
>6.2.1&nbsp; Zero extensible arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.2"
>6.2.2&nbsp; Arrays extensible by insert</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.3"
>6.2.3&nbsp; Pitfalls</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; Unique</a><br />





&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp; Paste</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; Mapcar</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4"
>7.4&nbsp; Word offsets</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4.1"
>7.4.1&nbsp; Task description</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4.2"
>7.4.2&nbsp; Algorithm</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1"
>8.1&nbsp; The different source files</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1.1"
>8.1.1&nbsp; Building the software</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2"
>8.2&nbsp; Partitioning</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3"
>8.3&nbsp; Data structures</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.1"
>8.3.1&nbsp; The generic part</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.2"
>8.3.2&nbsp; Lists</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.3"
>8.3.3&nbsp; Source files</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.4"
>8.3.4&nbsp; Double linked lists</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.5"
>8.3.5&nbsp; Vector</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.6"
>8.3.6&nbsp; Dictionary</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.7"
>8.3.7&nbsp; String collection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.8"
>8.3.8&nbsp; Masks</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.9"
>8.3.9&nbsp; Bit strings</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.10"
>8.3.10&nbsp; The iterator implementation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.11"
>8.3.11&nbsp; The timestamp field</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4"
>8.4&nbsp; The code</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4.1"
>8.4.1&nbsp; List</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4.2"
>8.4.2&nbsp; Queues</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4.3"
>8.4.3&nbsp; The dictionary</a><br />




&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4.4"
>8.4.4&nbsp; The bloom filter</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4.5"
>8.4.5&nbsp; Debugging malloc</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4.6"
>8.4.6&nbsp; The observer interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4.7"
>8.4.7&nbsp; ValArrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.5"
>8.5&nbsp; Building the documentation</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.1"
>9.1&nbsp; Pre processing a generic file</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2"
>9.2&nbsp; Using the pre-processor</a><br />



<a href="#tth_sEcindex">Index</a><br />* 

 <h1><a name="tth_chAp2">
Chapter 2 </a><br />Introduction</h1>
The objective of this proposal is to standardize the usage of common data structures within the context of the C language. The existence of a common standard interface for lists, hash tables, flexible arrays, and other containers has several advantages:

<ul>
<li>User code remains portable across different projects. In C, we all use the FILE abstraction, for instance. This abstraction allows software to be 
compatible across a large spectrum of machines and operating systems. Imagine what would happen if each project had to develop a file stream
abstraction again and again. This is the case when using lists, for instance. Today, we have in all significant projects written in C a list
module, and probably other ones like hash tables, etc.
<div class="p"><!----></div>
</li>

<li> Avoid duplication of effort. Most of the list or hash tables modules can't be debugged completely and are the source of never ending problems.
<div class="p"><!----></div>
</li>

<li> Lack of standards makes the merging of two projects very difficult since in most cases the interfaces and data structures are slightly
different. This leads to a complete rewrite of one of the modules, or to &#228;dapter" software that will translate from one list implementation
to the other, adding yet another layer of complexity to the merged project.
<div class="p"><!----></div>
</li>

<li> The language becomes more expressive since it becomes possible to reason within a high level environment. The lack of operations for
handling advanced data structures conditions programmers to use low level solutions like making an array with a fixed maximum size instead of a
list even if the programmer would agree that a list would be a more adequate solution to the problem. Confronted to the alternative of
developing yet another list module or opting for a low level solution many time constrained programmers will opt for the second solution.
<div class="p"><!----></div>
</li>

<li>
The portable specifications provide a common framework for library writers and compiler/system designers to build compatible yet strongly specialized implementations.
<div class="p"><!----></div>
</li>

<li>
The language becomes easier to analyze mathematically.
In their very interesting paper "Precise reasoning for programs using containers", Dillig, Dillig and Aiken
<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a> enumerate three main points that make program analysis easier using containers:

<ol type="1">
<li> Understanding the contents of a container doesn't require understanding the container's implementation
<div class="p"><!----></div>
</li>

<li> Verifying container implementations requires different techniques and degrees of automation than verifying their clients. Hence, separating
these two tasks allows us to choose the verification techniques best suited for each purpose.
<div class="p"><!----></div>
</li>

<li> There are orders of magnitude more clients of a container than there are container implementations. This fact makes it possible to annotate
a handful of library interfaces in order to analyze many programs using these containers.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li> It is possible to abstract from the nature of any container (using the <font size="+1"><tt>iterator</tt></font> construct) what allows a series of algorithms to
be written without having to bind them to a precise data structure. Containers present a uniform interface to the rest of the program.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
<img src="AbstractIterator.png" alt="Figure">

<div class="p"><!----></div>
The big innovation of C in the eighties was its standard library, that made input/output portable across machines and implementations. The container library would replicate again that idea, at a higher level.

<div class="p"><!----></div>
The specifications presented here are completely scoped by the C99 specifications, and can be implemented even in compilers that do not implement C99 and remained within the C94 context. No language extensions are needed nor any are proposed.

<div class="p"><!----></div>
The interfaces proposed try to present complete packages, i.e. interfaces with all the necessary functions to allow the widest usage: Serialization, searching, and many other functionalities are included in the proposed standard to allow for maximum code portability. It can be argued that this makes  for "fat" containers, but if you read carefully you will notice that many things can be left out in systems that run in low memory or with feeble computing power.

<div class="p"><!----></div>
This documentation is composed of several parts:

<ol type="1">
<li> An introductory part where the general lines of the library are explained.
<div class="p"><!----></div>
</li>

<li> A specifications part where each function of the library is fully specified. This is the proposal for the next C standard.
<div class="p"><!----></div>
</li>

<li> An &#235;xamples" part that shows the uses of the library and allows you to have a better idea of how the usage of the library looks like.
<div class="p"><!----></div>
</li>

<li> An implementation part where the code of the sample implementation is discussed. This is designed as a guide for implementors to give them a basis to start with.
<div class="p"><!----></div>
</li>
</ol>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Design goals</h2>

     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Error analysis</h3>
It has been a  tradition in C to place raw performance as the most important quality of specifications. To follow this sacred cow, C specifications
ignored any error analysis arguing that any specification of failure modes would damage "performance". No matter that raw machine performance
increased by several orders of magnitude, the cost of  a check for NULL was always "too expensive" to afford.

<div class="p"><!----></div>
This kind of mental framework was described by one of the people in the discussion group "comp.lang.c++" as follows:<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>

<blockquote>
 In C++, the program is responsible for ensuring that <b>all</b> parameters to
 the standard library functions are valid, not only the third parameter of
 <font size="+1"><tt>std::mismatch()</tt></font>. For example, also the first range for <font size="+1"><tt>std:mismatch()</tt></font>
 must be valid, one may not pass a start iterator from one container and
 end iterator from another, for example. However, STL does not guarantee
 any protection against such errors, this is just UB.
</blockquote>
These specifications try to break away from that frame of thought. Each function specifies a minimal subset of failure modes as a consequence of its 
error analysis. This allows user code to:

<ul>
<li> Detect and handle errors better. Error detection is simple: Almost all functions return a negative
error code when they detect an error condition. Error detection can always test for the result
of any API with:

<font size=+1><pre>
if&nbsp;(SomeCclApi(arg1,arg2)&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;error&nbsp;handling&nbsp;here
}

</pre></font>

<div class="p"><!----></div>
Some functions like the <font size="+1"><tt>Create</tt></font> function return a pointer. In those cases an error provokes a NULL 
pointer result. The error checking in those cases should be:

<font size=+1><pre>
if&nbsp;((r=SomeCclApi(arg1,arg2))&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;error&nbsp;handling&nbsp;here
}

</pre></font>
<div class="p"><!----></div>
</li>

<li> Ensure that errors will always have the <b>same</b> consequences. One of the worst consequences of undefined behavior is that the same error can 
have completely different consequences depending on apparently random factors like previous contents of memory or previous allocation pattern.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
At the same time, the mandatory error checking consists mainly of checks that can be implemented with a few integer comparisons. For instance a check 
for zero is a single instruction in most processors. If implemented correctly the conditional jump after the comparison with zero is not taken in the 
normal case and correctly predicted by the processor. This means that the pipeline is not disturbed and the cost for the whole operation is much less than a cycle.

<div class="p"><!----></div>
Why is error analysis an essential part of any program specifications?

<div class="p"><!----></div>
Because <b>mistakes are a fact of life</b>. Good programmers are good most of the time only. Even very good programmers <i>do make mistakes<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>.</i> Software
must be prepared to cope with this fact in an orderly fashion because if failure modes are not specified they have catastrophic consequences and lead
to brittle software that crashes randomly.

<div class="p"><!----></div>
Note that error <i>analysis</i> is not error <i>handling</i>. Error handling is taking an action after an error, a task only the application can do.
What the library can do is to establish a framework where a user defined procedure receives enough information about the specific problem at hand.

<div class="p"><!----></div>
Error analysis means that for each function and each API:

<ul>
<li> An analysis is performed of what are the consequences of any error in its inputs. Error codes are used to pass detailed error information
to the error procedure.
<div class="p"><!----></div>
</li>

<li> During its execution, an analysis is done of each step that can fail.
<div class="p"><!----></div>
</li>

<li> The outputs of the function are left in a consistent state, errors provoking the undo of the previous steps in most cases, leaving the inputs
as they were before the function was called. This feature allows library functions to be restartable after an error. For instance an out of memory
condition can be corrected by freeing memory and retrying.
<div class="p"><!----></div>
</li>
</ul>
The library provides hooks for the users that can control each step and provide functions that can do the error handling, for instance logging the
error and jumping to a pre-established recovery point.

     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Full feature set</h3>
Another design goal is to offer to the user a full feature set, complete with serializing, iterators, search, read-only containers and all the features 
needed in most
situations. Other features are planned for later like multi-threading support. The objective here is to avoid incompatible and non portable extensions
because some essential feature is missing.

     <h3><a name="tth_sEc1.3">
1.3</a>&nbsp;&nbsp;Abstraction</h3>
The library is designed with the possibility of implementing abstraction like serial and associative containers that allow software to treat several 
containers in a way that abstract most of their features, improving code reuse by allowing to implement algorithms for a class of objects. This is
specially true in the iterators feature.

<div class="p"><!----></div>
It can be argued that the C language lacks many of the abstractions constructs of other languages like templates, inheritance, and many others.
All that is true, but the objective of this proposal is to show that those constructs are just an aid to developing abstractions, an aid that
is paid in added complexity for the resulting language, and in a limitation of what is feasible within a given framework. Since C has no 
framework, no preferred inheritance model, it is possible to create abstractions that are quite unconstrained: there is no framework precisely.

     <h3><a name="tth_sEc1.4">
1.4</a>&nbsp;&nbsp;Performance</h3> Even with all the tests, the performance of the library has been maintained at a high level compared to similar libraries
in other languages. The performance should improve if standardized because compiler writers could specialize their optimizations targeting this
code.

     <h3><a name="tth_sEc1.5">
1.5</a>&nbsp;&nbsp;Compile time checking</h3>
The base implementation of the library uses <font size="+1"><tt>void&nbsp;*</tt></font> everywhere since the library can't know what type
of data the user is storing in it. This means that no compile-time checking can be done on the type of
arguments passed to a library function, what is very error prone.

<div class="p"><!----></div>
To mitigate this problem the library offers a "templated" version of each container, where the user must
write a very small parameter file for a templated version that specifies a container for a specific data
type, allowing for compile time checking of arguments and a simpler syntax.

<div class="p"><!----></div>
Note that no new language features are needed for this to work since it uses the preprocessor to specialize
a file template of the desired container. Most of the containers are provided in these two forms: a generic
version using void pointers and a templated version that builds a software layer between the generic version and
the specialized version allowing for compile time checking.

<div class="p"><!----></div>
To speed up this process specialized versions of the list and vector containers are provided for most of the
basic types of the language: int, doubles, etc.

     <h3><a name="tth_sEc1.6">
1.6</a>&nbsp;&nbsp;Design choices</h3>
The parameter space for a container library is virtually infinite. There are choices and choices to be made and it would be
impossible to explain them all. There are choices done by default (the other possibilities aren't realized or not even considered)
or choices made semi-consciously ("... it is better not to go in that direction") or done because
other choices done before impose them. And there are choices done with full knowledge of the alternatives,
where a conscious choice is done after exploring several possible solutions.

<div class="p"><!----></div>
Here are some examples of design decisions, to show the kind of reasoning that goes into them,
and the priorities schema.

<ul>
<li> Some libraries propose the use of &#239;nvasive" containers where the user defines
some fields <i>within his/her structure definitions</i> where the containers
would have a handle to act. For instance the user defines a single field "Next" within
his data structure definition so that the single linked list container can use it
to perform its operations.

<div class="p"><!----></div>
The problem with this approach is that all the fields necessary must be fully disclosed
to the user. Any change in those fields provokes a recompilation of <i>all</i> user
codes. There isn't really a full separation between the container data structures
and the user's.

<div class="p"><!----></div>
A big design goal is the complete separation of the containers from user's code so that
a new version of the library doesn't need any changes to user code at all, not even
to the binaries. Within the current design the implementor of the library can change
the inner structure of its data structures without affecting at all user's code.
<div class="p"><!----></div>
</li>

<li> Another design decision is to hide or not the container access within macros. Instead
of writing: 

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(myList,&amp;mydata);
&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(myVector,&amp;mydata)&nbsp;
//&nbsp;that&nbsp;would&nbsp;be&nbsp;replaced&nbsp;by
#define&nbsp;CCL_ListAdd(List,data)&nbsp;iList.Add(List,&amp;data)
#define&nbsp;CCL_VectorAdd(Vector,data)&nbsp;iVector.Add(Vector,&amp;data)
//&nbsp;...&nbsp;etc

</pre></font>

<div class="p"><!----></div>
This  has been a very difficult design decision, and one that is not closed yet.
The advantage of this is that the implementor can then make hidden functions that
inline calls, and in general increase the speed of the generated code. 

<div class="p"><!----></div>
Another advantage is that the linker
doesn't need to include <b>all</b> members of the list container but only
those that are used into the final executable.

<div class="p"><!----></div>
The problem is that this is (in my opinion) <b>too</b> flexible and hides
completely what is happening from the user. Another problem is that even if the
new names are all prefixed (here with <font size="+1"><tt>CCL_</tt></font>) name clashes can occur. The
resulting names are quite long also, even if typing <font size="+1"><tt>iList.Add</tt></font> is also
quite long.

<div class="p"><!----></div>
Here the decision is not definitive since at any moment a set of macros can be added
to the library.
<div class="p"><!----></div>
</li>
</ul>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;How the functions are specified in this document.</h2>
The specifications part of the proposal uses the same building blocks for each of the functions proposed.
<div class="p"><!----></div>
<b>Name</b>

<div class="p"><!----></div>
 The name of the function. Note that when using this name, the name of the container interface should be always before 
since this name is a field of the interface structure:

<div class="p"><!----></div>
 <font size="+1"><tt>iList.Add</tt></font>, <font size="+1"><tt>iDictionary.Add</tt></font>, etc.

<div class="p"><!----></div>
 The name is followed by the prototype defined as a function pointer. For the function <font size="+1"><tt>Add</tt></font> of the container <font size="+1"><tt>List</tt></font> we have

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(List&nbsp;*list,const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(TYPEList&nbsp;*list,const&nbsp;TYPE&nbsp;data);

</pre></font> 
This means that <font size="+1"><tt>Add</tt></font> is a function pointer in the interface <font size="+1"><tt>iList</tt></font>. It would be used as:
<font size="+1"><tt>iList.Add(list,data)</tt></font>.
The second line corresponds to the <i>template</i> form of the API. This is explained further down (&#167; <a href="#TwoTypes"> 2.2Overview</a> page-<a href="#TwoTypes">pageref</a>) and
it is specified only when the signature of the API diverges from the generic one. The <font size="+1"><tt>TYPE</tt></font> marker means that
a type name should appear there: in the example it could be intList, doubleList, CustomerList, etc.

<div class="p"><!----></div>

  <b>Description:</b> The API is described: purpose, inputs and outputs. Note that unmodified arguments are always marked
as <font size="+1"><tt>const</tt></font>.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>
The minimal set of errors that can appear during the execution of the function is listed. Each implementation 
is free to add implementation specific errors to this list. Note that how the library behaves after an error is 
defined by the current error function in the container (if any), then by the behavior of the error function in the 
<font size="+1"><tt>iError</tt></font> interface.

<div class="p"><!----></div>

<b>Returns:</b>
The return value of the operation. Normally, negative values are error codes, positive values means success, and zero means non fatal errors, more in the sense of a warning.

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Which sections of this document are normative?</h2>
This document presents the C container Library to the C standardization committee. The following sections are normative:

<ul>
<li> Chapter 4: The auxiliary interfaces. The required interfaces are:


<ul>
<li> The mask interface
<div class="p"><!----></div>
</li>

<li> The memory management interface
<div class="p"><!----></div>
</li>

<li> The error handling interface
<div class="p"><!----></div>
</li>

<li> The iterator interface
<div class="p"><!----></div>
</li>

<li> The observer interface

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
The heap and pool interfaces are optional.
<div class="p"><!----></div>
</li>

<li> Chapter 5: The containers:

<center>

<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table border="1">
<tr><td width="106"><b>Container</b></td><td width="118"><b>Interface</b></td><td width="82"><b>Required?</b></td><td width="237"><b>Short description</b></td></tr>
<tr><td width="106">BitString</td><td width="118">iBitString</td><td width="82"> </td><td width="237"><font size="-2">Sequence of bits</td></tr>
<tr><td width="106">BloomFilter</td><td width="118">iBloomFilter</td><td width="82"> </td><td width="237"><font size="-2">Statistical container</td></tr>
<tr><td width="106">CircularBuffer</td><td width="118">iCircularBuffer</td><td width="82"> </td><td width="237"><font size="-2">Retains the last n items</td></tr>
<tr><td width="106">Deque</td><td width="118">iDeque</td><td width="82"> </td><td width="237"><font size="-2">Queue with fast insertions at both ends.</td></tr>
<tr><td width="106">Dictionary</td><td width="118">iDictionary</td><td width="82"></td><td width="237"><font size="-2">Associates a character key to arbitrary data. </td></tr>
<tr><td width="106">Dlist</td><td width="118">iDlist</td><td width="82"> </td><td width="237"><font size="-2">Double linked list</td></tr>
<tr><td width="106">HashTable</td><td width="118">iHashTable</td><td width="82"> </td><td width="237"><font size="-2">Associates a key with data.</td></tr>
<tr><td width="106">List</td><td width="118">iList</td><td width="82"> </td><td width="237"><font size="-2">Single linked list.</td></tr>
<tr><td width="106">Queue</td><td width="118">iQueue</td><td width="82"> </td><td width="237"><font size="-2">First in, first out container.</td></tr>
<tr><td width="106">PQueue</td><td width="118">iPriorityQueue</td><td width="82"> </td><td width="237"><font size="-2">Pull out items by priority.</td></tr>
<tr><td width="106">StreamBuffer</td><td width="118">iStreamBuffer</td><td width="82"> </td><td width="237"><font size="-2">Sequence of bytes.</td></tr>
<tr><td width="106">StringList</td><td width="118">iStringList</td><td width="82"></td><td width="237"><font size="-2">List of character strings.</td></tr>
<tr><td width="106">strCollection</td><td width="118">istrCollection</td><td width="82"> </td><td width="237"><font size="-2">Array of character strings.</td></tr>
<tr><td width="106">TreeMap</td><td width="118">iTreeMap</td><td width="82"> </td><td width="237"><font size="-2">Tree structure associates key with data.</td></tr>
<tr><td width="106">Value array</td><td width="118">iValArrayXXX</td><td width="82"> </td><td width="237"><font size="-2">Vector of numbers.<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a></td></tr>
<tr><td width="106">Vector</td><td width="118">iVector</td><td width="82"> </td><td width="237"><font size="-2">General resizable vector</td></tr>
<tr><td width="106">WstrCollection</td><td width="118">iWstrCollection</td><td width="82"></td><td width="237"><font size="-2">Array of wide character strings.</td></tr>
<tr><td width="106"></td></tr></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></table>
</center>
<div class="p"><!----></div>
</center>
<div class="p"><!----></div>
</li>
</ul>
All text in footnotes, tables or drawings is not normative.

<div class="p"><!----></div>
The order of the APIs within each interface is implementation defined. In general no assumptions should 
exist about any specific layout of the interfaces or data structures in the library. In the documentation
the APIs are listed following the alphabetical order.

<div class="p"><!----></div>
The code of the sample implementation can be obtained from:

<div class="p"><!----></div>
<font size="+1"><tt>http://code.google.com/p/ccl/</tt></font>

<div class="p"><!----></div>
Go to Downloads and there you will find the documentation (this document) and the source code in the form of a <font size="+1"><tt>ccl.zip</tt></font> file.
<a 
name="Download+source30"></a> See also the chapter about the sample implementation in this document.

<div class="p"><!----></div>
 <h1><a name="tth_chAp3">
Chapter 3 </a><br />Overview</h1>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Containers</h2>
In the context of this library, a container is a data structure used to organize data within a single logical object that allows for adding, searching 
and removing data. In most containers the data is not further specified, but the library assumes that all elements of a container have the same type. 
The data can be anything, images, numbers, text, whatever. The only thing that the container knows is the size of the data, if we store a series of 
objects of the same size, or its address, if we store objects of different sizes. In the later case we store just a pointer in the 
container<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a>.

<div class="p"><!----></div>
A special kind of containers, ValArrays, contain the basic types of the C language and the library treats them specially. There is one ValArray
for each elementary type. For character strings they are stored in &#223;tring collections", a term borrowed from the C# language.

<div class="p"><!----></div>
Each container has a way of iterating through all its elements by using an &#239;terator" auxiliary object, that returns each stored object in sequence. In 
sequential containers you can also iterate using an index variable, what can be cheaper than using iterators for arrays but very expensive in lists.

<div class="p"><!----></div>
All objects stored by the library are copied into the library, and the library is responsible for the management of the associated storage. If you do not want this, just store a pointer to the data and manage the data yourself.

<div class="p"><!----></div>
A container has a set of functions for accessing the elements it stores, called its <i>interface</i>. This object is a collection of function
pointers that provide the functionality of the container.  The interfaces are stored in writable memory and the user can, at run time, change the
behavior of a class of containers by changing the function pointer. This operation is called &#223;ubclassing" in this document.

<div class="p"><!----></div>
Subclassing allows the user to modify the behavior of a container, maybe adding some functionality, without having to write all the container from
scratch. The user of the library can:

<ul>
<li> Use the stored pointer to the original function to call the original functionality, and add some functionality after that call.
<div class="p"><!----></div>
</li>

<li> Add some functionality and call the stored pointer afterwards.
<div class="p"><!----></div>
</li>

<li> Replace completely the functionality by its own without calling any of the former functions.
<div class="p"><!----></div>
</li>
</ul>
Subclassing adds enormous flexibility to this design, since it makes possible to add functionality in a transparent way.

<div class="p"><!----></div>
Using the organization of the data as a classification criteria we have basically two different kinds of containers

<ul>
<li>1. Sequential containers
<div class="p"><!----></div>
</li>

<li>
2. Associative containers
<div class="p"><!----></div>
</li>

<li>
3. Statistical Containers
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
A sequential container is organized in a linear order. We have a sequence starting at index zero up to the number of elements stored. Data items can be 
retrieved by index, and it makes sense to speak of a "next" and a "previous" element.

<div class="p"><!----></div>
Sequential containers can be contiguous (arrays) or disjoint (lists). In the first case access is very fast since it implies multiplying the index by 
the size of each element to get to any position in the data. In the second case access the nth element can be a lengthy operation since the chain of 
"next" or "previous" pointers must be followed for each access to a given position.

<div class="p"><!----></div>
An associative container stores an object divided in two parts: a key, that is used as a token for the data, and the data itself. It associates 
key/value pairs. Speed of access is fast, but not linear, and can degrade as new items are stored in it.

<div class="p"><!----></div>
Statistical containers are containers that return the probability of an item being found in them. See the bloom filter as an example.

<div class="p"><!----></div>
In all cases, we have some basic properties of an abstract container that are common to all of them. 

<ul>
<li> Functions to implement the life-cycle of the object: creation, maintenance and destruction.
<div class="p"><!----></div>
</li>

<li> Functions to add, replace and remove elements from the container.
<div class="p"><!----></div>
</li>

<li> A function that returns the number of objects stored in the container.
<div class="p"><!----></div>
</li>

<li>
A function to report errors. This function (like all other function pointers) can be changed by the user of the library. In the sample implementation 
it defaults to a simple function that prints the error in the standard error stream.
<div class="p"><!----></div>
</li>

<li>
Each change in a container is recorded. This permits to validate pointers to a container: if the container has changed after the creation of the pointer, the pointer could be invalid.
<div class="p"><!----></div>
</li>

<li>
All containers use a standard object to allocate and manage memory. The library provides a default allocator that contains the standard C functions malloc, free, realloc and calloc. Each container class can contain an allocator pointer, or each container can contain an allocator. The provided
sample implementation has a per container allocator, but in many applications a per class allocator could be enough, or even a single global allocator
that would be used by the whole library.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Managing a sequence involves trade offs what performance is concerned. If the usage will involve frequent insertion and deletion of objects you will 
prefer a container that handles those operations in constant time: the time to add or delete an object doesn't increase with the number of elements in 
the container. Such a container will be unlikely to provide also access to a given element in constant time. Access is likely to be much slower, and 
what you gain in flexibility you loose in another dimension. It is the user of the library, the programmer, that decides what container fits best the 
intended usage.

<div class="p"><!----></div>
Since usage patterns change, however, the library tries to ensure that you can change the container you are using with minimal effort. If at the 
beginning of an application a list looked like a good solution but later an array, that provides constant time access is better suited, you can change 
the type of container without changing every line that uses it. The common vocabulary of the library makes this possible.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;The two types of interface</h2>
<a name="TwoTypes">
</a>
The library proposes two types of access:

<ul>
<li> A generic approach using <font size="+1"><tt>void&nbsp;*</tt></font>. This interface allows you to pass a pointer to the data and specify at creation time the size of the 
object you want to store in the container. There is no checking at compile-time of the validity of the pointer and the associated data. There is no 
checking at run time either since the software has no information to check something.
<div class="p"><!----></div>
</li>

<li> A templated generic approach where at compile time a <i>templated</i> file is specialized for a concrete type by writing a parameter file
where some macros are defined that are used by the templated file as arguments. The user of the library is required to write that file, compile
it, and adding the resulting object files to a user-specific library (or to the general containers library if he/she wishes) so that the linker finds 
them when needed.
<div class="p"><!----></div>
</li>
</ul>
The functions to call, their names, etc, are the same in both approaches with one important exception: the templated approach needs an object instead 
of a <font size="+1"><tt>void&nbsp;*</tt></font> to the data as parameter, and returns an object instead of a void pointer to the data.

<div class="p"><!----></div>
For instance, when writing for the generic interface you use:

<font size=+1><pre>
double&nbsp;MyDouble;
List&nbsp;*myList;
myList&nbsp;=&nbsp;iList.Create(sizeof(double));
//&nbsp;...
iList.Add(myList,&amp;myDouble);

</pre></font>

<div class="p"><!----></div>
For the templated interface you use:

<font size=+1><pre>
double&nbsp;MyDouble;
doubleList&nbsp;*myList;
myList&nbsp;=&nbsp;idoubleList.Create();
//&nbsp;...
idoubleList.Add(myList,myDouble);

</pre></font>

<div class="p"><!----></div>
Naming rules allow the user of the templated library to easily add
the required names to its program and use them. The naming rules are explained further down.

<div class="p"><!----></div>
The drawback of the second approach is a bigger complexity of the compilation process. When using a template container the user must:

<ul>
<li> Give the parameters that the templated file needs. In most cases the minimum requirements are that the data type is specified:

<font size=+1><pre>
#undef&nbsp;DATA_TYPE
#define&nbsp;DATA_TYPE&nbsp;Customer
#include&nbsp;"listgen.h"

</pre></font>

<div class="p"><!----></div>
This will produce the definitions of the following types:

<ul>
<li> The <font size="+1"><tt>CustomerList</tt></font> container and its <font size="+1"><tt>iCustomerList</tt></font> interface.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>iCustomerListIterator</tt></font>: an iterator type ready to be used with any <font size="+1"><tt>CustomerList</tt></font> containers.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Include the type specific header. For instance <font size="+1"><tt>#include&nbsp;"Customerlist.h"</tt></font>. All client code that uses the derived container must
include that header.
<div class="p"><!----></div>
</li>

<li> Compile the instantiation of the template:

<font size=+1><pre>
#undef&nbsp;DATA_TYPE
#define&nbsp;DATA_TYPE&nbsp;Customer
#include&nbsp;"listgen.c"

</pre></font>

<div class="p"><!----></div>
The resulting object file must be present at link time, either stand alone or within a library.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;The interface concept</h2>
Each container is defined by its interface, i.e. the table of functions it supports. For each interface, its name is composed of a lower case &#239;" followed by the container name: <font size="+1"><tt>iList</tt></font>, <font size="+1"><tt>iVector</tt></font>, <font size="+1"><tt>istrCollection</tt></font>, etc.

<div class="p"><!----></div>
Each function of the interface receives always the container as its first argument. Obviously, the big exception is the creation function, that receives various arguments depending of which container or from what input, the container is to be created.

<div class="p"><!----></div>
For each container interface a global object exists that allows direct access to the function table without the need of creating a container to access it.

<div class="p"><!----></div>
This interface allows for simple access to each container using a very similar vocabulary:

<font size=+1><pre>
iList.Add(list,object);
istrCollection.Add(strcol,object);

</pre></font>
The objects stored in a container have always the same size. When storing objects of different sizes just store a pointer to the objects, since pointers have always the same size.

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Error handling</h2>
This specification describes the basic error handling that each function of the library must do. Other errors can appear in different implementations.

<div class="p"><!----></div>
Error handling has three different phases:

<ol type="1">
<li> <b>Detection</b>. All library functions detect blatantly wrong arguments for instance, a &nbsp;NULL pointer when an object is expected, or arguments out of their valid range, etc.
<div class="p"><!----></div>
</li>

<li> <b>Reporting.</b> When an error is detected the library calls the corresponding error function that receives a character string with the name of the 
function where the error was detected, an integer error code, and possibly other arguments. Error codes are always negative constants.
<div class="p"><!----></div>
</li>

<li> <b>Response.</b> The library's default response to an error is to print it in the standard error stream. This can be modified by the user at any time by calling the <font size="+1"><tt>SetErrorFunction</tt></font> API, replacing the default behavior with its own.

<div class="p"><!----></div>
The response strategy can be changed at two levels <a href="#tthFtNtAAG" name="tthFrefAAG"><sup>6</sup></a>:


<ul>
<li> At the individual container level, by changing the error function called in  most cases when an error occurs for this specific container. One API of the <font size="+1"><tt>iError</tt></font> interface, the <font size="+1"><tt>SetErrorFunction</tt></font> API, is specifically designed for this purpose.
<div class="p"><!----></div>
</li>

<li> At the container library level by changing the default error function in the <font size="+1"><tt>iError</tt></font> interface.

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
At each error, the library calls the container instance specific error handling function. This function is initialized to the default error
function of the library when the container is created. When it is not possible to call the instance specific error function, for instance when the 
instance parameter is &nbsp;NULL , the library calls the general error handling function in the iError interface<a href="#tthFtNtAAH" name="tthFrefAAH"><sup>7</sup></a>.

<div class="p"><!----></div>
The user of the library can either replace the default iError interface with a function that handles the error with a jump to a previously set recovery point, or treat the error locally using the return code. 

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Return code</h3>
All errors are negative constants, it suffices to test if the result is less than zero. In general we have:

<center>
<img src="feux.png" alt="Figure">
</center>
In the positive return code some implementations may encode additional information. The sample implementation returns always 1
<a href="#tthFtNtAAI" name="tthFrefAAI"><sup>8</sup></a>. The zero return value means that nothing was done: it isn't an error but the container was empty for instance, or nothing was written to a 
file, etc. 

<div class="p"><!----></div>
The treatment of each error is done in the object defined by the <font size="+1"><tt>iError</tt></font> interface.

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Naming conventions</h2>

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Container Names</h3>
The basic container names are:

<center>

<table border="1"><tr><td></td></tr>
<tr><td align="center">AssociativeContainer</td><td align="center">BitString</td><td align="center">BloomFilter</td></tr>
<tr><td align="center">CircularBuffer</td><td align="center">Dictionary</td><td align="center">Dlist</td></tr>
<tr><td align="center">Deque</td><td align="center">HashTable</td><td align="center">List</td></tr>
<tr><td align="center">Mask</td><td align="center">PQueue</td><td align="center">Queue</td></tr>
<tr><td align="center">SequentialContainer</td><td align="center">strCollection</td><td align="center">StreamBuffer</td></tr>
<tr><td align="center">TreeMap</td><td align="center">Vector</td><td align="center">WstrCollection</td></tr><tr><td></td></tr></table>

</center>

     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Interface object name</h3>
All APIs of the library begin with the composite name formed by the letter <font size="+1"><tt>i</tt></font>, followed by the element type name in the templated versions,
then the container name. This builds the interface name, i.e. the name of the function table object. This object is indexed by the name of the specific API being called. 

<div class="p"><!----></div>
For calling the <font size="+1"><tt>Add</tt></font> API of the <font size="+1"><tt>List</tt></font> container you would write: 
<div class="p"><!----></div>
<font size="+1"><tt>iList.Add</tt></font>. This uses the generic implementation with <font size="+1"><tt>void&nbsp;*</tt></font>.

<div class="p"><!----></div>
For calling the <font size="+1"><tt>Add</tt></font> API of the <font size="+1"><tt>Vector</tt></font> container built from <font size="+1"><tt>double</tt></font> objects you would write:

<div class="p"><!----></div>
 <font size="+1"><tt>idoubleVector.Add</tt></font>. This uses the template implementation with a specific type, in this case the <font size="+1"><tt>double</tt></font> type.

<div class="p"><!----></div>
The interface object <font size="+1"><tt>idoubleVector</tt></font> has one field for each API it supports. The same for the interface object <font size="+1"><tt>iVector</tt></font> that is
a generic interface (uses and returns <font size="+1"><tt>void&nbsp;*</tt></font> instead of specific types). 

<div class="p"><!----></div>
Other containers like the list container would have the equivalent API named as: 

<div class="p"><!----></div>
<font size="+1"><tt>idoubleList.Add</tt></font>, or <font size="+1"><tt>iList.Add</tt></font>.

<div class="p"><!----></div>
The following drawing tries to make this clear:

<div class="p"><!----></div>
<img src="NamingConventions.png" alt="Figure">

<div class="p"><!----></div>
The different containers built from a basic container (say <font size="+1"><tt>List</tt></font>) are named by concatenating the name of the type and the name of the container:
<font size="+1"><tt>intList</tt></font>, <font size="+1"><tt>doubleList</tt></font> etc.

<div class="p"><!----></div>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;The different containers</h2>
All data structures in this section are known and used for several decades. Lists are a common feature of any data processing task since the sixties for instance. 
The library provides for abstract containers, and some examples of concrete ones for the elementary types.
We have:

<ul>
<li>Vectors. The general abstract vector container is implemented in the "Vector" container. This is a flexible array that allows for insertion/deletions, 
with no cost for insertion at the end in most cases. Concrete implementations for the elementary types are provided for bits (bit-strings), strings 
(null terminated), int/double/long double numeric data in the form of templates.

<div class="p"><!----></div>
Use this container when you need very cheap traversal and access times. Insertion are deletion are more expensive than in lists. The memory overhead is minimal.
<div class="p"><!----></div>
</li>

<li>
Lists. Single linked lists (List) and double linked lists (Dlist) are provided. Lists of strings and wide character strings are specified too. Memory overhead is one pointer for element in single linked lists, two pointers in double linked lists.

<div class="p"><!----></div>
Use this container when you need very cheap insertion and deletion access times. Traversal is more expensive than in vectors.
<div class="p"><!----></div>
</li>

<li>
Queue, Deque, Priority Queue.

<div class="p"><!----></div>
Use this containers when retrieval order is important and determined by the container.
<div class="p"><!----></div>
</li>

<li>
Trees (red/black trees, AVL trees)

<div class="p"><!----></div>
Use this container when finding a given element is primordial. Insertion, deletions and traversal times are more expensive.
<div class="p"><!----></div>
</li>

<li>
Dictionary. This is a simple implementation of a hash table with character keys. It comes in two flavors<a href="#tthFtNtAAJ" name="tthFrefAAJ"><sup>9</sup></a>
: 

<ol type="1">
<li> Single byte character keys
<div class="p"><!----></div>
</li>

<li> Wide character keys
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
Use this container when speed of retrieval is of paramount importance but you want to avoid the overhead of a tree.
<div class="p"><!----></div>
</li>

<li>
Hash Table. More complex implementation of a hash table with arbitrary (binary) keys, and automatic hash table resizing.

<div class="p"><!----></div>
Use this container when the key of your dictionary is not in the form of text.
<div class="p"><!----></div>
</li>

<li> Buffers. Stream buffers (linear buffers that resize to accommodate more data) and circular buffers are provided.

<div class="p"><!----></div>
Use stream buffers when you need growable temporary data. Use circular buffers when you need to retain the nth last elements of a stream.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp; Single and double linked lists</h3>

<div class="p"><!----></div>
<img src="SingleLinkedList.png" alt="Figure">

<div class="p"><!----></div>
This containers consist of a header and a list of elements containing each a pointer to the next element in the chain, and a pointer to the data item 
stored. The end of the list is marked by a node that contains a &nbsp;NULL "next" pointer. Double linked lists contain an additional pointer to the previous 
element.

<div class="p"><!----></div>
This is a very flexible container, allowing you to add and delete elements easily just by rewriting some pointers. You can even split them in two 
sublists just by zeroing somewhere the "next" pointer.

<div class="p"><!----></div>
The price you pay for this flexibility is that sequential access is expensive, the cost of accessing the nth element increases linearly with n.

<div class="p"><!----></div>
Storage overhead is one or two pointers per element stored in the list for single/double linked lists..

<div class="p"><!----></div>
The data is stored directly after the pointer, there is no pointer to the data. This is a variable length structure with a fixed and a variable part. 
To avoid using a standard C99 feature that could be absent in older compilers, we use a semi-generic pointer indexed either by one (for older compilers) or by nothing (standard C).

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.1.1">
6.1.1</a>&nbsp;&nbsp;Single linked lists of byte or wide character strings</h4>
A specialization of the single linked list is provided for multibyte or wide character strings. The rationale for this specialization is that
zero terminated strings are variable length records what would make them impossible to store into a standard list that needs records of the
same size.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Flexible arrays (vector)</h3>
This container is an array with added operations that allow the user to insert and delete elements easily. It will resize itself if needed.

<div class="p"><!----></div>
The access time is essentially the same as with a normal array. Insertion and deletion are possible but they are in general more expensive than with lists since the container must copy the elements to make place for a new element or to delete an element. An exception to this rule is the deletion of the last element that will be done in constant time since it implies only decrementing the number of elements in the container.

<div class="p"><!----></div>
The storage overhead for each element is zero since this container doesn't require any pointers per object stored.

<div class="p"><!----></div>
This container uses a reserve storage to avoid allocating new memory for each addition operation. This allows the <font size="+1"><tt>Add</tt></font> operation to be done in constant time in most occasions.

<div class="p"><!----></div>
Comparing vectors with plain arrays, there are following points to be made:

<ul>
<li> With plain arrays, a program cannot determine the array's capacity, which is to say, its dimension when it was allocated.  
The program code must supply this information independently, and must maintain that information always current.
<div class="p"><!----></div>
</li>

<li> There isn't any simple way to increase the size of our array, once it’s been allocated.  We often need to do that, rather than try to figure out 
in advance how large it should be.
<div class="p"><!----></div>
</li>

<li> When accessing the array there is no automatic way to check if the index is within bounds. We have to program all array access specially
if we want to make sure there are no index errors.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;ValArray: Arrays of numbers</h3>
This group is an specialization of flexible array. It features objects that contain numbers in different formats designed to facilitate operations
in numerical programming. There are ValArrays for the types <font size="+1"><tt>short</tt></font>, <font size="+1"><tt>int</tt></font>, <font size="+1"><tt>long</tt></font>, <font size="+1"><tt>float</tt></font>, <font size="+1"><tt>double</tt></font>,
<font size="+1"><tt>long double</tt></font>, <font size="+1"><tt>size_t</tt></font> and <font size="+1"><tt>long long</tt></font>. Each <font size="+1"><tt>ValArray</tt></font> has the same basic operations (addition, subtraction, etc)
but some members have specialized operations: trigonometric operations are defined only in floating point ValArrays, boolean operations only in the unsigned versions of the <font size="+1"><tt>int/short</tt></font> and the <font size="+1"><tt>long long</tt></font> types.

<div class="p"><!----></div>
ValArray functions come often in two flavors: The first uses two arrays where the left argument is both source and destination, and a second form where
a number is applied to the whole array. For instance we have <font size="+1"><tt>AddTo(leftArray</tt></font><b>,</b><font size="+1"><tt>rightArray)</tt></font> and <font size="+1"><tt>AddToScalar(Array</tt></font><b>,</b><font size="+1"><tt>number)</tt></font>.

     <h3><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;String collection</h3>
This container is designed to handle a collection of C strings. It is essentially an application of the flexible array container with some extra functionality to handle strings. It comes in two flavors, as strings in C: multi-byte and wide character strings.

     <h3><a name="tth_sEc6.5">
6.5</a>&nbsp;&nbsp;Bit-string</h3>
This container is designed to handle arbitrary sequences of bits. Some algorithms that are easy to program with strings are much more complicated for bit-strings, like to one that mimics &#223;trstr" ("bit-strstr"). 

<div class="p"><!----></div>
The bits are packed with 8 bits per character unit. The overhead per bit is the size of the bit-string header only. No pointers are associated with each bit.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.6">
6.6</a>&nbsp;&nbsp;Dictionary</h3>

<div class="p"><!----></div>
<img src="HashTable.png" alt="Figure">

<div class="p"><!----></div>
This is an associative container based on a hash table. It associates a text key with some arbitrary data. This container is not ordered. Access time to each element depends on how much elements are stored in it and on the efficacy of the hash function to maintain elements in different slots. Storage overhead per element is one pointer each, plus the size of the slot table. This is for a hash table with linked lists in each slot for managing collisions. Other implementations exist of course.

     <h3><a name="tth_sEc6.7">
6.7</a>&nbsp;&nbsp;Hash Table</h3>
This is a more sophisticated version of the dictionary hash table. It allows for keys of binary data and it has automatic resizing in case the table gets too crowded.

     <h3><a name="tth_sEc6.8">
6.8</a>&nbsp;&nbsp;AVL trees</h3>
This data structure allows for fast searching for data. You can store millions of records and find a given record with a few comparisons.

     <h3><a name="tth_sEc6.9">
6.9</a>&nbsp;&nbsp;Scapegoat trees</h3>
This is another form of trees. They can be more efficient than AVL trees, but from a container perspective they share the same characteristics.

     <h3><a name="tth_sEc6.10">
6.10</a>&nbsp;&nbsp;Bloom Filter</h3>
This is a probabilistic data structure used to quickly check if an element is not in a larger set of elements. It returns false positives with a given probability set when the container is built. Elements can be added to it but they can't be removed from the container. It stores no data, just a key.

     <h3><a name="tth_sEc6.11">
6.11</a>&nbsp;&nbsp;Queue</h3>
Queues are designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the 
other. This container can be implemented as an adaptor using a single linked list as its base container. The sample implementation uses this strategy 
to show how adapters can look like. Other implementations can implement this container directly presenting the same interface.

     <h3><a name="tth_sEc6.12">
6.12</a>&nbsp;&nbsp;Deque</h3>
This is a linear container that allows for cheap insertions/deletions at both ends.

     <h3><a name="tth_sEc6.13">
6.13</a>&nbsp;&nbsp;Buffers</h3>
Buffers are containers used to hold data temporarily, either to be transmitted or stored into some medium, or to be filtered and used later
by other parts of the application. The library provides two types of buffers:

<ul>
<li> Stream buffers. They are a linear sequence of bytes, like a file. They resize automatically if they need to, and they have a <i>cursor</i>
that points to the position where the next item will be stored.
<div class="p"><!----></div>
</li>

<li> Circular buffers. They store the last <i>n</i> items of a stream. They can contain any item as in the vector container, or they can contain 
character strings, as in the string collection.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc6.14">
6.14</a>&nbsp;&nbsp;Priority Queues</h3>
This container stores data associated with an integer "priority". The meaning of this integer is not further specified and defined by the application.
The <font size="+1"><tt>Pop</tt></font> operation retrieves the data associated with the <i>lowest</i> priority. 

     <h3><a name="tth_sEc6.15">
6.15</a>&nbsp;&nbsp;At a glance</h3>



<center>


<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table border="1">
<tr><td width="118"><b>Container</b></td><td width="118"><b>Interface</b></td><td width="276"><b>Description </b></td></tr><tr><td></td></tr>
<tr><td width="118">BitString</td><td width="118">iBitString</td><td width="276">Growable array of bits </td></tr>
<tr><td width="118">BloomFilter</td><td width="118">iBloomFilter</td><td width="276">Statistical container </td></tr>
<tr><td width="118">CircularBuffer</td><td width="118">iCircularBuffer</td><td width="276">Circular buffer </td></tr>
<tr><td width="118">Deque</td><td width="118">iDeque</td><td width="276">Double ended queue </td></tr>
<tr><td width="118">Dictionary</td><td width="118">iDictionary</td><td width="276">Hash table with character keys </td></tr>
<tr><td width="118">Dlist</td><td width="118">iDlist</td><td width="276">Double linked list </td></tr>
<tr><td width="118">HashTable</td><td width="118">iHashTable</td><td width="276">Hash tables with arbitrary binary keys </td></tr>
<tr><td width="118">List</td><td width="118">iList</td><td width="276">Single linked list </td></tr>
<tr><td width="118">Queue</td><td width="118">iQueue</td><td width="276">Queue </td></tr>
<tr><td width="118">PQueue</td><td width="118">iPriorityQueue</td><td width="276">Priority queue. </td></tr>
<tr><td width="118">StreamBuffer</td><td width="118">iStreamBuffer</td><td width="276">Stream buffer </td></tr>
<tr><td width="118">StringList</td><td width="118">iStringList</td><td width="276">Single linked list of strings</td></tr>
<tr><td width="118">strCollection</td><td width="118">istrCollection</td><td width="276">Flexible string arrays. </td></tr>
<tr><td width="118">TreeMap</td><td width="118">iTreeMap</td><td width="276">Scapegoat trees </td></tr>
<tr><td width="118">Value array</td><td width="118">iValArrayXXX</td><td width="276">Growable array of numbers </td></tr>
<tr><td width="118">Vector</td><td width="118">iVector</td><td width="276">Growable array of arbitrary objects </td></tr>
<tr><td width="118">WstrCollection</td><td width="118">iWstrCollection</td><td width="276">Flexible array of wide character strings</td></tr>
<tr><td width="118"></td></tr></table>
</center>
<div class="p"><!----></div>
</center> 
 <h1><a name="tth_chAp4">
Chapter 4 </a><br />The common vocabulary</h1>
The library uses always the same words to represent similar actions in all containers. In addition, each container can use specific words to name actions that are specific to it. In this section only the common actions will be documented, to give an overview of the common vocabulary available.<a href="#tthFtNtABA" name="tthFrefABA"><sup>10</sup></a>

<div class="p"><!----></div>
At the end of this documentation you will find a complete table that lists each action supported by the library and marks which container supports it.

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Creation of a container: Create</h2>
<a 
name="Create10"></a>
Containers are created with a call to their "Create" function.  The first argument is the size of the objects that will be stored in the container. The second is optional and is a hint to the number of elements that will be stored in the container.
Note that if you want to store objects of different sizes you just store a pointer to those objects instead of the objects themselves.
The creation functions can have several arguments, the first being always the size of the elements that the container will hold. The prototype can be:

<font size=+1><pre>
Container&nbsp;*&nbsp;iContainer.Create(size_t&nbsp;elementsize,...);

</pre></font>
The creation function needs to allocate memory to hold the container. This memory will be allocated using the current memory manager that is always an implicit argument to all creation functions. The rationale behind this design decision is that you don't change your memory allocation strategy at each call to a container creation function. This simplifies the interface at the expense of making the change of allocation strategy more expensive.

<div class="p"><!----></div>
There is an abstract class of objects called "Generic container" that has all functions that are common to all containers. This is an abstraction,
and as such, it can't have any concrete examples: there is no creation function for a generic container. You can only create a concrete container, a list, a vector, etc. 

<div class="p"><!----></div>
Once created, and if the created container supports the generic interface, you can make a cast and treat the concrete container as an abstract member
of a mythical "generic" container. This can save you a lot of redundant code since your code is independent of the type of container and will run
with any object (even future objects) that support the generic container interface.

<div class="p"><!----></div>
<img src="Vocabulary.png" alt="Figure">
<div class="p"><!----></div>
As everything, there is no free lunch. Precisely because of its generality the generic interface is missing a lot of functionality that you will find
in the concrete containers interfaces. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Destruction of a container: Clear and Finalize</h2>
<a 
name="Clear20"></a><a 
name="Finalize20"></a>
All containers support two cleanup functions:
	
<ol type="1">
<li>Clear: remove all elements. The header structure remains untouched. This can be used to free the memory when the container was created with the <font size="+1"><tt>Init</tt></font> function.
<div class="p"><!----></div>
</li>

<li>
Finalize: Remove all elements and the memory used by the container object using the allocator for this container. The container should NOT have been created using the <font size="+1"><tt>Init</tt></font> function.
<div class="p"><!----></div>
</li>
</ol>
The syntax is:

<ol type="1">
<li> <font size="+1"><tt>int iContainer.Clear(Container *);</tt></font>
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>int iContainer.Finalize(Container *);</tt></font>
<div class="p"><!----></div>
</li>
</ol>
The result of those functions is less than zero when something goes wrong, greater than zero otherwise.

     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Other creation functions</h3>

<ol type="1">
<li>An implicit argument to all the creation functions is the current allocator, that is used to retrieve space for the container being built. To avoid changing the current allocator, what in multi-threaded environment would need acquiring a lock to that global variable, some containers support a creation function that receives an extra argument: a custom allocator.<a href="#tthFtNtABB" name="tthFrefABB"><sup>11</sup></a>

<font size=+1><pre>
Container&nbsp;*&nbsp;iContainer.CreateWithAllocator(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*allocator,&nbsp;...);

</pre></font>
<div class="p"><!----></div>
</li>

<li>
Sometimes it can be useful for some containers (specially lists) to create the  header structure using an already existing space, for instance in the space for local variables. For this an 'Init' function can exist, that initializes a container within an existing space.
Since normally the detailed structure (and the size of course) of each container header is implementation dependent, you use the Sizeof function with an argument of &nbsp;NULL to get the size of the header. This can be used within a C99 compiler environment to allocate the space for that variable.
<a href="#tthFtNtABC" name="tthFrefABC"><sup>12</sup></a>
The declaration of the container header in C99 would be:

<font size=+1><pre>lc&nbsp;tta
int&nbsp;function(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;listSpace[iList.Sizeof(NULL)];
&nbsp;&nbsp;&nbsp;&nbsp;iList.Init(listSpace);
}

</pre></font>

<div class="p"><!----></div>
If C99 is not available, the best way is to just print the size of the container you are interested in, and then use that value that should stay fixed 
for a given version. This can be automated and you can find in the Appendix 1, a small program that generates a series of <font size="+1"><tt>#defines</tt></font> with the 
values of the sizes of the containers described in this documentation.

<div class="p"><!----></div>
Problems with the above construct could arise because of the alignment requirements of the platform 
where the library is running. Instead of a <font size="+1"><tt>char</tt></font> as the type
of the buffer, it is better to use a slightly more complicated expression to ensure correct alignment. For instance:

<font size=+1><pre>
&nbsp;size_t&nbsp;s&nbsp;=&nbsp;(sizeof(void&nbsp;*)-1+iList.Sizeof(NULL))/sizeof(void&nbsp;*);
&nbsp;void&nbsp;*listSpace[s];

</pre></font>
<div class="p"><!----></div>
</li>

<li> Initializing with existing data
All containers support the <font size="+1"><tt>InitializeWith</tt></font> function. It will create a container using a table of elements to store. Its arguments are the size of 
the objects to be stored, the number of those objects, and a pointer to the table. The table should be a contiguous memory area.

<font size=+1><pre>
/*&nbsp;For&nbsp;sequential&nbsp;containers&nbsp;and&nbsp;TreeMap&nbsp;*/
Container&nbsp;*&nbsp;iContainer.InitializeWith(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;n,&nbsp;void&nbsp;*data);
/*&nbsp;For&nbsp;Dictionary&nbsp;*/
Container&nbsp;*&nbsp;iContainer.InitializeWith(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;n,&nbsp;char&nbsp;**&nbsp;Keys,void&nbsp;*data;

</pre></font>
<div class="p"><!----></div>
</li>
</ol>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Adding an element to a container: Add and AddRange</h2>
This operation adds the given element to a container. In sequential containers it is added at the end, in associative containers it is added at an unspecified position.

<font size=+1><pre>
int&nbsp;iContainer.Add(Container&nbsp;*,const&nbsp;&nbsp;void&nbsp;*element);

</pre></font>
The result of this operation is a positive integer if success, or an error code less than zero if the operation fails <a href="#tthFtNtABD" name="tthFrefABD"><sup>13</sup></a>.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input data is not modified in any way, it is copied into the container.

<div class="p"><!----></div>
Sequential containers support also the <font size="+1"><tt>AddRange</tt></font> API:

<font size=+1><pre>
int&nbsp;iContainer.AddRange(Container&nbsp;*,size_t&nbsp;n,const&nbsp;void&nbsp;*elements[]);

</pre></font>
This API allows you to pass a table of elements into a sequential container and add it with a single call.<a href="#tthFtNtABE" name="tthFrefABE"><sup>14</sup></a>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Removing elements from a container</h2>

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Using an element as key</h3>
The functions <font size="+1"><tt>Erase</tt></font> and <font size="+1"><tt>EraseAll</tt></font> remove the given element from the container. 
The result is an integer greater or equal to zero or an error code less than zero if the element couldn't be added
<a href="#tthFtNtABF" name="tthFrefABF"><sup>15</sup></a> 
.

<div class="p"><!----></div>
The <font size="+1"><tt>EraseAll</tt></font> function is not needed for associative containers since each element in those data structures is unique.

<font size=+1><pre>
int&nbsp;iContainer.Erase(Container&nbsp;*,const&nbsp;void&nbsp;*element);
int&nbsp;iContainer.EraseAll(Container&nbsp;*,const&nbsp;void&nbsp;*element);

</pre></font>

     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Removing at a given position</h3>
 The <font size="+1"><tt>Erase/EraseAt</tt></font> functions need to search for the given element before erasing it. For sequential containers you can use the &#203;raseAt" function, that will remove an element at a given position.

<font size=+1><pre>
int&nbsp;iContainer.EraseAt(Container&nbsp;*,size_t&nbsp;idx);

</pre></font>

For associative containers you use a different argument set:

<font size=+1><pre>
int&nbsp;iContainer.Erase(Container&nbsp;*,const&nbsp;char&nbsp;*Key);

</pre></font>

     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Using a container as a stack</h3>
Elements can be removed from the front or the back in sequential containers using it like a stack:

<font size=+1><pre>
int&nbsp;iContainer.PopBack(Container&nbsp;*d,void&nbsp;*outbuf);
int&nbsp;iContainer.PopFront(Container&nbsp;*d,void&nbsp;*outbuf);

</pre></font>
These functions copy the contents of the last or the first element into the given buffer. If the buffer is NULL, nothing is copied, but the
container is modified: the first or the last element is removed.

     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Batch removing</h3>
Several elements can be removed at once from a container using the <font size="+1"><tt>RemoveRange</tt></font> function. This function is implemented in sequential
containers only.

<font size=+1><pre>
int&nbsp;iContainer.RemoveRange(Container&nbsp;*c,size_t&nbsp;start,&nbsp;size_t&nbsp;end);

</pre></font>
This function removes the elements whose index is greater or equal than <i>start</i> and less than <i>end</i>. If <i>start</i> equals <i>end</i>
nothing is removed and the result is zero. If <i>end</i> is greater than the length of the container it will be adjusted to 1 element past the
end. If no elements are removed the result is zero, positive when one or more elements are removed. The result is a negative error code when an
error occurs.<a href="#tthFtNtABG" name="tthFrefABG"><sup>16</sup></a>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Retrieving elements</h2>
The GetElement function retrieves an element from a container. It comes in two different flavors, one for sequential containers, and another for associative ones.

<font size=+1><pre>
const&nbsp;void&nbsp;*iContainer.GetElement(const&nbsp;Container&nbsp;*,size_t&nbsp;index);
const&nbsp;void&nbsp;*iContainer.GetElement(const&nbsp;Container&nbsp;*,const&nbsp;void&nbsp;*Key);

</pre></font>
These functions return a pointer to the requested element or &nbsp;NULL if the element can't be retrieved. The resulting pointer points directly to the data 
stored in the container. This could be used to bypass all the flags that control the access to the container. For read-only containers, use the 
<font size="+1"><tt>CopyElement</tt></font> function that returns a copy of the requested data into a buffer.

<div class="p"><!----></div>
The function <font size="+1"><tt>GetRange</tt></font> retrieves a slice of a container returning a container of the same type with a copy of the elements stored in the
given range: <a 
name="GetRange50"></a>

<font size=+1><pre>
Container&nbsp;*iContainer.GetRange(const&nbsp;Container&nbsp;*src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;start,&nbsp;size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
The pointer returned can be invalidated by some operations done to the container. For instance if you reverse the order of the elements in a container, 
a pointer to the element zero will point to something else than when you obtained it. If a container needs reallocating its data space because you
added an element, all the pointers that point to data elements of the container can be invalidated. In general <b>it is a bad idea to keep pointers 
to elements in a container that is being modified</b>


<div class="p"><!----></div>
 <b>Invariants:</b>
The given container is not modified in any way.

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Using masks</h2>
A <font size="+1"><tt>mask</tt></font> is a sequence of boolean elements that contains zeroes or some value different from zero. They are used to select elements from a sequential container: for each element of the mask different from zero the corresponding value is selected, for all elements that contain a zero, that value is eliminated.

<div class="p"><!----></div>
The selection operation can be destructive, reusing a container by eliminating from it all elements not selected by the mask, or can be a copy operation where the copy contains only the selected elements.

<div class="p"><!----></div>
In the case of a destructive operation, the destructor functions are called for each element destroyed.

<font size=+1><pre>
int&nbsp;(*Select)(Container&nbsp;*,const&nbsp;mask&nbsp;*);
Container&nbsp;*(*SelectCopy)(const&nbsp;Container&nbsp;*,const&nbsp;mask&nbsp;*);

</pre></font>

<div class="p"><!----></div>
The functions <font size="+1"><tt>CompareEqual</tt></font> and <font size="+1"><tt>CompareEqualScalar</tt></font> produce a mask using two containers as input. Those masks can be used with the selection functions. It is possible of course, to create masks from completely different sources, either directly or by copying. See the <font size="+1"><tt>iMask</tt></font> interface for further details.

<div class="p"><!----></div>

<font size=+1><pre>
Mask&nbsp;*(*CompareEqual)(const&nbsp;Container&nbsp;*,const&nbsp;Mask&nbsp;*);
Mask&nbsp;*(*CompareEqualScalar)(const&nbsp;Container&nbsp;*,&nbsp;const&nbsp;Mask&nbsp;*);

</pre></font>

<div class="p"><!----></div>
The <font size="+1"><tt>CompareEqual</tt></font> function compares two sequential containers of the same type and length, producing a mask containing a value different from zero at each element position where the pair of elements from each container is equal, zero otherwise.

<div class="p"><!----></div>
The <font size="+1"><tt>CompareEqualScalar</tt></font> function compares each element of the given sequential container with a single element, producing a mask with a value 
different from zero<a href="#tthFtNtABH" name="tthFrefABH"><sup>17</sup></a> for each element that is equal to the given element.

 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Sorting a sequential container: Sort</h2>
The "Sort" function will sort a container in place. To keep the old, unsorted contents, make a copy of the container first.

<font size=+1><pre>
int&nbsp;iContainer.Sort(Container&nbsp;*);

</pre></font>

 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Copying a container: Copy</h2>
 The "Copy" function will make a fresh copy of a container. Some fields of the header are copied: the error and compare functions, the flags, and others. Memory will be allocated withe the source container allocator.

<font size=+1><pre>
newContainer&nbsp;*&nbsp;iContainer.Copy(const&nbsp;Container&nbsp;*);

</pre></font>


<div class="p"><!----></div>
 <b>Invariants:</b>
The input container is not modified.

 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Saving and loading a container to or from disk: Save and Load</h2>
The functions "Save" and "Load" will save / load the contents, state, and characteristics of a container into / from disk. They need an open file stream, open in binary mode, and in the correct direction: saving needs a stream open in the write direction, loading needs a stream open in the read direction.

<font size=+1><pre>
int&nbsp;Save(const&nbsp;Container&nbsp;*c,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;fn,void&nbsp;*arg);
Container&nbsp;*Load(FILE&nbsp;*stream,ReadFunction&nbsp;fn,void&nbsp;*arg);

</pre></font>
Both <font size="+1"><tt>Save</tt></font> and <font size="+1"><tt>Load</tt></font> provide default functions to save and load an element but they do a <i>shallow</i> save: pointers aren't followed 
to save the data they point to <a href="#tthFtNtABI" name="tthFrefABI"><sup>18</sup></a>.

 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Inserting a container into another</h2>

     <h3><a name="tth_sEc10.1">
10.1</a>&nbsp;&nbsp;Sequential containers</h3>


<font size=+1><pre>
int&nbsp;(*InsertIn)(Container&nbsp;*destination,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;position,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container&nbsp;*source);
int&nbsp;(*Append)(SequentialContainer&nbsp;*&nbsp;SC1,SequentialContainer&nbsp;*&nbsp;SC2);

</pre></font>
The <font size="+1"><tt>InsertIn</tt></font> function will insert into the "destination" container the contents of the <font size="+1"><tt>source</tt></font> container at the given position. The source is not modified in any way, and a copy of its data will be used. Both containers must be of the same type and store elements of  the same type. The library only tests the element size of each one.

<div class="p"><!----></div>
The <font size="+1"><tt>Append</tt></font> function is similar to InsertIn: the elements of the second container are appended at the end of the first one. The big difference 
is that the second container is destroyed. It is absorbed into the first: its elements are not copied but inserted. This means that a requirement is
that the allocator be the same in both containers.

     <h3><a name="tth_sEc10.2">
10.2</a>&nbsp;&nbsp;Associative containers</h3>

<font size=+1><pre>
int&nbsp;(*InsertIn)(Container&nbsp;*destination,&nbsp;Container&nbsp;*source);

</pre></font>
This function will insert into the destination container the source container using the source container keys. Otherwise the same conditions apply as to the sequential containers: the containers must be of the same type and store elements of the same type.

 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Replace an element with another</h2>

     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Sequential containers: ReplaceAt</h3>

<font size=+1><pre>
int&nbsp;(*ReplaceAt)(Container&nbsp;*dst,size_t&nbsp;position,void&nbsp;*newData);

</pre></font>
Replaces the element at the given position with the new data. 

     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Associative containers: Replace</h3>

<font size=+1><pre>
int&nbsp;(*Replace)(Dictionary&nbsp;*Dict,&nbsp;const&nbsp;char&nbsp;*Key,void&nbsp;*Value);

</pre></font>
Replaces the element with the given key. If the element is absent nothing is done.

 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Looping through all elements of a container</h2>
The user has  three methods for looping through all elements:

<ol type="1">
<li> Using a simple loop construct
<div class="p"><!----></div>
</li>

<li> Using the <font size="+1"><tt>Apply</tt></font> function
<div class="p"><!----></div>
</li>

<li> Using an iterator
<div class="p"><!----></div>
</li>
</ol>
One the most familiar design patterns  is the ITERATOR pattern, which ‘provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 

<div class="p"><!----></div>
Traditionally, this is achieved by identifying an ITERATOR interface that presents operations to initialize an iteration, to access the current element, to advance to the next element, and to test for completion; collection objects are expected to implement this interface, usually indirectly via an auxiliary object. 

<div class="p"><!----></div>
This is exactly the case in the iterator proposal here. Essential to the pattern is the idea that elements are accessed sequentially, but independently of their position in the collection; for example, labeling each element of a tree with its index in left-to-right order fits the pattern, but labeling each element with its depth does not. This traditional version of the pattern is sometimes called an EXTERNAL ITERATOR. 

<div class="p"><!----></div>
An alternative INTERNAL ITERATOR approach assigns responsibility for managing the traversal to the collection instead of the client: the client needs only to provide an operation, which the collection applies to each of its elements. The latter approach is simpler to use, but less flexible; for example, it is not possible for the iteration to affect the order in which elements are accessed, nor to terminate the iteration early. This is the algorithm followed by the <font size="+1"><tt>Apply</tt></font> function.

<div class="p"><!----></div>
     <h3><a name="tth_sEc12.1">
12.1</a>&nbsp;&nbsp;Using a simple loop to iterate a container</h3>

<div class="p"><!----></div>
You can iterate any sequential container with a simple loop. You use the "Size" function to limit the loop. At each loop step you get the corresponding 
element with the "GetElement" function, present in this form in all containers.

<font size=+1><pre>
//&nbsp;"Container"&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;some&nbsp;container
for&nbsp;(size_t&nbsp;i=0;&nbsp;i&lt;iContainer.Size(Container);&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;someType&nbsp;*element&nbsp;=&nbsp;iContainer.GetElement(Container,i);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Use&nbsp;"element"&nbsp;here.
}

</pre></font>
For associative containers you retrieve first a strCollection containing all keys using the <font size="+1"><tt>GetKeys</tt></font> function, present in all associative 
containers. Then, you retrieve each element by looping through the string collection that you have obtained in a similar manner to the sequential 
containers. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc12.2">
12.2</a>&nbsp;&nbsp;Using the Apply function.</h3>
<a 
name="Apply+general122"></a>
The <font size="+1"><tt>Apply</tt></font> function will iterate through all elements calling a given function for each one.1 Its prototype is:

<font size=+1><pre>
void&nbsp;iContainer.Apply(Container,&nbsp;//pointer&nbsp;to&nbsp;some&nbsp;container
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int(*Applyfn)(void&nbsp;*elem,void&nbsp;*arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);

</pre></font>
This function receives three arguments:

<ol type="1">
<li> A pointer to the container. <a href="#tthFtNtABJ" name="tthFrefABJ"><sup>19</sup></a>.
<div class="p"><!----></div>
</li>

<li> A function pointer that should point to a function that receives two arguments: the element of the container, and an extra argument where it can 
receive (and write to) global information about the search.  This extra argument is
<div class="p"><!----></div>
</li>

<li> The third one passed to the <font size="+1"><tt>Apply</tt></font> function. <font size="+1"><tt>Apply</tt></font> will pass this argument to the given function together with a pointer to the 
element retrieved from the container.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc12.3">
12.3</a>&nbsp;&nbsp;Using iterators</h3>
<a 
name="Iterators+General123"></a>
Iterators are objects returned by each container that allow you to iterate (obviously) through all elements of a container.
You use iterators like this:

<font size=+1><pre>
Iterator&nbsp;*it&nbsp;=&nbsp;iContainer.NewIterator(someContainer);
Mytype&nbsp;*myobject;
for&nbsp;(myobject&nbsp;=&nbsp;it-&#62;GetFirst(it);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myobject!=&nbsp;NULL;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myobject&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;"myobject"&nbsp;here
}
iContainer.DeleteIterator(it);&nbsp;//&nbsp;dispose&nbsp;the&nbsp;iterator&nbsp;object

</pre></font>
Iterators provide a container-independent way of iterating that will work with any container, both sequential or associative. In associative containers 
the specific sequence is implementation defined, and in sequential containers is the natural sequence.

<div class="p"><!----></div>
The main objective for iterators is to break a dependence between an algorithm and the type of container it is working with. Since all containers
support iterators, you can write your code independently (to a great extent) from which specific iterator you are using.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input container could be modified in some implementations. A list of existing iterators is possible, to allow invalidating them in case of
modifications to the container for example.

<div class="p"><!----></div>
Iterators always support at least the following functions:

<font size=+1><pre>
void&nbsp;*iterator-&#62;GetFirst(iterator);
void&nbsp;*iterator-&#62;GetNext(iterator);
void&nbsp;*iterator-&#62;GetCurrent(iterator);

</pre></font>
All containers support the "NewIterator"  and "DeleteIterator" methods:

<font size=+1><pre>
iterator&nbsp;*iContainer.NewIterator(Container);&nbsp;
int&nbsp;iContainer.DeleteIterator(iterator);

</pre></font>
Iterators must be destroyed since they are allocated using the containers allocator.

<div class="p"><!----></div>
Sequential containers can support additional functions:

<font size=+1><pre>
void&nbsp;*iterator-&#62;GetLast(iterator);
void&nbsp;*iterator-&#62;GetPrevious(iterator);
void&nbsp;*iterator-&#62;Seek(iterator&nbsp;i,&nbsp;size_t&nbsp;position);

</pre></font>
This interface allows users to write fully general algorithms that will work with any container, independently of its internal structure. Obviously the 
performance can differ from container to container depending on usage.

<div class="p"><!----></div>
All iterators will become invalid if the underlying container changes in any way, except through the iterator itself.<a href="#tthFtNtACA" name="tthFrefACA"><sup>20</sup></a>
Each container can conceptually be seen as a sequence of <i>generations</i>, or <i>states</i>. Beginning with the fresh constructed state, the container
evolves until it reaches the destroyed state after the execution of the <font size="+1"><tt>Finalize</tt></font> function. This sequence of states interacts with an
iterator as follows: An iterator applies only to a <b>single</b> container state. Any modification of the container state, directly or
indirectly moves the state and invalidates the iterator.

<div class="p"><!----></div>
An implementation may catch some of the movements of the container in the state space and report an error when an iterator is used that belongs to 
a different container state. But not all access can be detected. If the user has pointers to an iterator's data and modifies this data without
using the container API an implementation may not catch this error.

<div class="p"><!----></div>
 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;Setting and retrieving the state: GetFlags and SetFlags</h2>
Each container has a set of flags that can be read and written to change the container's behavior. The only flag that is defined by all containers
is the read-only flag. Implementations can extend this to offer different services like copy-on-write, or other applications. 

<div class="p"><!----></div>
The read-only flag means that no direct pointers to an element or to the whole data are returned, no functions that modify the
container are allowed to proceed and that the <font size="+1"><tt>Clear()</tt></font>
and <font size="+1"><tt>Finalize()</tt></font> APIs will not work. You must unset this flag to allow for destruction of the object.
<a href="#tthFtNtACB" name="tthFrefACB"><sup>21</sup></a>

<div class="p"><!----></div>
Using the state space concept introduced above, this flag freezes the state of a container disallowing any further evolution. The only API that
can modify the state is the <font size="+1"><tt>SetFlags</tt></font> API that can reset the state to a read/write state again.

 <h2><a name="tth_sEc14">
14</a>&nbsp;&nbsp;Retrieving the number of elements stored: Size</h2>
<a 
name="Size140"></a>
All containers support querying the number of elements stored. The prototype is:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;iContainer.Size(const&nbsp;Container&nbsp;*);

</pre></font>
There is no error return. If a &nbsp;NULL pointer is given to those functions the result is zero.

 <h2><a name="tth_sEc15">
15</a>&nbsp;&nbsp;Sizes</h2>

     <h3><a name="tth_sEc15.1">
15.1</a>&nbsp;&nbsp;Sizeof</h3>
This computes the total size used by the container in bytes, including the header structure and the data stored in the container. Any other overhead 
must be accounted for.

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;iContainer.Sizeof(const&nbsp;Container&nbsp;*);

</pre></font>

<div class="p"><!----></div>
If its argument is &nbsp;NULL , <font size="+1"><tt>Sizeof</tt></font> returns the size of the container header. This can be used to allocate space for a container as a local variable for instance.

<div class="p"><!----></div>
     <h3><a name="tth_sEc15.2">
15.2</a>&nbsp;&nbsp;SizeofIterator</h3>
<a 
name="SizeofIterator152"></a>
Computes the size of the iterator for the given container. The objective here is to allow the declaration of the iterator as a local variable
to avoid having to free the iterator at the exit of the function.

<font size=+1><pre>
int&nbsp;Fn(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[iList.SizeofIterator(NULL)];
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;(Iterator&nbsp;*)buf;
&nbsp;&nbsp;&nbsp;&nbsp;iList.InitIterator(it);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Use&nbsp;iterator&nbsp;"it"&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;No&nbsp;need&nbsp;to&nbsp;call&nbsp;DeleteIterator&nbsp;at&nbsp;exit
}

</pre></font>

<div class="p"><!----></div>
 <h2><a name="tth_sEc16">
16</a>&nbsp;&nbsp;Memory management</h2>
<a 
name="Allocator160"></a>
All containers have a pointer to their allocator object. An allocator object is a simple interface that provides 4 functions:

<ol type="1">
<li> malloc: A function that receives a <font size="+1"><tt>size_t</tt></font> and returns a <font size="+1"><tt>void *</tt></font> pointing to a memory block of the requested size, or &nbsp;NULL if no more memory is available. Note that this function receives the number of <b>bytes</b> to allocate, not the number of items.<a href="#tthFtNtACC" name="tthFrefACC"><sup>22</sup></a>
<div class="p"><!----></div>
</li>

<li> realloc: A function that will resize a previously allocated block.
<div class="p"><!----></div>
</li>

<li> free: A function that will release the memory allocated previously with malloc/realloc.
<div class="p"><!----></div>
</li>

<li> calloc: a function that will allocate <font size="+1"><tt>n</tt></font> objects of <font size="+1"><tt>m</tt></font> size and clear the memory block to zero before returning it.
<div class="p"><!----></div>
</li>
</ol>
At the start of the library runtime a default allocator object exists that uses the four functions of the standard C library. Other allocator objects can be used, and the user can change the global allocator at any time. Each container retrieves the default allocator object when created, and stores it in the container descriptor. Any further change to the default allocator will not affect existing containers that have already an allocator. When changing the allocator you should do that before creating the container.

<div class="p"><!----></div>
Some containers are created without any heap management by default. You can introduce heap management by calling the <font size="+1"><tt>UseHeap</tt></font> function, that will install a new heap in the container. Other containers are always created with a heap, and you should pass them an allocator object for object creation.

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.1">
16.1</a>&nbsp;&nbsp;Memory manager objects</h3>
The library provides two memory manager objects:

<ol type="1">
<li> The default memory manager, that receives the standard C library functions; malloc, free, realloc and calloc.
<div class="p"><!----></div>
</li>

<li> The debug memory manager that implements the same functions with added functionality designed to:

<ul>
<li>Catch the "double free" problem.
<div class="p"><!----></div>
</li>

<li>
Catch the overflow of a memory block
<div class="p"><!----></div>
</li>

<li>
Catch freeing a block that wasn't allocated
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc16.2">
16.2</a>&nbsp;&nbsp;Pooled memory management</h3>
The problem with the traditional C memory management is that it requires that the programmer cares about each piece of RAM that is allocated by the program and follows the lifetime of each piece to ensure that it gets returned to the system for reuse. In today's software world, this is just impractical.

<div class="p"><!----></div>
A better strategy is to use a pool of memory where related memory allocations can b e done from a common pool. When the module finishes, all the allocated pool is freed just by destroying the whole pool. This is much easier to manage, and in many cases more efficient.
The proposed interface has the following functionalities:

<ol type="1">
<li> Creation. The creation function receives a memory allocator to use for this pool.
<div class="p"><!----></div>
</li>

<li> Alloc. This function receives a pool and a size and returns a memory block, or &nbsp;NULL if there is no more memory.
<div class="p"><!----></div>
</li>

<li> Clear. This erases all objects allocated in the pool without returning the memory to the system.
<div class="p"><!----></div>
</li>

<li> Finalize. This releases all memory and destroys all objects.
<div class="p"><!----></div>
</li>
</ol>
Note that there is no realloc, and that the "Clear" function is optional. Not all pools support it. The rationale for these decisions being that realloc would need to store the size of each block, what in a pool maintained by a single stack like pointer would be very expensive.

     <h3><a name="tth_sEc16.3">
16.3</a>&nbsp;&nbsp;Heap of same size objects</h3>
Many containers are used to store sets of objects of the same size. The library provides a specialized heap management software for this application. It stores vectors of objects of the same size. The interface provided is as follows:

<ul>
<li> Create. This function receives as an argument a memory manager object that will be used to allocate memory.
<div class="p"><!----></div>
</li>

<li> NewObject: returns an object to the application
<div class="p"><!----></div>
</li>

<li> FreeObject: Adds an object to the list of available objects
<div class="p"><!----></div>
</li>

<li> Size: Returns the size of the heap in bytes
<div class="p"><!----></div>
</li>

<li> Clear: reclaims memory used by the free list
<div class="p"><!----></div>
</li>

<li> Finalize: Reclaims all memory used by the heap and the heap object
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.4">
16.4</a>&nbsp;&nbsp;Garbage collection</h3>
Automatic garbage collection is offered by some compiler systems as an alternative to traditional memory management. This solution is
not compatible with real time requirements, and is not practical in machines with very low memory configurations.

<div class="p"><!----></div>
In other cases however, it can be a real simplification since the programmer is relieved from the huge task of taking care of each
piece of memory and to cater its disposal. A simple memory model is proposed: you program as if the amount of memory was infinite
and never worry about freeing the memory you use. Periodically the collector starts collecting unused memory chunks and adds them
to the pool of available memory or releases it to the underlying operating system.

<div class="p"><!----></div>
This model is not the solution to all memory management problems. It can be a solution to some situations, specially when developing
in workstation environments where memory is freely available. The bugs that can appear are also very difficult to solve. One of the
most difficult is when you keep by mistake some reference to a large piece of memory making the recycling of the memory impossible.
In that case you have to search in all the code of the application for the reference that keeps the memory block marked as used, and that can
be very difficult in large applications.

     <h3><a name="tth_sEc16.5">
16.5</a>&nbsp;&nbsp;Multi-threading</h3>
In environments where multi-threading or other parallel programming constructs are possible, the implementation must provide for sequential
semantics, i.e. each operation should perform as described in this documentation with the additional caveat that any operation that modifies
a container must be <font size="+1"><tt>atomic</tt></font>, i.e. it can't be interrupted leaving the container in an unstable or incoherent state. It is up to the
implementation to ensure that if an atomic operation is interrupted, the inconsistent container state will be invisible to other processes
or threads accessing the container.

 <h2><a name="tth_sEc17">
17</a>&nbsp;&nbsp;At a glance</h2>
For a more detailed description see &#167;<a href="#APIOverview"> 10API Overview</a> on page&nbsp;<a href="#APIOverview">pageref</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
<font size="-2">
<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table border="1">
<tr><td width="138"><b>Operation</b></td><td width="414"><b>Description</b></td></tr>
<tr><td width="138">Add</td><td width="414">Adds a single element at the end of the container</td></tr>
<tr><td width="138">AddRange</td><td width="414">Adds a sequence of elements</td></tr>
<tr><td width="138">Append</td><td width="414">Adds a container after a first one </td></tr>
<tr><td width="138">Apply</td><td width="414">Calls a function with each element of the container in  sequence.</td></tr>
<tr><td width="138">Clear</td><td width="414">Erases all elements </td></tr>
<tr><td width="138">Contains</td><td width="414">Searches for an element in a container</td></tr>
<tr><td width="138">Copy</td><td width="414">Copies a container </td></tr>
<tr><td width="138">Create</td><td width="414">Creates a container that will use the current allocator.</td></tr>
<tr><td width="138">CreateWithAllocator</td><td width="414">Creates a container that will use a given allocator.</td></tr>
<tr><td width="138">DeleteIterator</td><td width="414">Disposes of the storage used by the iterator object </td></tr>
<tr><td width="138">Equal</td><td width="414">Compares two containers of the same type </td></tr>
<tr><td width="138">Erase</td><td width="414">Removes an element from the container</td></tr>
<tr><td width="138">EraseAt</td><td width="414">Erases an element at a given position </td></tr>
<tr><td width="138">Finalize</td><td width="414">Destroys all storage used </td></tr>
<tr><td width="138">GetElement</td><td width="414">Retrieves one element from a container </td></tr>
<tr><td width="138">GetFlags</td><td width="414">Returns the flags</td></tr>
<tr><td width="138">GetAllocator</td><td width="414">Retrieves the allocator used by the container</td></tr>
<tr><td width="138">GetRange</td><td width="414">Retrieves several elements</td></tr>
<tr><td width="138">IndexOf</td><td width="414">Retrieves the position of an element </td></tr>
<tr><td width="138">InsertAt</td><td width="414">Inserts an element at a given position </td></tr>
<tr><td width="138">InsertIn</td><td width="414">Inserts a container into another </td></tr>
<tr><td width="138">Load</td><td width="414">Retrieves a container from disk </td></tr>
<tr><td width="138">NewIterator</td><td width="414">Returns an iterator object </td></tr>
<tr><td width="138">PopFront </td><td width="414">Retrieves the first element and removes it</td></tr>
<tr><td width="138">PopBack</td><td width="414">Retrieves the last element and removes it</td></tr>
<tr><td width="138">PushFront </td><td width="414">Stores an element at the start of a container</td></tr>
<tr><td width="138">PushBack</td><td width="414">Stores an element at the end </td></tr>
<tr><td width="138">RemoveRange</td><td width="414">Erases a range of elements </td></tr>
<tr><td width="138">Replace </td><td width="414">Replaces one element (Associative containers)</td></tr>
<tr><td width="138">ReplaceAt </td><td width="414">Replaces one element (Sequential containers) </td></tr>
<tr><td width="138">Save</td><td width="414">Stores the container to disk </td></tr>
<tr><td width="138">SetCompareFunction</td><td width="414">Sets or retrieves the function used for comparisons </td></tr>
<tr><td width="138">SetErrorFunction</td><td width="414">Sets or retrieves the function used to report errors</td></tr>
<tr><td width="138">SetDestructor</td><td width="414">Sets or retrieves the function called when an element is destroyed </td></tr>
<tr><td width="138">Select</td><td width="414">Selects elements using a mask </td></tr>
<tr><td width="138">SelectCopy</td><td width="414">Select elements to copy using a mask.</td></tr>
<tr><td width="138">SetFlags</td><td width="414">Sets the flags</td></tr>
<tr><td width="138">Size</td><td width="414">Returns the number of elements stored in the container </td></tr>
<tr><td width="138">Sizeof</td><td width="414">Returns the number of bytes used </td></tr>
<tr><td width="138">SizeofIterator</td><td width="414">Returns the size of the iterator object for a container </td></tr>
<tr><td width="138">Sort</td><td width="414">Sorts the contents </td></tr>
<tr><td colspan="2" align="center"> <b>Iterator vocabulary</b> </td></tr>
<tr><td width="138">GetFirst </td><td width="414">Retrieves a pointer to the first element</td></tr>
<tr><td width="138">GetNext </td><td width="414">Retrieves a pointer to the next element </td></tr>
<tr><td width="138">GetPrevious </td><td width="414">Retrieves a pointer to the previous element if the container supports bidirectional seek.</td></tr>
<tr><td width="138">GetCurrent</td><td width="414">Retrieves a pointer to the current element </td></tr>
<tr><td width="138">GetLast </td><td width="414">Retrieves a pointer to the last element </td></tr>
<tr><td width="138">Replace </td><td width="414">Replaces the current element with a different element. If the given pointer to the replacement is &nbsp;NULL 
it will delete the current element.</td></tr>
<tr><td width="138">Seek</td><td width="414">Sequential containers only. Positions the cursor at a given position.</td></tr>
<tr><td width="138"></td></tr></table>
</center>
<div class="p"><!----></div>
</font> 
 <h1><a name="tth_chAp5">
Chapter 5 </a><br />The auxiliary interfaces</h1>
These interfaces are used by all the containers in the rest of the library. They provide basically the following functions:

<ul>
<li> Memory management with the <font size="+1"><tt>Allocator</tt></font> object.
<div class="p"><!----></div>
</li>

<li> Observer and circulation of notifications with <font size="+1"><tt>iObserver</tt></font>.
<div class="p"><!----></div>
</li>

<li> Error handling with the <font size="+1"><tt>iError</tt></font> interface.
<div class="p"><!----></div>
</li>

<li> Masks used to select items
<div class="p"><!----></div>
</li>
</ul>
<img src="Basic.png" alt="Figure">

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Masks</h2>
A mask is a sequence that contains boolean data used for selection of items in a sequential container. 
It is not specified if a mask is a bit string (i.e. a
strictly boolean array) or an array of chars or other integers used to hold the binary data. In all cases a value of the mask at a given position 
means <i>select</i> if it is different than zero, or <i>do not select</i> if it is zero.

<div class="p"><!----></div>
The interface offered by the mask object is very small. Masks can't be resized but they have an allocator to be able to reclaim the
memory they use when created. This allocator will be initialized to the current allocator when the mask is created.

     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;The interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_Mask&nbsp;Mask;
typedef&nbsp;struct&nbsp;tagMaskInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*And)(Mask&nbsp;*src1,Mask&nbsp;*src2);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*Copy)(const&nbsp;Mask&nbsp;*src);
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*Create)(size_t&nbsp;length);
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CreateFromMask)(size_t&nbsp;length,char&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(Mask&nbsp;*src1,Mask&nbsp;*src2);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*PopulationCount)(const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Set)(Mask&nbsp;*m,size_t&nbsp;idx,int&nbsp;val);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(Mask&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Mask&nbsp;*);
}&nbsp;iMask;

</pre></font>

     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="And+\container12"></a> <font size="+1"><b>And</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*And)(Mask&nbsp;*src1,Mask&nbsp;*src2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Stores into src1 the result of a logical AND operation between each element of src1 with the corresponding element of src2.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The masks are of different length.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation was performed, a negative error code if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container12"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets all elements of the mask to zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the mask was cleared, a negative error code if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container12"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*Copy)(const&nbsp;Mask&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates a new mask and copies the contents of the given one into it.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 No memory is available to perform the allocation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new mask or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CreateFromMask+\container12"></a> <font size="+1"><b>CreateFromMask</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CreateFromMask)(size_t&nbsp;length,const&nbsp;char&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new mask with the specified length and copies the given data into the mask. Each character in the input data is transformed into the
mask internal representation. The storage is obtained using the CurrentAllocator pointer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The data pointer is &nbsp;NULL 

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 No memory is available to perform the allocation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new mask or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container12"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*Create)(size_t&nbsp;length);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new mask with the specified length. The storage is obtained using the CurrentAllocator pointer. The data is initialized to zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 No memory is available to perform the allocation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new mask or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Finalize+\container12"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The memory used by the mask is reclaimed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the memory was reclaimed, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Not+\container12"></a> <font size="+1"><b>Not</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Not)(Mask&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Stores into src the result of a logical NOT operation: each bit is inverted.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation was performed, a negative error code if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Or+\container12"></a> <font size="+1"><b>Or</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(Mask&nbsp;*src1,const&nbsp;Mask&nbsp;*src2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Stores into src1 the result of a logical OR operation between each element of src1 with the corresponding element of src2.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The masks are of different length.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation was performed, a negative error code if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="PopulationCount+\container12"></a> <font size="+1"><b>PopulationCount</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;size_t&nbsp;(*PopulationCount)(const&nbsp;Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Counts the number of entries different from zero in the given mask, returning the sum.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number or zero.

<div class="p"><!----></div>
 
<br /><a 
name="Set+\container12"></a> <font size="+1"><b>Set</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Set)(Mask&nbsp;*m,size_t&nbsp;idx,int&nbsp;val);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the given position to the given value if the value fits in the internal representation of the mask. If not, an implementation defined
conversion occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The index given is out of bounds.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the value was set or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container12"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(Mask&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The number of elements in the mask is returned.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The number of elements. If the mask pointer is &nbsp;NULL , the result is zero.

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container12"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;Mask&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The number of bytes used by the given mask. If the argument is &nbsp;NULL the number of bytes of the header structure is returned.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>The number of bytes.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Memory management</h2>
Several interfaces implement different memory allocation strategies. This should give flexibility to the implementations, allowing it to use several memory allocation strategies within the same container.
<div class="p"><!----></div>
The library starts with the <font size="+1"><tt>default</tt></font> memory manager, that contains pointers to the default C memory management functions: malloc, free, realloc and calloc. Another memory manager is the <font size="+1"><tt>debug</tt></font> memory manager that should implement more checking and 
maybe offer hooks to the debugger. The sample
implementation shows how to implement several simple checks, but other implementations can extend this simple interface providing 
much more sophisticated controls<a href="#tthFtNtACD" name="tthFrefACD"><sup>23</sup></a>.

<div class="p"><!----></div>
<img src="MemoryManagement.png" alt="Figure">
<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;The default memory manager</h3>
The C language provides several functions to manage memory. The default Allocator object is built from the standard C memory allocation functions.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagAllocator&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*malloc)(size_t);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;(*free)(void&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*realloc)(void&nbsp;*,size_t);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*calloc)(size_t,size_t);
}&nbsp;ContainerAllocator;
extern&nbsp;ContainerAllocator&nbsp;*&nbsp;CurrentAllocator;

</pre></font>
At startup, the CurrentAllocator points to an object constructed with the functions of the C standard library. This is a required interface.
The user can change at any time the current allocator by making the <font size="+1"><tt>CurrentAllocator</tt></font> point to a different object. Note that this change
does <b>not</b> change the allocators of the containers already created but the allocators of the new containers allocated after the
change is made.

<div class="p"><!----></div>
This is the established procedure to build custom memory allocators to provide for special alignment requirements, improve speed, allocate objects
from the stack instead of the heap, and many other usages.

<div class="p"><!----></div>
All containers have an <font size="+1"><tt>Allocator</tt></font> object, either explicitly when created with the <font size="+1"><tt>CreateWithAllocator</tt></font> API or implicitly since all 
creation functions use the object pointed to by the <font size="+1"><tt>CurrentAllocator</tt></font> global variable to obtain memory.

<div class="p"><!----></div>
The library can also include a debug version on top of the standard C functions, offering the same interface. Changing the CurrentAllocator to point to that object allows to switch to the debug version. The debug version of the sample implementation offers:

<ul>
<li>Detection of free() of a memory block not allocated by malloc().
<div class="p"><!----></div>
</li>

<li>
Detection of  writing past the end of the block in some cases.
<div class="p"><!----></div>
</li>

<li>
Detection of freeing a memory block twice.
<div class="p"><!----></div>
</li>
</ul>

<font size=+1><pre>
extern&nbsp;ContainerAllocator&nbsp;iDebugMalloc;

</pre></font>
This interface is optional. The sample implementation documents a possible implementation, see &#167;<a href="#Malloc"> 8.4.5The sample implementation</a> on page&nbsp;<a href="#Malloc">pageref</a>
.

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.1.1">
2.1.1</a>&nbsp;&nbsp;Interface for modifying the current allocator</h4>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagAllocatorInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*(*Change)(ContainerAllocator&nbsp;*newAllocator);
&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*(*GetCurrent)(void);
}&nbsp;AllocatorInterface;
extern&nbsp;AllocatorInterface&nbsp;iAllocator;

</pre></font>
 
<br /><a 
name="Change+\container21"></a> <font size="+1"><b>Change</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*(*Change)(ContainerAllocator&nbsp;*newAllocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Changes the value pointed by the <font size="+1"><tt>CurrentAllocator</tt></font> pointer to the given one. This is an atomic operation. If the given 
allocator pointer is &nbsp;NULL nothing is changed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>The old value stored in the <font size="+1"><tt>CurrentALlocator</tt></font> pointer.
 
<div class="p"><!----></div>
<br /><a 
name="GetCurrent+\container21"></a> <font size="+1"><b>GetCurrent</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*(*GetCurrent)(void);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Returns the value pointed to by the <font size="+1"><tt>CurrentAllocator</tt></font> pointer. This operation is atomic.

<div class="p"><!----></div>
<b>Returns:</b>The value stored in the ,CurrentAllocator, pointer
<a href="#tthFtNtACE" name="tthFrefACE"><sup>24</sup></a>
.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;The Heap interface: iHeap</h3>
Some containers can benefit from a cacheing memory manager that manages a stock of objects of the same size. This is not required and not all implementations may provide it. If they do, the interface is:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*UseHeap)(Container&nbsp;*c);
&nbsp;&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*(*GetHeap)(Container&nbsp;*c);

</pre></font>
In the sample implementation, many complex data structures are implemented using a heap. This allows automatically to have an iterator, since for 
looping all elements of the container it suffices to iterate the underlying heap.
The standard interface for the heap is:<a 
name="iHeap22"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagContainerHeapInterface&nbsp;{
&nbsp;&nbsp;&nbsp;void&nbsp;(*Clear)(ContainerHeap&nbsp;*heap);
&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*(*Create)(size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*it);
&nbsp;&nbsp;&nbsp;void&nbsp;(*Finalize)(ContainerHeap&nbsp;*heap);
&nbsp;&nbsp;&nbsp;int&nbsp;(*FreeObject)(ContainerHeap&nbsp;*heap,void&nbsp;*element);
&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*(*InitHeap)(void&nbsp;*heap,size_t&nbsp;nbElements,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(ContainerHeap&nbsp;*);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*NewObject)(ContainerHeap&nbsp;*heap);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(ContainerHeap&nbsp;*heap);
}&nbsp;ContainerHeapInterface;

</pre></font>

 
<div class="p"><!----></div>
<br /><a 
name="Create+\container22"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

ContainerHeap&nbsp;*iHeap.Create(size_t&nbsp;elementSize,&nbsp;Allocator&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new heap object that will use the given memory manager to allocate memory. All elements will have the given size. If the memory manager object pointer is &nbsp;NULL , the object pointed by CurrentAllocator will be used.

<div class="p"><!----></div>
<b>Returns:</b>a pointer to the new heap object or &nbsp;NULL , if an error occurred.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The element size is bigger than what the heap implementation can support..

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.
 
<div class="p"><!----></div>
<br /><a 
name="InitHeap+\container22"></a> <font size="+1"><b>InitHeap</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*&nbsp;(*InitHeap)(void&nbsp;*heap,size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the given buffer to a heap header object designed to hold objects of <font size="+1"><tt>ElementSize</tt></font> bytes. The heap will use the given memory
manager. If the memory manager parameter is &nbsp;NULL the default memory manager is used.

<div class="p"><!----></div>
This function supposes that the <font size="+1"><tt>heap</tt></font> parameter points to a contiguous memory space at least enough to hold a <font size="+1"><tt>ContainerHeap</tt></font> object.
The size of this object can be obtainer by using the <font size="+1"><tt>iHeap.Size</tt></font> API with a &nbsp;NULL parameter.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new ContainerHeap object or &nbsp;NULL if there is an error. Note that the pointer returned can be different from the passed in
pointer due to alignment requirements.
 
<div class="p"><!----></div>
<br /><a 
name="newObject+\container22"></a> <font size="+1"><b>newObject</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;void&nbsp;*iHeap.newObject(ContainerHeap&nbsp;*heap);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The heap returns a pointer to a new object or &nbsp;NULL if no more memory is left.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to an object or &nbsp;NULL if there is not enough memory to complete the operation.
 
<div class="p"><!----></div>
<br /><a 
name="FreeObject+\container22"></a> <font size="+1"><b>FreeObject</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;size_t&nbsp;iHeap.FreeObject(ContainerHeap&nbsp;*heap,void&nbsp;*element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given object to the list of free objects, allowing for recycling of memory without new allocations. The element pointer can be &nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The heap pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The number of objects in the free list.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container22"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;void&nbsp;iHeap.Clear(ContainerHeap&nbsp;*heap);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Releases all memory used by the free list and resets the heap object to its state as it was when created.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The heap pointer is &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container22"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;iHeap.Finalize(ContainerHeap&nbsp;*heap);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Destroys all memory used by the indicated heap and frees the heap object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The heap pointer is &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Sizeof+\container22"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;iHeap.Sizeof(ContainerHeap&nbsp;*heap);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of bytes used by the given heap, including the size of the free list. If the argument <font size="+1"><tt>"heap"</tt></font> is &nbsp;NULL , the result is the size of the heap header structure (i.e. <font size="+1"><tt>sizeof(ContainerHeap)</tt></font>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

void&nbsp;SomeFunction(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buffer[iHeap.Sizeof(NULL)];
&nbsp;&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*ch;

&nbsp;&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;iHeap.InitHeap(buffer,200,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;iHeap.Clear(ch);
}

</pre></font>
This example uses the variable length arrays that have been introduced in the C language by the latest standard (C99). The <font size="+1"><tt>Sizeof</tt></font> function
returns the size of the header object that is used to specify the size of the buffer. The buffer is passed to the <font size="+1"><tt>InitHeap</tt></font> function using
a number of objects of 200 and the default memory allocator.

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Pooled memory interface: iPool</h2>
<a 
name="iPool30"></a>
<img src="Pool.png" alt="Figure">
<div class="p"><!----></div>
Many containers could benefit from a memory pool. A memory pool groups all allocations done in a specific context and can be released in a single call. This allows the programmer to avoid having to manage each single piece of memory like the basic interface.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_tagPoolAllocatorInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Pool&nbsp;&nbsp;*(*Create)(ContainerAllocator&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*(*Alloc)(Pool&nbsp;*pool,size_t&nbsp;size);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*(*Calloc)(Pool&nbsp;*pool,size_t&nbsp;size);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;(*Clear)(Pool&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;(*Finalize)(Pool&nbsp;*);
}&nbsp;PoolAllocatorInterface;

</pre></font>
Note that there is no realloc function. Pooled memory is often implemented without storing the size of the block to cut overhead. Since a realloc function could be expensive, implementations are not required to provide it.
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container30"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Pool&nbsp;*iPool.Create(ContainerAllocator&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new pool object that will use the given memory manager. If m is &nbsp;NULL , the object pointed by the CurrentAllocator will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new object or &nbsp;NULL if the operation couldn't be completed.

<div class="p"><!----></div>
 
<br /><a 
name="Alloc+\container30"></a> <font size="+1"><b>Alloc</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*iPool.Alloc(Pool&nbsp;*pool,size_t&nbsp;size);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Allocates size bytes from the pool pool. If there isn't enough memory to resize the pool  the result is &nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the allocated memory or &nbsp;NULL if error.

<div class="p"><!----></div>
 
<br /><a 
name="Calloc+\container30"></a> <font size="+1"><b>Calloc</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*iPool.Calloc(Pool&nbsp;*pool,size_t&nbsp;n,size_t&nbsp;size);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates n objects of size &#223;ize" in a single block. All memory is initialized to zero. If there is no memory left it returns &nbsp;NULL ;

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the allocated memory or &nbsp;NULL if error.

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container30"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;iPool.Clear(Pool&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the pool and leaves the object as it was when created.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The pool pointer is &nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="Finalize+\container30"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;iPool.Finalize(Pool&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the pool and destroys the pool object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The pool pointer is &nbsp;NULL .

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Error handling Interface: iError</h2>
<a 
name="iError40"></a>
The &#239;Error" interface provides a default strategy for handling errors. The "RaiseError" function will be used as the default error function within the creation function for all containers that support a per container instance error function.

<font size=+1><pre>
typedef&nbsp;(*ErrorFunction)(const&nbsp;char&nbsp;*,int,...);
typedef&nbsp;struct&nbsp;{
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*AddError)(int&nbsp;code,&nbsp;char&nbsp;*Message);
&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*EmptyErrorFunction)(const&nbsp;char&nbsp;*fname,int&nbsp;code,...);
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*NullPtrError)(const&nbsp;char&nbsp;*);
&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*RaiseError)(const&nbsp;char&nbsp;*fname,int&nbsp;code,...);
&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(ErrorFunction);
&nbsp;&nbsp;const&nbsp;char&nbsp;*&nbsp;&nbsp;(*StrError)(int&nbsp;errorCode);
}&nbsp;ErrorInterface;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="AddError+\container40"></a> <font size="+1"><b>AddError</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*AddError)(int&nbsp;code,&nbsp;char&nbsp;*Message);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds an error code and its corresponding text to the list of error messages recognized by the library. New error messages should be added at runtime using integer codes below the <font size="+1"><tt>CONTAINER_LAST_ERRORCODE</tt></font> constant.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NO_MEMORY

 Some implementations use the current allocator to get more memory. If this fails, the error is not added and the function returns an error code. Note that the message text is copied into the library. This allocation can also fail.

<div class="p"><!----></div>
<b>Returns:</b>A positive integer for success, a negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="RaiseError+\container40"></a> <font size="+1"><b>RaiseError</b></font> <hr />


<font size=+1><pre>

&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError(const&nbsp;char&nbsp;*fname,int&nbsp;errcode,...);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The parameter "fname" should be the name of the function where the error occurs. The &#235;rrcode" parameter is a negative error code. The actual value of the code is defined for the cases mentioned in the section <a href="#errorcodes"> 4.4.1The auxiliary interfaces</a>. Other negative values can be defined by the implementation.

<div class="p"><!----></div>
Other parameters can be passed depending on the error. The sample implementation never passes anything else but the name of the function where the
error occurs and the error code.

<div class="p"><!----></div>
The behavior of the default error function is implementation specific. In the sample code this function will just print the error message in the standard error stream. Other implementations could end the program, log the error into a error stream, or do nothing.

<div class="p"><!----></div>
<b>Returns:</b>No return value

<div class="p"><!----></div>
 
<br /><a 
name="EmptyErrorFunction+\container40"></a> <font size="+1"><b>EmptyErrorFunction</b></font> <hr />


<font size=+1><pre>

&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.EmptyErrorFunction(const&nbsp;char&nbsp;*fname,int&nbsp;errcode,...);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function can be used to ignore all errors within the library. It does nothing.

<div class="p"><!----></div>
 
<br /><a 
name="StrError+\container40"></a> <font size="+1"><b>StrError</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;const&nbsp;char&nbsp;*iError.StrError(int&nbsp;errorCode);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Converts the given error code in a character string. If the error code doesn't correspond to any error defined by the implementation a character string 
with an implementation defined value is returned.

<div class="p"><!----></div>
 
<br /><a 
name="SetErrorFunction+\container40"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;ErrorFunction&nbsp;iError.SetErrorFunction(ErrorFunction);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Changes the value of the default error function. If its argument is &nbsp;NULL , nothing is done, and the call is interpreted as a query of the current value.

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the default error function.
 
<div class="p"><!----></div>
<br /><a 
name="NullPtrError+\container40"></a> <font size="+1"><b>NullPtrError</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*NullPtrError)(const&nbsp;char&nbsp;*msg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This is a utility function equivalent to:

<font size=+1><pre>
int&nbsp;NullPtrError(const&nbsp;char&nbsp;*fname)
{
&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError(fname,CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
}

</pre></font>

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Error codes</h3>
<a name="errorcodes">
</a> 
The error codes defined by this specification are:
<a 
name="error-codes41"></a>

<ul>
<li>
CONTAINER_ERROR_BADARG

 One of the parameters passed to a function is invalid. This is the same as the <font size="-2">EDOM</font> error code used by the function errno. If an implementation uses the <font size="+1"><tt>errno</tt></font> mechanism it can set at each occurrence of this error also <font size="+1"><tt>errno</tt></font> to <font size="-2">EDOM</font>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation<a href="#tthFtNtACF" name="tthFrefACF"><sup>25</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The index is out of bounds. If an implementation uses the <font size="+1"><tt>errno</tt></font> mechanism it can set <font size="+1"><tt>errno</tt></font> to <font size="-2">ERANGE</font>.
The library passes extra parameters when this error is invoked: the <font size="+1"><tt>container</tt></font> pointer, and a <font size="+1"><tt>size_t</tt></font> containing the
the out of bounds index.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The object is read-only and the operation would modify it <a href="#tthFtNtACG" name="tthFrefACG"><sup>26</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_INTERNAL

 Unspecified error provoked by a problem in the implementation.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 A change in the underlying object has invalidated an iterator. If an implementation uses <font size="+1"><tt>errno</tt></font> it can set 
<font size="+1"><tt>errno</tt></font> to <font size="-2">EILSEQ</font><a href="#tthFtNtACH" name="tthFrefACH"><sup>27</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_FILE_READ

 Input error in a stream<a href="#tthFtNtACI" name="tthFrefACI"><sup>28</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_FILE_WRITE

 Output error in a stream.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_CONTAINER_FULL

 Implementations can limit the maximum number of elements a container can hold. This error indicates that the limit is reached.
<a href="#tthFtNtACJ" name="tthFrefACJ"><sup>29</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_BADPOINTER

 The debug implementation of <font size="+1"><tt>free()</tt></font> has discovered an incorrect pointer attempting to be freed<a href="#tthFtNtADA" name="tthFrefADA"><sup>30</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_BUFFEROVERFLOW

 The debug implementation of <font size="+1"><tt>free()</tt></font> discovered a buffer overflow.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_WRONGFILE

 You are trying to read a container from a stream that has no such container saved
<a href="#tthFtNtADB" name="tthFrefADB"><sup>31</sup></a>.
<div class="p"><!----></div>
</li>

<li> 

<div class="p"><!----></div>
CONTAINER_ERROR_DIVISION_BY_ZERO

 The library has detected an attempt to divide by zero<a href="#tthFtNtADC" name="tthFrefADC"><sup>32</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_OVERFLOW

 An overflow was detected in an arithmetic operation. Implementations are encouraged to detect overflow in all operations that
can generate one and report it through this error.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_BADMASK

 The mask given to a <font size="+1"><tt>Select</tt></font> or <font size="+1"><tt>SelectCopy</tt></font> operation is of a different length than the length of the associated
container. The library passes two pointers to the error function: The first to the container and the second to the mask.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_NOENT

 The library wants to open a file that doesn't exist or is not readable. A pointer to the name of the file is passed to the error function
<a href="#tthFtNtADD" name="tthFrefADD"><sup>33</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_WRONG_ITERATOR

 The type of the iterator is wrong, i.e. you are passing a vector iterator to a list for instance.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_LAST_CODE

 This is the last negative number used by the implementation. The user can add error codes below this one, always descending.
For instance

<font size=+1><pre>
#define&nbsp;My_error_Code&nbsp;&nbsp;&nbsp;CONTAINER_ERROR_LAST_CODE&nbsp;-&nbsp;1
#define&nbsp;My_Failure_Code&nbsp;CONTAINER_ERROR_LAST_CODE&nbsp;-&nbsp;2

</pre></font>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Other errors can be defined by each implementation.

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;The iterator interface</h2>
<img src="Iterator.png" alt="Figure">
<div class="p"><!----></div>
The iterator object exposes at least the functions "GetFirst", for initializing the loop, and "GetNext", for getting the next element in the sequence. 
The functions "NewIterator" and "DeleteIterator" are specific to each container interface even if they all have the same syntax.

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Error handling</h3>

<div class="p"><!----></div>
Containers being iterated are not supposed to change when processes or threads read them. Any change in the structure of a container when being read aborts the reading. This error is passed to its handler, that by default breaks the operation.

<div class="p"><!----></div>
This is quite drastic, but provides a consistent memory interface for all containers, it is not necessary to explicitely know what the container is doing or delve in the specific container detail. Code remains portable to other containers easily.

<div class="p"><!----></div>
This is the default behavior, but  of course, much more sophisticated containers can be written, that allow for safe concurrent accessing with a minimum of locks. In such an implementation, the container could be modified without the iterators returning &nbsp;NULL .

<div class="p"><!----></div>
One of the drawbacks of this scheme is that a &nbsp;NULL from an error is identical to the &nbsp;NULL at the end of the container. The callback function for errors is called however, and that allows to differentiate between an error and a normal end of the loop. The alternative would be to return always an int containing the status report, and retrieve the data using a buffer passed as a parameter. This syntax was considered too heavy and cumbersome to be used.

     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;The interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_Iterator&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetNext)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetPrevious)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetFirst)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetCurrent)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetLast)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*Seek)(Iterator&nbsp;*it,size_t&nbsp;pos);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;(*Replace)(Iterator&nbsp;*it,&nbsp;void&nbsp;*data,&nbsp;int&nbsp;direction);
}&nbsp;Iterator;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="GetCurrent+\container52"></a> <font size="+1"><b>GetCurrent</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetCurrent)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Returns the element at the cursor position.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the current element or &nbsp;NULL , if the container is empty or an error occurs. If the container is read-only, a pointer to a copy of the element is returned. This pointer is valid only until the next iterator function is called.
 
<div class="p"><!----></div>
<br /><a 
name="GetFirst+\container52"></a> <font size="+1"><b>GetFirst</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetFirst)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function initializes the given iterator to the first element in the container. For sequential operators this is the element with index zero. In 
associative operators which element is the first is implementation defined and can change if elements are added or removed from the container.

<div class="p"><!----></div>
If the container is empty the result is &nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the first element or &nbsp;NULL , if the container is empty or an error occurs. If the container is read-only, a pointer to a copy of the element 
is returned. This pointer is valid only until the next iterator function is called.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Iterator&nbsp;*myIterator;
List&nbsp;*myList;
myType&nbsp;*obj;&nbsp;//&nbsp;"myList"&nbsp;stores&nbsp;objects&nbsp;of&nbsp;type&nbsp;"myType"
myIterator&nbsp;=&nbsp;iList.NewIterator(myList);&nbsp;//&nbsp;Request&nbsp;iterator
for&nbsp;(obj&nbsp;=&nbsp;myIterator-&#62;GetFirst(myIterator);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;!=&nbsp;NULL;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&nbsp;myIterator-&#62;GetNext(myIterator))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Use&nbsp;obj&nbsp;here
}
iList.DeleteIterator(myIterator);&nbsp;//&nbsp;Reclaim&nbsp;memory

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="GetNext+\container52"></a> <font size="+1"><b>GetNext</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetNext)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Positions de cursor at the next element and returns a pointer to its contents. If the iterator is at the end of the container the result is &nbsp;NULL 
and the iterator remains at the last position, a subsequent call to GetCurrent returns the last element.

<div class="p"><!----></div>
If the container is read-only, a pointer to a copy of the object is returned. This pointer is valid only until the next iterator function is called.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the next element or &nbsp;NULL , if the cursor reaches the last element. If the container is read-only, a pointer to a copy of the element is 
returned, valid until the next element is retrieved

<div class="p"><!----></div>
CONTAINER_ERROR_WRONG_ITERATOR

 The iterator passed is not the expected type. For instance you pass an iterator to a list when iterating a vector.
 
<div class="p"><!----></div>
<br /><a 
name="GetPrevious+\container52"></a> <font size="+1"><b>GetPrevious</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetPrevious)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Positions de cursor at the previous element and returns a pointer to its contents. If the pointer is at the beginning of the container the
result is &nbsp;NULL and the iterator remains at the beginning, a subsequent call to GetCurrent will return the first element of the container.

<div class="p"><!----></div>
This function is meaningful only in sequential containers. Its existence in associative containers is implementation defined. Even in sequential 
containers, it can be very expensive to find a previous element, for instance in single linked lists. In those cases it can always return &nbsp;NULL .

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_WRONG_ITERATOR

 The iterator passed is not the expected type.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the previous element or &nbsp;NULL , if the cursor reached the first element already. If the container is read-only, a pointer to a copy of the 
element is returned.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Iterator&nbsp;*myIterator;
List&nbsp;*myList;
myType&nbsp;*obj;&nbsp;//&nbsp;"myList"&nbsp;stores&nbsp;objects&nbsp;of&nbsp;type&nbsp;"myType"
myIterator&nbsp;=&nbsp;iList.NewIterator(myList);&nbsp;//&nbsp;Request&nbsp;iterator
for&nbsp;(obj&nbsp;=&nbsp;myIterator-&#62;GetLast(myIterator);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;!=&nbsp;NULL;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&nbsp;myIterator-&#62;GetPrevious(myIterator))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Use&nbsp;obj&nbsp;here
}
iList.DeleteIterator(myIterator);&nbsp;//&nbsp;Reclaim&nbsp;memory

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetLast+\container52"></a> <font size="+1"><b>GetLast</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetLast)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Positions the cursor at the last element and returns a pointer to it. Returns &nbsp;NULL if the container is empty.  If the container is read-only, a pointer 
to a copy of the element is returned.

<div class="p"><!----></div>
This function is meaningful only in sequential containers. Its existence in associative containers is implementation defined. Even in sequential 
containers, it can be very expensive to find the last element, for instance in single linked lists. In those cases it can always return &nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_WRONG_ITERATOR

 The iterator passed is not the expected type.
 
<div class="p"><!----></div>
<br /><a 
name="Seek+\container52"></a> <font size="+1"><b>Seek</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*Seek)(Iterator&nbsp;*it,size_t&nbsp;pos);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Positions the given iterator at the indicated position and then returns a pointer to the element's data at that position. 
If the position is bigger than the last element of the container, the last element position will be used.

<div class="p"><!----></div>
This function is supported in sequential containers only.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_WRONG_ITERATOR

 The iterator passed is not the expected type.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the data of the given element or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Replace+\container52"></a> <font size="+1"><b>Replace</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Replace)(Iterator&nbsp;*it,void&nbsp;*data,&nbsp;int&nbsp;direction);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current object pointed by the given iterator with the new data. If the
<font size="+1"><tt><i>data</i></tt></font>
 argument is &nbsp;NULL the element is erased from the
container. If the 
<font size="+1"><tt><i>direction</i></tt></font>
 parameter is different from zero, in sequential containers the iterator will point to the next element,
otherwise it will point to the previous element. In associative containers this parameter is ignored and the iterator is always set to the next
element, if any.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The container is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_WRONG_ITERATOR

 The iterator passed is not the expected type.

<div class="p"><!----></div>
<b>Returns:</b>A positive value if the element was changed or erased, zero if the container was empty, or a negative error code if an error occurred.

<div class="p"><!----></div>

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;The observer interface</h2>
<a 
name="observer60"></a>
In its general form, the observer design pattern can be defined as a one-to-many dependency between objects so that when one object 
changes state, all its dependents are notified and updated automatically. 

<div class="p"><!----></div>
When a container changes its state, specifically when elements are added or removed, it is sometimes necessary to update relationships that 
can be very complex.
The observer interface is designed to simplify this operation by allowing the container to emit <i>notifications</i> to other objects that have 
previously manifested interest in receiving them by <i>subscribing</i> to them. In general notifications are sent only when one of the defined
operations for a container occur, mostly operations that change the number of elements.

<div class="p"><!----></div>
This interface then, establishes a relationship between two software entities:

<ol type="1">
<li> The container, that is responsible for sending the notifications when appropriate
<div class="p"><!----></div>
</li>

<li> The receiver, that is an unspecified object represented by its callback function that is called when a change occurs that matches the
notifications specified in the subscription.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
Since this relationship needs both objects, it will be finished when either object goes out of scope or breaks the relationship for whatever 
reason. Both objects can unsubscribe (terminate) their relationship.

     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Caveats</h3>

<ul>
<li>It is in general a bad idea to modify the object being observed during a notification since this could trigger other notification
messages. Implementations are not required to avoid this situation that is the responsibility of the programmer. Contrary to the iterator interface
no error is issued when a possible infinite loop is started. Implementations may catch the error by limiting the number of recursive
invocations of this interface but they are not required to do so.
<div class="p"><!----></div>
</li>

<li>
Since all messages sent by the containers have different type of information in the same two arguments that each message is associated with,
there is no possible compile time control of the usage of the received pointers or numbers. The observer function must correctly 
discriminate between the different messages it can receive<a href="#tthFtNtADE" name="tthFrefADE"><sup>34</sup></a>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;The interface</h3>

<font size=+1><pre>
typedef&nbsp;void&nbsp;(*ObserverFunction)(const&nbsp;void&nbsp;*ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Operation,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo[]);

typedef&nbsp;struct&nbsp;tagObserverInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Subscribe)(void&nbsp;*ObservedObject,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback,&nbsp;unsigned&nbsp;Operations);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Notify)(const&nbsp;void&nbsp;*ObservedObject,unsigned&nbsp;operation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo1,void&nbsp;*ExtraInfo2);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Unsubscribe)(void&nbsp;*ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback);
}&nbsp;ObserverInterface;
extern&nbsp;ObserverInterface&nbsp;iObserver;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="ObserverFunction+\container62"></a> <font size="+1"><b>ObserverFunction</b></font> <hr />


<font size=+1><pre>

typedef&nbsp;void&nbsp;(*ObserverFunction)(void&nbsp;*ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Operation,&nbsp;void&nbsp;*ExtraInfo[]);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function will be called by the interface when a notification is received for an observed object.  The call happens after all arguments have been processed, the actual work of the function is finished (when adding an object) or not yet done (when destroying an object). 
The container is in a consistent state. For the callbacks that are called when an object is deleted from a
container the call happens before any call to <font size="+1"><tt>free()</tt></font> and before any call to a destructor (if any) is done. For the calls that add an object
the callback is called after the container has been modified. 

<div class="p"><!----></div>
Arguments:

<ol type="1">
<li> <font size="+1"><tt>ObservedObject</tt></font>: Specifies the object that sends the notification, i.e. the container
that has the subscription. It is assumed that this container conforms to the <font size="+1"><tt>iGeneric</tt></font> interface.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Operation</tt></font>: The operation that provoked the notification. Since it is possible to subscribe to several operations with only one callback function,
this argument allows the callback to discriminate between the operation notifications.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>ExtraInfo</tt></font>: This argument is specific to each operation and conveys further information<a href="#tthFtNtADF" name="tthFrefADF"><sup>35</sup></a> for each operation.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
None of the arguments will be ever &nbsp;NULL or zero.
 
<div class="p"><!----></div>
<br /><a 
name="Subscribe+\container62"></a> <font size="+1"><b>Subscribe</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Subscribe)(void&nbsp;*ObservedObject,&nbsp;ObserverFunction&nbsp;callback,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Operations);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function establishes the relationship between the observed object (argument 1) and the observer, represented by its callback (argument 2).
The third argument establishes which operations are to be observed.
This operation performs an allocation to register the relationship in the observer interface tables, therefore it can fail with an out of memory 
condition.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The observed object pointer is &nbsp;NULL , the callback function pointer is &nbsp;NULL , or the operations argument is zero.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to proceed.

<div class="p"><!----></div>
<b>Returns:</b>An integer greater than zero if the relationship was established, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Notify+\container62"></a> <font size="+1"><b>Notify</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Notify)(void&nbsp;*ObservedObject,unsigned&nbsp;Operation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo1,void&nbsp;*ExtraInfo2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function will be used by the container to send a message to the receiver callback. The arguments correspond roughly to the arguments the callback
function will receive. "Notify" will call all the objects that are observing <font size="+1"><tt>ObservedObject</tt></font> and that have subscribed to one of the 
operations
specified in the <font size="+1"><tt>Operation</tt></font> argument. This implies a search through the observer interface table, and possibly several calls, making
this function quite expensive. The time needed is roughly proportional to the number of registered callbacks and the complexity of the callbacks
themselves.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The ObservedObject pointer is &nbsp;NULL or the Operation argument is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number with the number of objects that received the notifications, zero if there was no match for the combination of observed object and operations specified, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Unsubscribe+\container62"></a> <font size="+1"><b>Unsubscribe</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Unsubscribe)(void&nbsp;*ObservedObject,&nbsp;ObserverFunction&nbsp;callback);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function breaks the relationship between the observed object and the observer. There are several combinations of both arguments:

<ul>
<li> The <font size="+1"><tt>ObservedObject</tt></font> argument is &nbsp;NULL . This means that the <font size="+1"><tt>callback</tt></font> object wants to break its relationship to all objects it is
observing. The observer interface will remove all relationships that contain this callback from its tables.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>callback</tt></font> argument is &nbsp;NULL . This means that the given <font size="+1"><tt>ObservedObject</tt></font> is going out of scope and wants to break all
relationships to all its observers. The interface removes from its tables all relationships that have this object as the observed object.
This happens normally immediately after the notification <font size="+1"><tt>FINALIZE</tt></font> is sent.
<div class="p"><!----></div>
</li>

<li> If both <font size="+1"><tt>callback</tt></font> and <font size="+1"><tt>ObservedObject</tt></font> are non &nbsp;NULL , only the matching relationship will be removed from the tables.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Notification messages</h3>

<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table>
<tr><td width="98"><b>Operation</b> </td><td width="197"><b>Argument 1</b> </td><td width="177"><b>Argument 2</b></td></tr>
<tr><td width="98"></td></tr>

<tr><td width="98">
<div class="p"><!----></div>

<div class="p"><!----></div>
 </td></tr>
<tr><td width="98"><b>Operation</b> </td><td width="197"><b>Argument 1</b> </td><td width="177"><b>Argument 2</b></td></tr>
<tr><td width="98"></td></tr>

<tr><td width="98">Add</td><td width="197">Pointer to the new object</td><td width="177">&nbsp;NULL or slice specs if any</td></tr>
<tr><td width="98">AddRange</td><td width="197">A <font size="+1"><tt>size_t</tt></font> with the number of objects added</td><td width="177">Pointer to a table of <i>n</i> elements that were added</td></tr>
<tr><td width="98">Append</td><td width="197">A pointer to the object being appended.</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Clear</td><td width="197">Pointer to the container being cleared</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Copy</td><td width="197">Pointer to the copy of the container</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Erase</td><td width="197">Pointer to the object being deleted. The object is still valid</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">EraseAt</td><td width="197">Pointer to object being deleted</td><td width="177">Position (as size_t)</td></tr>
<tr><td width="98">Finalize</td><td width="197">&nbsp;NULL </td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Insert</td><td width="197">Pointer to the new object being inserted</td><td width="177">A <font size="+1"><tt>size_t</tt></font> with the position of the object being inserted if applicable</td></tr>
<tr><td width="98">InsertIn</td><td width="197">Pointer to the object being inserted, that has the same type as the object sending the notification</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Pop</td><td width="197">Pointer to the object being popped</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Push</td><td width="197">Pointer to the object being pushed</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">ReplaceAt</td><td width="197">Pointer to the old value</td><td width="177">Pointer to the new value</td></tr>
<tr><td width="98"></td></tr></table>
</center>
<div class="p"><!----></div>
Here is a complete example that demonstrates some of the above functions.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

include&nbsp;"containers.h"
static&nbsp;void&nbsp;fn(void&nbsp;*ObservedObject,&nbsp;unsigned&nbsp;operation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraInfo[])
{
&nbsp;&nbsp;&nbsp;&nbsp;printf("Object&nbsp;is&nbsp;%p,&nbsp;operation&nbsp;is&nbsp;%d\n",ObservedObject,operation);
}
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayInt&nbsp;*&nbsp;vInt&nbsp;=&nbsp;iValArrayInt.CreateSequence(24,0,1);

&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;array:&nbsp;\n");
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Subscribe(vInt,fn,CCL_ADD|CCL_FINALIZE);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Adding&nbsp;an&nbsp;integer\n");
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Add(vInt,4096);
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Finalize(vInt);
}
OUTPUT:
Original&nbsp;array:&nbsp;
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;
Adding&nbsp;an&nbsp;integer
Object&nbsp;is&nbsp;0x100100080,&nbsp;operation&nbsp;is&nbsp;1
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;4096&nbsp;
Object&nbsp;is&nbsp;0x100100080,&nbsp;operation&nbsp;is&nbsp;16

</pre></font>
We setup our observer function calling the Subscribe API. We request to be notified when there is an addition and when the object
finalizes. Our callback function does nothing but print some of its arguments. We see that we get called when the requested operations are performed.

 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Types used by the library</h2>
Here is a complete list of all the auxiliary data types defined by the library. This definitions are the minimum requirements, i.e. all the fields mentioned here must be present in all implementations. Many implementations will need more fields, that in all cases can be added to the data
types present here without affecting conformance. 

<div class="p"><!----></div>
The order and specific layout of the structure fields are not normative: an implementation can change this order, or insert extra fields between them.
If an implementation does insert fields between the here mentioned fields it becomes binary incompatible with the sample implementation and maybe
with other implementations that respect this order. An alternative way to expand the structure is to add fields at the end, retaining binary
compatibility with other implementations. This choice is obviously implementation defined.

<div class="p"><!----></div>
An implementation can change the signature of the function pointers described here by adding optional arguments after the required ones using the
standard C mechanism for variable arguments functions. This retains source and binary compatibility with the standard, allowing for extensions
specific to the implementation.

     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;CompareInfo</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagCompareInfo&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs;
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*ContainerLeft;
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*ContainerRight;
}&nbsp;CompareInfo;

</pre></font>
This structure will be passed to the comparison functions. The <font size="+1"><tt>ExtraArgs</tt></font> pointer will receive the pointer that was passed to the calling function. If both elements being compared are members of a single container, the <font size="+1"><tt>ContainerRight</tt></font> member will be &nbsp;NULL and <font size="+1"><tt>ContainerLeft</tt></font>
will hold a pointer to the container where both elements belong. Otherwise <font size="+1"><tt>ContainerLeft</tt></font> will hold a pointer to the container that holds
the first argument, and <font size="+1"><tt>ContainerRight</tt></font> to the one that holds the second. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;CompareFunction</h3>
<a 
name="CompareFunction72"></a>

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*CompareFunction)(const&nbsp;void&nbsp;*elem1,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*elem2,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;*ExtraArgs);

</pre></font>
This type defines the function used to compare two elements.
The result should be less than zero if elem1 is less than elem2, zero if they are equal, and bigger than zero if elem1 is bigger than element 2.

<div class="p"><!----></div>
The default comparison function is <font size="+1"><tt>memcmp</tt></font>. This function will compare all the object's area, including eventually padding bytes added by
compilers for alignment reasons. To minimize this problem always zero the objects before assigning the values. For instance:

<font size=+1><pre>
struct&nbsp;Data&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Age;&nbsp;//&nbsp;Here&nbsp;the&nbsp;compiler&nbsp;can&nbsp;introduce&nbsp;padding&nbsp;bytes
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;Weight;
};

int&nbsp;fn(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;Data&nbsp;m;
&nbsp;&nbsp;&nbsp;&nbsp;memset(&amp;m,0,sizeof(m));
&nbsp;&nbsp;&nbsp;&nbsp;m.Age&nbsp;=&nbsp;23;
&nbsp;&nbsp;&nbsp;&nbsp;m.Weight&nbsp;=&nbsp;76;
&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(DataCollection,&amp;m);
}

</pre></font>
By zeroing the structure before making the assignments, we have a known value in the padding bytes. If we make comparisons with memcmp, they will
work correctly.

<div class="p"><!----></div>
Obviously the best way to avoid this problem is to avoid any default comparison function by defining one.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Save function</h3>
<a 
name="SaveFunction73"></a>

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*SaveFunction)(const&nbsp;void&nbsp;*element,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArg,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*OutputStream);

</pre></font>
This function should save the given element into the given stream.  The <font size="+1"><tt>ExtraArg</tt></font> argument receives any argument passed to the Save function.
The result should be bigger than zero if the operation completed successfully, zero or less than zero otherwise.

<div class="p"><!----></div>
What the save function does is unknown to the rest of the library, basically the only requirement is that its output should be understood by the
read function, when called to read each element. The size of the written data can be bigger (or smaller) than the size of each stored element,
according to the specific requirements of the application data. This allows to write save functions that would write a complete data set, including
embedded objects into the stream. For instance a save function can save the contents pointed by a character pointer instead of the pointer value 
that would be meaningless when read again.

<div class="p"><!----></div>
The default save function provided by the implementation just writes the contents of each element into the stream. Embedded pointers aren't followed.

     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Read function</h3>
<a 
name="ReadFunction74"></a>

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*ReadFunction)(void&nbsp;*element,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArg,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*InputStream);

</pre></font>
This function should read into the given element from the given stream. The <font size="+1"><tt>ExtraArg</tt></font> argument is passed to the container read function and allows to pass an argument to the user defined save function. The amount of data read is unknown to the rest of the software and the only requirement
is that it should reverse the work of the save function.

<div class="p"><!----></div>
The default read function provided by the implementation should read the contents of one element from the stream and add it to the result container.

<div class="p"><!----></div>
The result is bigger than zero if the operation completed successfully, zero or less than zero otherwise.

     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;Error function</h3>
<a 
name="ErrorFunction75"></a>

<font size=+1><pre>
typedef&nbsp;void&nbsp;*(*ErrorFunction)(const&nbsp;char&nbsp;*functionName,int&nbsp;code,...);

</pre></font>
This function type is used to handle errors in each container. The first argument is the name of the function where the error occurred, the second is a 
negative error code. No checks are performed on the function name argument, and other information or messages could be included in the message.

<div class="p"><!----></div>
Note that this function is roughly compatible with the prototype of snprintf, and could be used with a format string, a buffer size, and a series of 
arguments corresponding to the arguments the format requires. The only problem is the conversion between <font size="+1"><tt>int</tt></font> and <font size="+1"><tt>size_t</tt></font>.

<div class="p"><!----></div>
The result value of the default error function is always &nbsp;NULL . This result will be in most cases ignored, except in the vector container where
it can be used to return special values in the case of the <font size="+1"><tt>INDEX</tt></font> error.

<div class="p"><!----></div>
When <font size="+1"><tt>iVector</tt></font> interface detects an index error, it will pass in the extra arguments the array pointer and a <font size="+1"><tt>size_t</tt></font> containing 
the out of bounds index.

     <h3><a name="tth_sEc7.6">
7.6</a>&nbsp;&nbsp;Destructor function</h3>
<a 
name="DestructorFunction76"></a>

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*DestructorFunction)(void&nbsp;*object);

</pre></font>
This function is called when an object is being destroyed. An object is destroyed when:

<ul>
<li> An <font size="+1"><tt>Erase</tt></font> call is done.
<div class="p"><!----></div>
</li>

<li> A <font size="+1"><tt>Replace</tt></font> call is done.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>Clear</tt></font> call is done.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>Select</tt></font> call is done with some element of the mask to zero.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>Resize</tt></font> function is called with an argument less than the size of the container.
<div class="p"><!----></div>
</li>
</ul>
This function should free any memory used by pointers within the object <b>without</b> freeing the object memory itself. In most cases the memory
used by the library is <b>not</b> allocated with malloc. Its result type is less than zero when an error occurred or greater than zero when
it finished successfully. It is implementation defined what happens if a destructor encounters an error.

<div class="p"><!----></div>

 <h1><a name="tth_chAp6">
Chapter 6 </a><br />The containers</h1>
<a 
name="List06"></a>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;The List interfaces: iList, iDlist</h2>
The list container appears in two flavors: 

<ul>
<li>single linked lists: the iList type
<div class="p"><!----></div>
</li>

<li>
double linked lists the iDlist type
<div class="p"><!----></div>
</li>
</ul>
The space overhead of single linked lists is smaller at the expense of more difficult access to the elements. It is up to the application programmer to decide which container fits best in his/her application
<a href="#tthFtNtADG" name="tthFrefADG"><sup>36</sup></a>.

<div class="p"><!----></div>
It is often more efficient to get the next element from a list starting with the previous element instead of searching the whole list starting from the beginning. For this, the list and the Dlist containers provide:


<ul>
<li> <font size="+1"><tt>FirstElement</tt></font> Start of the list
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>LastElement</tt></font> End of the list
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>NextElement</tt></font> Returns a pointer to the next element
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>PreviousElement</tt></font> Only in double linked lists. Returns a pointer to the previous element.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>GetElementData</tt></font> Extracts a pointer to the element data
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>SetElementData</tt></font> Modifies one element of the list.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Advance</tt></font> Returns the data of an element and advances the given pointer in one operation.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>MoveBack</tt></font> Returns the data of an element and moves back the pointer one element. This operation is available only in double linked lists.

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
These operations can't be done in a read-only list.

<div class="p"><!----></div>
The exact layout of the <font size="+1"><tt>ListElement</tt></font> structure is undefined and private to each implementation. This is the reason for providing the <font size="+1"><tt>GetElementData</tt></font> function: it hides the exact position and layout of the data from user code, that remains independent from implementation details.

<div class="p"><!----></div>
The interfaces of both containers are very similar. Double linked lists support all functions in single linked ones, and add a few more. To avoid unnecessary repetition we document here all the single linked list interface, then only the functions that the Dlist interface adds to it.
<a 
name="iList10"></a><a 
name="lists+single linked10"></a>

<BR CLEAR=LEFT><BR><BR>

<img src="ListVocabulary.png" alt="Figure">
<BR CLEAR=LEFT><BR><BR>


<div class="p"><!----></div>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagListInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(List&nbsp;*L,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(List&nbsp;*L,&nbsp;size_t&nbsp;n,const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Advance)(ListElement&nbsp;**pListElement);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(List&nbsp;*l1,List&nbsp;*l2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(List&nbsp;*L,int(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Back)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(List&nbsp;*L);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;List&nbsp;*L,const&nbsp;void&nbsp;*element);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*Copy)(const&nbsp;List&nbsp;*L);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;List&nbsp;*list,size_t&nbsp;idx,void&nbsp;*OutBuffer);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*Create)(size_t&nbsp;element_size);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;List&nbsp;*l1,const&nbsp;List&nbsp;*l2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(List&nbsp;*L,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(List&nbsp;*l,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(List&nbsp;*L,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseRange)(List&nbsp;*L,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(List&nbsp;*L);
&nbsp;&nbsp;&nbsp;ListElement&nbsp;*(*FirstElement)(List&nbsp;*l);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Front)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;List&nbsp;*list);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;List&nbsp;*L,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElementData)(ListElement&nbsp;*le);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;List&nbsp;*L);
&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*(*GetHeap)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*GetRange)(const&nbsp;List&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(const&nbsp;List&nbsp;*L,const&nbsp;void&nbsp;*SearchedElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*Init)(List&nbsp;*aList,size_t&nbsp;element_size);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(List&nbsp;*L,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*InitWithAllocator)(List&nbsp;*aList,size_t&nbsp;element_size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(List&nbsp;*L,size_t&nbsp;idx,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(List&nbsp;*l,&nbsp;size_t&nbsp;idx,List&nbsp;*newData);
&nbsp;&nbsp;&nbsp;ListElement&nbsp;*(*LastElement)(List&nbsp;*l);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;loadFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(List&nbsp;*L);
&nbsp;&nbsp;&nbsp;ListElement&nbsp;*(*NextElement)(ListElement&nbsp;*le);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(List&nbsp;*L,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(List&nbsp;*L,const&nbsp;void&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(List&nbsp;*l,size_t&nbsp;start,&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(List&nbsp;*L,size_t&nbsp;idx,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(List&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(List&nbsp;*l,&nbsp;size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(List&nbsp;*l,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;List&nbsp;*L,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(List&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*SelectCopy)(const&nbsp;List&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(List&nbsp;*l,CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(List&nbsp;*v,DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetElementData)(List&nbsp;*l,&nbsp;ListElement&nbsp;*le,void&nbsp;*data);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(List&nbsp;*L,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(List&nbsp;*L,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;List&nbsp;*L);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;List&nbsp;*);
&nbsp;&nbsp;&nbsp;ListElement&nbsp;*(*Skip)(ListElement&nbsp;*l,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(List&nbsp;*l);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*SplitAfter)(List&nbsp;*l,&nbsp;ListElement&nbsp;*pt);
&nbsp;&nbsp;&nbsp;int&nbsp;(*UseHeap)(List&nbsp;*L,&nbsp;const&nbsp;ContainerAllocator&nbsp;*m);
}&nbsp;ListInterface;

</pre></font>


<div class="p"><!----></div>
     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;General remarks</h3>
Lists are containers that store each element in a sequence, unidirectionally (single linked lists) or bidirectionally (double linked lists).
The advantage of linked lists is their flexibility. You can easily and with a very low cost remove or add elements by manipulating the links between the elements. Single linked lists have less overhead than their double linked counterparts (one pointer less in each node), but they tend to use a lot of computer power when inserting elements near the end of the list: you have to follow all links from the beginning until you find the right one.

<div class="p"><!----></div>
The list nodes themselves do not move around, only their links are changed. This can be important if you maintain pointers to those elements. Obviously, if you delete a node, its contents (that do not move) could be recycled to contain something else than what you expect.

<div class="p"><!----></div>
The iList interface consists (as all other interfaces) of a table of function pointers. The interface describes the behavior of the List container.

<div class="p"><!----></div>
The stack operations push and pop are provided with PushFront and PopFront because they have a very low cost, insertion at the start of a single linked list is very fast. PushBack is the equivalent of the <font size="+1"><tt>Add</tt></font> operation, but PopBack would have a very high cost since it would need going through all the list. 

<div class="p"><!----></div>
The list container features in some implementations a per list error function.  This is the function that will be called for any errors, except in  
cases where no list object exists: the creation function, or the error of getting a &nbsp;NULL pointer instead of a list pointer. In those cases the general 
iError interface is used, and iError.RaiseError is called. The default value of the list error function is the function iError.RaiseError at the moment 
the list is created.

<div class="p"><!----></div>
Other implementations of this interface may specialize list for a certain category of uses: lists of a few elements would try to reduce overhead by 
eliminating a per list error function and replace it with the standard error function in iError, for instance, eliminating their fields in the header. 
If the read-only flag support is dropped, the whole "Flags" field can be eliminated. In such an implementation, the SetFlags primitive would always 
return an error code.

<div class="p"><!----></div>
The sample implementation of the list container supports the following state flags:

<font size=+1><pre>
#define&nbsp;CONTAINER_READONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1

</pre></font>
If this flag is set, no modifications to the container are allowed, and the Clear and Finalize functions will not work. Only copies of the data are 
handed out, no direct pointers to the data are available.

<font size=+1><pre>
#define&nbsp;CONTAINER_SORTED_FRONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2
#define&nbsp;CONTAINER_SORTED_BACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4

</pre></font>
If this flag is set, the container is maintained always in sorted order, with the biggest element at the index zero for <font size="+1"><tt>CONTAINER_SORTED_FRONT</tt></font>
or with the biggest element at the end if <font size="+1"><tt>CONTAINER_SORTED_BACK</tt></font> is set. It is an error if both flags are set, and the results in that  case
are implementation defined.

      <h4><a name="tth_sEc1.1.1">
1.1.1</a>&nbsp;&nbsp;Specializations</h4>
All &#223;pecialized" containers share the same interface with the following exceptions:


<ul>
<li> The functions where a <font size="+1"><tt>void&nbsp;*</tt></font> to the element data is passed or where a <font size="+1"><tt>void&nbsp;*</tt></font> is the result of the operation are replaced with the 
actual data type of the specialization. For instance the <font size="+1"><tt>GetElement</tt></font> API instead of returning a void pointer returns a pointer to the specific 
data type: an 
integer for <font size="+1"><tt>intList</tt></font>, a double for <font size="+1"><tt>doubleList</tt></font> etc.
<div class="p"><!----></div>
</li>

<li> The creation and initialization functions that construct a new container receive one argument less than its generic counterparts since the
size of each element is fixed.

<div class="p"><!----></div>
To make things clear and to save work from the library user, some specializations are delivered with the sample implementation to show how a
<i>file templated</i> container looks like.

<div class="p"><!----></div>
</li>
</ul>


<center>
<img src="ListContainerSpecializations.png" alt="Figure">
</center>
In the right side of the drawing we see the generic list container using generic pointers (<font size="+1"><tt>void&nbsp;*</tt></font>) and the stringlist container. Strings are 
special because in C their length is the result of a function call instead of being fixed like other data types.

<div class="p"><!----></div>
In the left side, we see three specialized containers for some numeric data types. Those containers are generated using two types of source files:


<ul>
<li> Parameter files: They define the data type and some other parameters like the comparison expression.
<div class="p"><!----></div>
</li>

<li> Templated files: They implement the specialized container. The pre-processor does the editing work on the templated file to yield several 
different type definitions. Using this interface has the advantage of ensuring compile time checking of the arguments to the API, what is not
possible using generic pointers.

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container11"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Add)(List&nbsp;*l,const&nbsp;void&nbsp;*data);
int&nbsp;(*Add)(TYPEList&nbsp;*l,&nbsp;TYPE&nbsp;data);

</pre></font>

<div class="p"><!----></div>

  <b>Description:</b> 
Adds the given element to the container. In its generic form it is assumed that "data" points to a contiguous memory area of at least ElementSize 
bytes. In its specialized form the data is passed by value. Returns a value greater than zero if the addition of the element to the list completed 
successfully, a negative error code otherwise.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the data pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input data is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element was added or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

/*&nbsp;This&nbsp;example&nbsp;shows&nbsp;how&nbsp;to:&nbsp;
(1)&nbsp;Create&nbsp;a&nbsp;linked&nbsp;list&nbsp;of&nbsp;"double"&nbsp;data
(2)&nbsp;Fill&nbsp;it&nbsp;using&nbsp;the&nbsp;"Add"&nbsp;function
(3)&nbsp;Print&nbsp;it&nbsp;using&nbsp;the&nbsp;GetElement&nbsp;function&nbsp;*/
#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;PrintList(List&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*(double&nbsp;*)iList.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
static&nbsp;void&nbsp;FillList(List&nbsp;*&nbsp;AL,size_t&nbsp;siz)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;siz;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*AL&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;FillList(AL,10);
&nbsp;&nbsp;&nbsp;&nbsp;PrintList(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>
Using the templated container implementation:

<font size=+1><pre>
#include&nbsp;&lt;containers.h&#62;
#include&nbsp;&lt;doublelist.h&#62;
static&nbsp;void&nbsp;PrintList(doubleList&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;idoubleList.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",idoubleList.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
static&nbsp;void&nbsp;FillList(doubleList&nbsp;*&nbsp;AL,size_t&nbsp;siz)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;siz;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idoubleList.Add(AL,(double)i);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;doubleList&nbsp;*AL&nbsp;=&nbsp;idoubleList.Create();
&nbsp;&nbsp;&nbsp;&nbsp;FillList(AL,10);
&nbsp;&nbsp;&nbsp;&nbsp;PrintList(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Advance+\container11"></a> <font size="+1"><b>Advance</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*Advance)(ListElement&nbsp;**ppElement);
TYPE&nbsp;*(*Advance)(TYPEListElement&nbsp;**ppElement);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Given the address of a pointer to an element, it returns a pointer to the data stored into that element and writes the address of the next element
into its argument <font size="+1"><tt>ppElement</tt></font>. If ppElement is&nbsp;NULL it returns&nbsp;NULL . If <font size="+1"><tt>*ppElement</tt></font> is&nbsp;NULL it also returns&nbsp;NULL , and obviously there 
is no advancing done.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the data stored in the given element or&nbsp;NULL if the data can't be retrieved.
 
<div class="p"><!----></div>
<br /><a 
name="AddRange+\container11"></a> <font size="+1"><b>AddRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(List&nbsp;*&nbsp;AL,size_t&nbsp;n,&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(TYPEList&nbsp;*&nbsp;AL,size_t&nbsp;n,&nbsp;TYPE&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the n given elements to the end of the container. It is the same operations as the PushBack operation. It is assumed that "data" points to a 
contiguous memory area of at least n*ElementSize bytes. If <i>n</i> is zero no error is issued even if the array pointer or the data pointer are 
&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the data pointers are &nbsp;NULL , and n is not zero.

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Append+\container11"></a> <font size="+1"><b>Append</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(List&nbsp;*list1,List&nbsp;*list2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Appends the contents of list2 to list1 and destroys list2.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either list1 or list2 are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 One or both lists are read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The size of the elements in the lists differ, or the lists allocators are different <a href="#tthFtNtADH" name="tthFrefADH"><sup>37</sup></a>. 

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;PrintList(List&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*(double&nbsp;*)iList.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
static&nbsp;void&nbsp;FillList(List&nbsp;*&nbsp;AL,size_t&nbsp;siz)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;siz;i++)&nbsp;{&nbsp;double&nbsp;d&nbsp;=&nbsp;i;&nbsp;iList.Add(AL,&amp;d);}
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L1&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L2&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;FillList(L1,10);
&nbsp;&nbsp;&nbsp;&nbsp;FillList(L2,10);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Append(L1,L2);
&nbsp;&nbsp;&nbsp;&nbsp;PrintList(L1);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container11"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(List&nbsp;l,int&nbsp;(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(List&nbsp;l,int&nbsp;(Applyfn)(TYPE&nbsp;,void&nbsp;*),void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Will call the given function for each element of the list. The first argument of the callback function receives an element of the list. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the list is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either list or Applyfn are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

: The list is read-only and there is no more memory to allocate the buffer to copy each element.


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
The list container of C++ has no direct equivalent, but in the algorithm part of the STL there is a "for_each" construct, that does essentially the same. Java and C# offer a similar "ForEach" functionality.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;int&nbsp;Callback(void&nbsp;*pElement,void&nbsp;*pResult)
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p&nbsp;=&nbsp;pElement;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*result&nbsp;=&nbsp;pResult;
&nbsp;&nbsp;&nbsp;&nbsp;*result&nbsp;+=&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
&nbsp;&nbsp;&nbsp;&nbsp;
void&nbsp;main(void)&nbsp;
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(list,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;3;
&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(list,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Apply(list,Callback,&amp;sum);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Here&nbsp;sum&nbsp;should&nbsp;be&nbsp;5.
&nbsp;&nbsp;&nbsp;&nbsp;printf("%g\n",sum);
}

/*&nbsp;Template&nbsp;file&nbsp;example&nbsp;*/
#include&nbsp;&lt;containers.h&#62;
#include&nbsp;"doublelist.h"
static&nbsp;int&nbsp;Callback(double&nbsp;Element,void&nbsp;*pResult)
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*result&nbsp;=&nbsp;pResult;
&nbsp;&nbsp;&nbsp;&nbsp;*result&nbsp;+=&nbsp;Element;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
&nbsp;&nbsp;&nbsp;&nbsp;
void&nbsp;main(void)&nbsp;
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;doubleList&nbsp;*list&nbsp;=&nbsp;idoubleList.Create();
&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(list,2);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(list,3);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Apply(list,Callback,&amp;sum);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Here&nbsp;sum&nbsp;should&nbsp;be&nbsp;5.
&nbsp;&nbsp;&nbsp;&nbsp;printf("%g\n",sum);
}

</pre></font>
The above example shows a function callback as used by &#196;pply". It receives two pointers, one to the current element and another to an extra argument that in this case contains a pointer to the sum. For each call to the callback, the function adds the contents of the element to the sum.

<div class="p"><!----></div>
The main function creates a list, adds two elements with the values 2 and 3, and then calls &#196;pply" to get their sum using the callback.
 
<div class="p"><!----></div>
<br /><a 
name="Back+\container11"></a> <font size="+1"><b>Back</b></font> <hr />


<font size=+1><pre>

const&nbsp;void&nbsp;*(*Back)(const&nbsp;List&nbsp;*list);
const&nbsp;TYPE&nbsp;&nbsp;(*Back)(const&nbsp;TYPEList&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the last element of the given list or &nbsp;NULL if the list is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
The last element or &nbsp;NULL if the list is empty or an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container11"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The list header will not be destroyed, and its contents will be the same as when the list was initially created. It is an error to use this function when there are still active iterators for the container.<a href="#tthFtNtADI" name="tthFrefADI"><sup>38</sup></a>

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

List&nbsp;*l;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m&nbsp;=&nbsp;iList.Clear(l);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Contains+\container11"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(List&nbsp;*list,void&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(TYPEList&nbsp;*l,&nbsp;TYPE&nbsp;data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns one if the given data is stored in the list, zero otherwise. The "data" argument is supposed to point to an element at least ElementSize bytes. The list's comparison function is used for determining if two elements are equal. This comparison function defaults to memcmp.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either list or data are &nbsp;NULL .


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
C++ has std::find that does essentially the same . Java and C# have a "Contains" method.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.Contains(list,&amp;data);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container11"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*Copy)(const&nbsp;List&nbsp;*L);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
A shallow copy of the given list is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the given list's allocator.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
C++ has no direct equivalent but the assignment operator should work, Java and C# support a copy method.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*newList,*OldList;
&nbsp;&nbsp;&nbsp;&nbsp;newList&nbsp;=&nbsp;iList.Copy(OldList);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newList&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="CopyElement+\container11"></a> <font size="+1"><b>CopyElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;List&nbsp;*list,size_t&nbsp;idx,void&nbsp;*outBuffer);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;TYPEList&nbsp;*list,size_t&nbsp;idx,TYPE&nbsp;*outBuffer);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the element data at the given position into the given buffer, assuming that at least ElementSize bytes of storage are available at the position pointed by the output buffer. The main usage of this function is to access data in a read only container for later modification.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer or the output buffer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if it failed.

<div class="p"><!----></div>

  <b>Notes:</b>
<div class="p"><!----></div>
Neither C# nor Java provide this functionality because the treatment of pointers in those languages makes the need for such a construct unnecessary.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;&nbsp;double&nbsp;d;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iList.CopyElement(list,3,&amp;d)&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;value&nbsp;at&nbsp;position&nbsp;3&nbsp;is&nbsp;%g\n",d);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container11"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*Create)(size_t&nbsp;element_size);
&nbsp;&nbsp;&nbsp;&nbsp;TYPEList&nbsp;*(*Create)(void);&nbsp;//&nbsp;Template&nbsp;version

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The creation function returns an empty List container, initialized with all the default values.
The current memory manager is used to allocate the space needed for the List header. The list is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the list with sizeof(void *) as the size parameter.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a newly created List or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given element size is zero or greater than what the implementation allows for maximum object size.

<div class="p"><!----></div>
Errors provoke the call of the current default error function of the library since this is the creation function and there isn't a container specific error function yet.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*ListOfDoubles&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;doubleList&nbsp;*ListOfDoubles&nbsp;=&nbsp;idoubleList.Create();

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CreateWithAllocator+\container11"></a> <font size="+1"><b>CreateWithAllocator</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elem_size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator);
//&nbsp;Template&nbsp;file&nbsp;version
TYPEList&nbsp;*(*CreateWithAllocator)(ContainerAllocator&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The creation function returns an empty List container, initialized with all the default values.
The given memory manager is used to allocate the space needed for the List header. The list is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the list with sizeof(void *) as the size parameter.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a newly created List or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given element size is zero or greater than what the implementation allows for maximum object size, or the given allocator pointer is &nbsp;NULL .

<div class="p"><!----></div>
Errors provoke the call of the current default error function of the library since this is the creation function and there isn't a container specific error function yet.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

ContainerAllocator&nbsp;*myAllocator;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*ListOfDoubles&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.CreateWithAllocator(sizeof(double),myAllocator);
&nbsp;&nbsp;&nbsp;&nbsp;doubleList&nbsp;*ListOfDoubles&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idoubleList.CreateWithAllocator(myAllocator);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="DeleteIterator+\container11"></a> <font size="+1"><b>DeleteIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;DeleteIterator(Iterator&nbsp;*it);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims the memory used by the given iterator object

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful or a negative error code.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetElementData+\container11"></a> <font size="+1"><b>GetElementData</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElementData)(ListElement&nbsp;*le);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Accesses and returns a pointer to the raw data field of a <font size="+1"><tt>ListElement</tt></font> skipping the container related fields.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Equal+\container11"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;List&nbsp;*list1,const&nbsp;List&nbsp;*list2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares the given lists using the list comparison function of either list1 or list2 that must compare equal. If the list differ in their length, flags, or any other characteristic they compare unequal. If any of their elements differ, they compare unequal.
If both list1 and list2 are &nbsp;NULL they compare equal. If both list1 and list2 are empty they compare equal.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None


<div class="p"><!----></div>
 <b>Invariants:</b>
The two lists are not modified.

<div class="p"><!----></div>
<b>Returns:</b>
The result is one if the lists are equal, zero otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container11"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(List&nbsp;*list,void&nbsp;*const&nbsp;data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list the element that matches the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that a match was found and the element was removed. If the element is not in the list the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.Erase(list,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("2.3&nbsp;erased\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;==&nbsp;CONTAINER_ERROR_NOTFOUND)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("No&nbsp;element&nbsp;with&nbsp;value&nbsp;2.3&nbsp;present\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("2.3&nbsp;not&nbsp;erased.&nbsp;Error&nbsp;is&nbsp;\%s\n",iError.StrError(r));

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="EraseAll+\container11"></a> <font size="+1"><b>EraseAll</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(List&nbsp;*list,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list all elements that match the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that a match was found and the element was removed. If the element is not in the list the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="EraseAt+\container11"></a> <font size="+1"><b>EraseAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(List&nbsp;*list,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list the element at the given position.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred or a positive value that indicates that the element was removed.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.EraseAt(list,2);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Element&nbsp;at&nbsp;position&nbsp;2&nbsp;erased\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error&nbsp;code&nbsp;%d\n",r);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="EraseRange+\container11"></a> <font size="+1"><b>EraseRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;int&nbsp;(*EraseRange)(List&nbsp;*L,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list the given range, starting with the <font size="+1"><tt>start</tt></font> index, until the element before the <font size="+1"><tt>end</tt></font> index. If <font size="+1"><tt>end</tt></font>
is greater than the length of the list, it will be 'rounded' to the length of the list.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number indicates success, zero means nothing was erased, and a negative number an error.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;print_list(List&nbsp;*li)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(li);&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;%d",*(int&nbsp;*)iList.GetElement(li,i));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*li&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(li,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;print_list(li);
&nbsp;&nbsp;&nbsp;&nbsp;iList.EraseRange(li,3,8);
&nbsp;&nbsp;&nbsp;&nbsp;print_list(li);
}
OUTPUT:
&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9
&nbsp;0&nbsp;1&nbsp;2&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container11"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the list, including the list header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed. A negative error code indicates failure.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.Finalize(list);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="FirstElement+\container11"></a> <font size="+1"><b>FirstElement</b></font> <hr />


<font size=+1><pre>

ListElement&nbsp;*(*FirstElement)(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Finds the first element of the list and returns a pointer to it. This is a pointer to the element, <b>not</b> to the data stored at that element.
It is an error to attempt to use this function with a read-only list. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the element or&nbsp;NULL if the list is empty or an error occurs. 

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container11"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

const&nbsp;void&nbsp;*(*Front)(const&nbsp;List&nbsp;*l);
TYPE&nbsp;*(*Front)(const&nbsp;TYPEList&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the first element of the given list or &nbsp;NULL if the list is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified. The resulting pointer is read-only.

<div class="p"><!----></div>
<b>Returns:</b>
The first element or &nbsp;NULL if the list is empty or an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetAllocator+\container11"></a> <font size="+1"><b>GetAllocator</b></font> <hr />


<font size=+1><pre>

ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the list's allocator object. If the list pointer is &nbsp;NULL it returns &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="GetElementSize+\container11"></a> <font size="+1"><b>GetElementSize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the size of the elements stored in the given list. Note that this value can be different than the value given to the creation function because of alignment requirements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
The element size.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

List&nbsp;*l;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iList.GetElementSize(l);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetElement+\container11"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*(*GetElement)(const&nbsp;List&nbsp;*list,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;TYPE&nbsp;*(*GetElement)(const&nbsp;TYPEList&nbsp;*list,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a read only pointer to the element at the given index, or &nbsp;NULL if the operation failed.  This function will return &nbsp;NULL if the list is read only.

<div class="p"><!----></div>
Use the CopyElement function to get a read/write copy of an element of the list.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified. The resulting pointer is read-only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;doubleList&nbsp;*dlist;
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;*(double&nbsp;*)iList.GetElement(list,3);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;idoubleList.GetElement(dlist,3);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetFlags / SetFlags+\container11"></a> <font size="+1"><b>GetFlags / SetFlags</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(List&nbsp;*l,unsigned&nbsp;newFlags);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
GetFlags returns the state of the container flags, SetFlags sets the flags to a new value and returns the old value.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
The flags or zero if there was an error.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetRange+\container11"></a> <font size="+1"><b>GetRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*GetRange)(const&nbsp;List&nbsp;*list,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;*(*GetRange)(const&nbsp;TYPEList&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Selects a series of consecutive elements starting at position start and ending at position end.  Both the elements at start and end are included in the result.
If start is greater than end start and end are interchanged. If end is bigger than the number of elements in list, only elements up to the number of elements will be used. If both start and end are out of range an error is issued and &nbsp;NULL is returned.
The selected elements are copied into a new list. 


<div class="p"><!----></div>
 <b>Invariants:</b>
The original list remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL 

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 Both start and end are out of range.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new list containing the selected elements or &nbsp;NULL if an error occurs.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*range&nbsp;=&nbsp;iList.GetRange(list,2,5);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(range&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="IndexOf+\container11"></a> <font size="+1"><b>IndexOf</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*IndexOf)(const&nbsp;List&nbsp;*l,const&nbsp;void&nbsp;*ElementToFind,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*args,size_t&nbsp;*result);
int&nbsp;(*IndexOf)(const&nbsp;TYPEList&nbsp;*l,const&nbsp;TYPE&nbsp;ElementToFind,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*args,size_t&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches for an element in the list. If found its zero based index is returned in the passed pointer "result". 

<div class="p"><!----></div>
Otherwise the result of the search is  
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
and the passed pointer will remain unmodified. The <font size="+1"><tt>args</tt></font> argument will be passed to the comparison function that is called by IndexOf.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer or element are &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list and the data to be searched are not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if element is found or a negative value if not found or an error occurs.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.IndexOf(list,&amp;data,&amp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;CONTAINER_ERROR_NOTFOUND)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Not&nbsp;found\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;printf("Found&nbsp;at&nbsp;position&nbsp;%ld\n",idx);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Init+\container11"></a> <font size="+1"><b>Init</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*Init)(List&nbsp;*aList,size_t&nbsp;element_size);
TYPEList&nbsp;*(*Init)(TYPEList&nbsp;*aList);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the memory pointed by the <font size="+1"><tt>aList</tt></font> argument. The new list will use the allocator pointed by the current memory allocator.
It is assumed that the memory pointed by <font size="+1"><tt>aList</tt></font> contains at least the size of the header object. This size can be obtained by calling the Sizeof function with a &nbsp;NULL argument.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

//&nbsp;This&nbsp;example&nbsp;uses&nbsp;C99
void&nbsp;Example(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;aList[iList.Sizeof(NULL)];
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list&nbsp;=&nbsp;iList.Init((List&nbsp;*)aList);
&nbsp;&nbsp;&nbsp;&nbsp;doubleList&nbsp;*l&nbsp;=&nbsp;idoubleList.Init((TYPEList&nbsp;*)aList);
}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="InitializeWith+\container11"></a> <font size="+1"><b>InitializeWith</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,&nbsp;size_t&nbsp;n,const&nbsp;void&nbsp;*Data);
//&nbsp;Template&nbsp;file&nbsp;version
TYPEList&nbsp;*(*InitializeWith)(size_t&nbsp;n,const&nbsp;TYPE&nbsp;*Data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Construct a new list from the given data. It is assumed that
<font size="+1"><tt><i>Data</i></tt></font>
 points to a memory area that contains at least
<font size="+1"><tt><i>n</i></tt></font>
 items 
of
<font size="+1"><tt><i>elementSize</i></tt></font>
 bytes each.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The Data argument is &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input data is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The new list or &nbsp;NULL if an error occurs

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="InitWithAllocator+\container11"></a> <font size="+1"><b>InitWithAllocator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*InitWithAllocator)(List&nbsp;*aList,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;element_size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;&nbsp;TYPEList&nbsp;*(*InitWithAllocator)(TYPEList&nbsp;*aList,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the memory pointed by the <font size="+1"><tt>aList</tt></font> argument. The new list will use the given allocator.
It is assumed that the memory pointed by <font size="+1"><tt>aList</tt></font> contains at least the size of the header object. This size can be obtained by calling the Sizeof function with a &nbsp;NULL argument.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The given allocator is not modified.
 
<div class="p"><!----></div>
<br /><a 
name="InsertAt+\container11"></a> <font size="+1"><b>InsertAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(List&nbsp;*L,size_t&nbsp;idx,const&nbsp;void&nbsp;*newData);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(TYPEList&nbsp;*L,size_t&nbsp;idx,const&nbsp;TYPE&nbsp;newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the new element. The new element will have the given index, that can go from zero to the list count inclusive, i.e. one more than the number of elements in the list. In single linked lists the cost for this operation is proportional to idx.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer or the element given are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.


<div class="p"><!----></div>
 <b>Invariants:</b>
The data is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

1&nbsp;#include&nbsp;"containers.h"
&nbsp;&nbsp;2&nbsp;static&nbsp;int&nbsp;PrintInt(void&nbsp;*pdata,void&nbsp;*extraArgs)
&nbsp;&nbsp;3&nbsp;{
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;*(int&nbsp;*)pdata;
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(extraArgs,"%d&nbsp;",i);
&nbsp;&nbsp;6&nbsp;}
&nbsp;&nbsp;7&nbsp;int&nbsp;main(void)
&nbsp;&nbsp;8&nbsp;{
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data;
&nbsp;11&nbsp;
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;0;
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(L,&amp;data);
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.PushFront(L,&amp;data);
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;2;
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.InsertAt(L,1,&amp;data);&nbsp;
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;5;
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(L,&amp;data);
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;6;
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(L,&amp;data);
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Apply(L,PrintInt,stdout);
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(L);
&nbsp;24&nbsp;}
OUTPUT:&nbsp;0&nbsp;2&nbsp;0&nbsp;5&nbsp;6

&nbsp;&nbsp;1&nbsp;#include&nbsp;"containers.h"
&nbsp;&nbsp;2&nbsp;#include&nbsp;"intlist.h"
&nbsp;&nbsp;3&nbsp;static&nbsp;int&nbsp;PrintInt(int&nbsp;data,void&nbsp;*extraArgs)
&nbsp;&nbsp;4&nbsp;{&nbsp;&nbsp;
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(extraArgs,"%d&nbsp;",data);
&nbsp;&nbsp;6&nbsp;}
&nbsp;&nbsp;7&nbsp;int&nbsp;main(void)
&nbsp;&nbsp;8&nbsp;{
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intList&nbsp;*L;
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data;
&nbsp;11&nbsp;
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;iintList.Create();
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iintList.Add(L,0);
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iintList.PushFront(L,0);
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iintList.InsertAt(L,1,2);&nbsp;
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iintList.Add(L,5);
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iintList.Add(L,6);
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iintList.Apply(L,PrintInt,stdout);
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iintList.Finalize(L);
&nbsp;24&nbsp;}
OUTPUT:&nbsp;0&nbsp;2&nbsp;0&nbsp;5&nbsp;6


</pre></font>
We create a list of integers at line 12. We add zero to it, then again a zero at the first position. 
Our list now is just <font size="+1"><tt>0&nbsp;0</tt></font>. We insert at the
position 1 the value 2 in line 17. Then we add some data at the end. To print the list we use <font size="+1"><tt>Apply</tt></font> with a function that receives the
file where the data should be printed in the <font size="+1"><tt>ExtraArgs</tt></font> parameter. 
 
<div class="p"><!----></div>
<br /><a 
name="InsertIn+\container11"></a> <font size="+1"><b>InsertIn</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(List&nbsp;*Destination,&nbsp;size_t&nbsp;position,&nbsp;List&nbsp;*source);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the list given in  its third argument at the given position in the list pointed to by its first argument. The data is copied, and the source argument is not modified in any way. Both lists must have elements of the same type. The library only tests the size of each one.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The source or the destination lists are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The destination list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The lists store elements of different size.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
/*&nbsp;Prints&nbsp;the&nbsp;contents&nbsp;of&nbsp;a&nbsp;list&nbsp;*/
static&nbsp;void&nbsp;PrintList(List&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Count&nbsp;%ld\n",(long)iList.Size(AL));
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*(double&nbsp;*)iList.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
/*&nbsp;Fills&nbsp;a&nbsp;list&nbsp;with&nbsp;10&nbsp;numbers.&nbsp;The&nbsp;10&nbsp;is&nbsp;hardwired...&nbsp;*/
static&nbsp;void&nbsp;FillList(List&nbsp;*&nbsp;AL,int&nbsp;start)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;i+start;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
/*&nbsp;Creates&nbsp;two&nbsp;lists:&nbsp;one&nbsp;with&nbsp;the&nbsp;numbers&nbsp;from&nbsp;0&nbsp;to&nbsp;9,&nbsp;another&nbsp;
&nbsp;&nbsp;&nbsp;with&nbsp;numbers&nbsp;100&nbsp;to&nbsp;109,&nbsp;then&nbsp;inserts&nbsp;the&nbsp;second&nbsp;into&nbsp;the&nbsp;
&nbsp;&nbsp;&nbsp;first&nbsp;at&nbsp;position&nbsp;5&nbsp;*/
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*AL&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*AL1&nbsp;=iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;FillList(AL,0);
&nbsp;&nbsp;&nbsp;&nbsp;FillList(AL1,100);
&nbsp;&nbsp;&nbsp;&nbsp;iList.InsertIn(AL,5,AL1);
&nbsp;&nbsp;&nbsp;&nbsp;PrintList(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Count&nbsp;20
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;100&nbsp;101&nbsp;102&nbsp;103&nbsp;104&nbsp;105&nbsp;106&nbsp;107&nbsp;108&nbsp;109&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="LastElement+\container11"></a> <font size="+1"><b>LastElement</b></font> <hr />


<font size=+1><pre>

ListElement&nbsp;*(*LastElement)(List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the last element stored in the given list or&nbsp;NULL if the list is empty or an error occurs. It is an error to call this
function in a read-only list.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>The last element or&nbsp;NULL 
 
<div class="p"><!----></div>
<br /><a 
name="Load+\container11"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads a list previously saved with the Save function from the stream pointed to by stream. If readFn is not &nbsp;NULL , it will be used to read each element. The <font size="+1"><tt>arg</tt></font> argument will be passed to the read function. If the read function is &nbsp;NULL , this argument is ignored and a default read function is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A new list or &nbsp;NULL if the operation could not be completed. Note that the function pointers in the list are NOT saved, nor any special allocator that was in the original list. Those values will be the values by default. To rebuild the original state the user should replace the pointers again with the new list.
 
<div class="p"><!----></div>
<br /><a 
name="NewIterator+\container11"></a> <font size="+1"><b>NewIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates and initializes a new iterator object to iterate this list.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 No more memory is available.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new iterator or &nbsp;NULL if there is no more memory left.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iList.NewIterator(list);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(d=it-&#62;GetFirst(it);&nbsp;d&nbsp;!=&nbsp;NULL;&nbsp;d&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;val&nbsp;=&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;the&nbsp;value&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iList.DeleteIterator(it);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="NextElement+\container11"></a> <font size="+1"><b>NextElement</b></font> <hr />


<font size=+1><pre>

DlistElement&nbsp;*(*NextElement)(DlistElement&nbsp;*le);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the next element in the list. If the input list is&nbsp;NULL it returns&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>The next element or&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="PopFront+\container11"></a> <font size="+1"><b>PopFront</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*PopFront)(List&nbsp;*L,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Pops the element at position zero copying it to the result pointer. If the "result" pointer is &nbsp;NULL , the first element is removed without any copying. The library supposes that result points to at least ElementSize bytes of contiguous storage. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the result pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if an element was popped, zero if the list was empty, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.PopFront(L,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("List&nbsp;empty\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error&nbsp;%d\n",r);
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;printf("OK,&nbsp;popped&nbsp;value&nbsp;%g\n",d);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="PushFront+\container11"></a> <font size="+1"><b>PushFront</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(List&nbsp;*L,void&nbsp;*element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the given element at position zero. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the element pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iList.PushFront(list,&amp;d)&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error\n");

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="RemoveRange+\container11"></a> <font size="+1"><b>RemoveRange</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*RemoveRange)(List&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes all elements having an index equal or greater than
<font size="+1"><tt><i>start</i></tt></font>
 and less than
<font size="+1"><tt><i>end</i></tt></font>
. If
<font size="+1"><tt><i>end</i></tt></font>
 is greater than the number of elements 
in the collection it will be adjusted to one more than the number of elements. If
<font size="+1"><tt><i>start</i></tt></font>
 is bigger than
<font size="+1"><tt><i>end</i></tt></font>
 the range is still valid and
starts with the value of
<font size="+1"><tt><i>end</i></tt></font>
 and ends with the value of
<font size="+1"><tt><i>start</i></tt></font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
Zero if no elements were removed. Otherwise returns a positive number for success, a negative error code in case of an error.
 
<div class="p"><!----></div>
<br /><a 
name="ReplaceAt+\container11"></a> <font size="+1"><b>ReplaceAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(List&nbsp;*list,size_t&nbsp;idx,const&nbsp;void&nbsp;*newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the list element at position idx with the new data starting at the position pointed to by "newData" and extending ElementSize bytes.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the new element pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input data is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;6.7;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.ReplaceAt(list,2,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Reverse+\container11"></a> <font size="+1"><b>Reverse</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reverses the order of the given list: the head becomes the tail and the tail becomes the head. The original order is lost.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;print_list(List&nbsp;*li)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(li);&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;%d",*(int&nbsp;*)iList.GetElement(li,i));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*li&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(li,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;print_list(li);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Reverse(li);
&nbsp;&nbsp;&nbsp;&nbsp;print_list(li);
}
OUTPUT
&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9
&nbsp;9&nbsp;8&nbsp;7&nbsp;6&nbsp;5&nbsp;4&nbsp;3&nbsp;2&nbsp;1&nbsp;0

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="RotateRight+\container11"></a> <font size="+1"><b>RotateRight</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(List&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates right the list by the indicated amount. The last n elements will be written to the start of
the array, and the rest will be shifted right.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size).

<div class="p"><!----></div>
 
<br /><a 
name="RotateLeft+\container11"></a> <font size="+1"><b>RotateLeft</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(List&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates left the list by the indicated amount. The first n elements will be written to the end of
the list, and the rest will be shifted left to fill the empty n places.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size), or an error code less than zero if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Save+\container11"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;List&nbsp;*l,&nbsp;FILE&nbsp;*stream,SaveFunction&nbsp;SaveFn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given list are saved into the given stream. If the save function pointer is not &nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save. Otherwise a default save function will be used and arg will be ignored.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer or the stream pointer are &nbsp;NULL .
EOF A disk input/output error occurred.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Select+\container11"></a> <font size="+1"><b>Select</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Select)(List&nbsp;*l,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Uses the given mask to select elements from the given list. The list is modified: all elements that have a corresponding value of zero in the mask are 
erased from the list. The length of the mask should be equal to the length of the list. If there is a destructor set up for the list, it is called for 
all the elements that are eliminated.


<div class="p"><!----></div>
 <b>Invariants:</b>
The mask is not modified.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the mask are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The mask and the list have different lengths.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value for success, a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
static&nbsp;void&nbsp;printList(List&nbsp;*v)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,*pi;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(v);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;iList.GetElement(v,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2d&nbsp;",*pi);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*&nbsp;vInt&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=1;i&lt;=24;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(vInt,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;iMask.Create(24);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;list:&nbsp;\n");
&nbsp;&nbsp;&nbsp;&nbsp;printList(vInt);

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;i&lt;24;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMask.Set(m,i,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2d&nbsp;",i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\nSelect&nbsp;of&nbsp;the&nbsp;list:\n");

&nbsp;&nbsp;&nbsp;&nbsp;iList.Select(vInt,m);
&nbsp;&nbsp;&nbsp;&nbsp;printList(vInt);

&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(vInt);
&nbsp;&nbsp;&nbsp;&nbsp;iMask.Finalize(m);
}
OUTPUT:
Original&nbsp;list:&nbsp;
&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;24&nbsp;
&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;
Select&nbsp;of&nbsp;the&nbsp;list:
&nbsp;2&nbsp;&nbsp;4&nbsp;&nbsp;6&nbsp;&nbsp;8&nbsp;10&nbsp;12&nbsp;14&nbsp;16&nbsp;18&nbsp;20&nbsp;22&nbsp;24&nbsp;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SelectCopy+\container11"></a> <font size="+1"><b>SelectCopy</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*SelectCopy)(const&nbsp;List&nbsp;*l,const&nbsp;Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Uses the given mask to select elements from the given list. The list is not modified: all elements that have a corresponding value different of zero
in the mask are copied to the new list. The length of the mask should be equal to the length of the list.


<div class="p"><!----></div>
 <b>Invariants:</b>
Neither the input list nor the mask are modified.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the mask are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The mask and the list have different lengths.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Insufficient resources to create the result list.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new list or &nbsp;NULL if there was an error.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
static&nbsp;void&nbsp;printList(List&nbsp;*v)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,*pi;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(v);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;iList.GetElement(v,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2d&nbsp;",*pi);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*&nbsp;vInt&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*copy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=1;i&lt;=24;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(vInt,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;iMask.Create(24);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;list:&nbsp;\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printList(vInt);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;i&lt;24;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMask.Set(m,i,!(i&amp;1));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2d&nbsp;",!(i&amp;1));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\nSelect&nbsp;of&nbsp;the&nbsp;list:\n");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy&nbsp;=&nbsp;iList.SelectCopy(vInt,m);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printList(copy);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(vInt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(copy);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMask.Finalize(m);
}
OUTPUT
Original&nbsp;list:&nbsp;
&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;24&nbsp;
&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;
Select&nbsp;of&nbsp;the&nbsp;list:
&nbsp;1&nbsp;&nbsp;3&nbsp;&nbsp;5&nbsp;&nbsp;7&nbsp;&nbsp;9&nbsp;11&nbsp;13&nbsp;15&nbsp;17&nbsp;19&nbsp;21&nbsp;23&nbsp;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SetCompareFunction+\container11"></a> <font size="+1"><b>SetCompareFunction</b></font> <hr />


<font size=+1><pre>

CompareFunction&nbsp;(*SetCompareFunction)(List&nbsp;l,CompareFunction&nbsp;f);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
if the f argument is non &nbsp;NULL , it sets the list comparison function to f.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only and the function argument is not &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the comparison function.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

ErrorFunction&nbsp;fn,newfn;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;iList.SetCompareFunction(list,newfn);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SetDestructor+\container11"></a> <font size="+1"><b>SetDestructor</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;SetDestructor(List&nbsp;*l,DestructorFunction&nbsp;fn);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Sets the destructor function to its given argument. If the function argument is &nbsp;NULL nothing is changed and the call is interpreted as a query since the return value is the current value of the destructor function. If the list argument is &nbsp;NULL , the result is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the destructor.
 
<div class="p"><!----></div>
<br /><a 
name="SetElementData+\container11"></a> <font size="+1"><b>SetElementData</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SetElementData)(List&nbsp;*l,&nbsp;ListElement&nbsp;*le,void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies <font size="+1"><tt>ElementSize</tt></font> bytes from its parameter <font size="+1"><tt>data</tt></font> into the given list element. The list is modified even if all pointers into it could 
remain valid. Any iterators into the list will stop working.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any argument is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the error function, or &nbsp;NULL if there is an error.
 
<div class="p"><!----></div>
<br /><a 
name="SetErrorFunction+\container11"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(List&nbsp;*L,ErrorFunction);&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current error function  for the given list with the new error function if the
<font size="+1"><tt><i>ErrorFunction</i></tt></font>
parameter is different from &nbsp;NULL . If 
the
<font size="+1"><tt><i>List</i></tt></font>
parameter is &nbsp;NULL the function returns the value of the current default error function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only and the function argument is not &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the error function, or &nbsp;NULL if there is an error.
 
<div class="p"><!----></div>
<br /><a 
name="Size+\container11"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the list.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
If the given list pointer is &nbsp;NULL , it returns  SIZE_MAX.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*li;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;bytes&nbsp;=&nbsp;iList.Size(li);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Sizeof+\container11"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the list, including the header, and all data stored in the list. If <font size="+1"><tt>list</tt></font> is &nbsp;NULL , the result is the size of the <font size="+1"><tt>List</tt></font> structure.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the list or the size of the empty List container if the argument is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*l&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(l,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Queries&nbsp;for&nbsp;size&nbsp;of&nbsp;the&nbsp;list&nbsp;and&nbsp;for&nbsp;size&nbsp;of&nbsp;the&nbsp;list&nbsp;header
&nbsp;&nbsp;&nbsp;&nbsp;printf("Size&nbsp;of&nbsp;list:&nbsp;%lu,&nbsp;sizeof&nbsp;list&nbsp;header&nbsp;%lu\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Sizeof(l),iList.Sizeof(NULL));
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Prints&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;data&nbsp;(int)&nbsp;and&nbsp;the&nbsp;size&nbsp;of&nbsp;a&nbsp;pointer
&nbsp;&nbsp;&nbsp;&nbsp;printf("Sizeof&nbsp;int&nbsp;%lu,&nbsp;sizeof&nbsp;void&nbsp;*&nbsp;%lu\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(int),sizeof(void&nbsp;*));
&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(l);
}

OUTPUT&nbsp;(64&nbsp;bit&nbsp;system)
Size&nbsp;of&nbsp;list:&nbsp;208,&nbsp;sizeof&nbsp;list&nbsp;header&nbsp;88
Sizeof&nbsp;int&nbsp;4,&nbsp;sizeof&nbsp;void&nbsp;*&nbsp;8

</pre></font>

<div class="p"><!----></div>
208&#8722;88 is 120. There are 10 elements, so each element is 12 bytes: 8 for a pointer and 4 for an integer<a href="#tthFtNtADJ" name="tthFrefADJ"><sup>39</sup></a>.
 
<div class="p"><!----></div>
<br /><a 
name="SizeofIterator+\container11"></a> <font size="+1"><b>SizeofIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the list iterator.  

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the list iterator.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;siz&nbsp;=&nbsp;iList.Sizeof(list);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Sort+\container11"></a> <font size="+1"><b>Sort</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sorts the given list using the list comparison function. The order of the original list is destroyed. You should copy it if you want to preserve it. 

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if sorting succeeded, a negative error code if not.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iList.Sort(list)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SplitAfter+\container11"></a> <font size="+1"><b>SplitAfter</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*SplitAfter)(List&nbsp;*list,&nbsp;ListElement&nbsp;*point);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Splits the source lost at the given element. This element <b>must</b> be an element of the source list. Checking that this is actually
the case is very expensive and probably will be skipped in most implementations. An error here will have very serious consequences for
the integrity of the system.

<div class="p"><!----></div>
<font size="+1"><tt>SplitAfter</tt></font> builds a new list with all the elements after the given element that becomes the last element of the source list.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer or the element are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The source list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There aren't enough resources to create a new list.

<div class="p"><!----></div>
<b>Returns:</b><br />
A pointer to the newly created list or &nbsp;NULL if an error occurs or the given list element is the last element of the list.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
/*&nbsp;This&nbsp;example&nbsp;creates&nbsp;a&nbsp;list&nbsp;of&nbsp;16&nbsp;double&nbsp;precision&nbsp;numbers
&nbsp;&nbsp;&nbsp;and&nbsp;splits&nbsp;it&nbsp;after&nbsp;element&nbsp;4.&nbsp;It&nbsp;prints&nbsp;the&nbsp;lists&nbsp;before&nbsp;and&nbsp;after
&nbsp;&nbsp;&nbsp;the&nbsp;split,&nbsp;then&nbsp;exits
*/
static&nbsp;void&nbsp;Fprintf(List&nbsp;*v)&nbsp;//&nbsp;Prints&nbsp;a&nbsp;list&nbsp;of&nbsp;doubles
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*pi;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(v);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;iList.GetElement(v,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*pi);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*l,*newList;
&nbsp;&nbsp;&nbsp;&nbsp;ListElement&nbsp;*le;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d;

&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;16;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(l,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;+=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;list:\n");
&nbsp;&nbsp;&nbsp;&nbsp;Fprintf(l);
&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;iList.FirstElement(l);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;4;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;iList.NextElement(le);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Element&nbsp;%g&nbsp;is&nbsp;at&nbsp;the&nbsp;split\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(double&nbsp;*)iList.GetElementData(le));
&nbsp;&nbsp;&nbsp;&nbsp;newList&nbsp;=&nbsp;iList.SplitAfter(l,le);
&nbsp;&nbsp;&nbsp;&nbsp;printf("New&nbsp;list:\n");
&nbsp;&nbsp;&nbsp;&nbsp;Fprintf(newList);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Source&nbsp;list\n");
&nbsp;&nbsp;&nbsp;&nbsp;Fprintf(l);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(l);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(newList);
}

OUTPUT:
Original&nbsp;list:
1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;
Element&nbsp;5&nbsp;is&nbsp;at&nbsp;the&nbsp;split
New&nbsp;list:
6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;
Source&nbsp;list
1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;

</pre></font>                         
 
<div class="p"><!----></div>
<br /><a 
name="UseHeap+\container11"></a> <font size="+1"><b>UseHeap</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*UseHeap)(List&nbsp;*list,ContainerAllocator&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds a heap manager to the given list, that should be empty. The heap manager will manage the free list and the allocation of new objects. Use this 
function when the list will hold a great number of elements. This function is optional and may not be present in all implementations.
If m is &nbsp;NULL , the current memory manager object will be used for allocating and reclaiming memory. Otherwise m should be a memory manager object.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOT_EMPTY

 The list is not empty or has already a heap.

<div class="p"><!----></div>
Portability:
This function is optional and may not be present in all implementations.

     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Specializations of linked lists</h3>
The sample implementation proposes a <font size="+1"><tt>stringlist</tt></font> container that can hold a list of strings. Its interface functions and all its vocabulary
are identical to the linked list one. This is a recommended extension but may not be present in all implementations of the library.

<div class="p"><!----></div>
It comes in two flavors:

<ul>
<li> Single byte character strings. The name of the interface is <font size="+1"><tt>iStringList</tt></font>.
<div class="p"><!----></div>
</li>

<li> Wide character strings. The name of the interface is <font size="+1"><tt>iWStringList</tt></font>.
<div class="p"><!----></div>
</li>
</ul>
In this specialization the function <font size="+1"><tt>GetElementSize</tt></font> returns always zero since it has no meaning in a list composed of strings of different
length.<a href="#tthFtNtAEA" name="tthFrefAEA"><sup>40</sup></a>

<div class="p"><!----></div>
The function <font size="+1"><tt>Sizeof</tt></font> that is very fast in normal lists (the element size is known), it is very expensive in string lists since all
the list needs to be scanned to add up the contents of each string.<a href="#tthFtNtAEB" name="tthFrefAEB"><sup>41</sup></a>

<div class="p"><!----></div>
Another difference is that the function <font size="+1"><tt>Save</tt></font> and the function <font size="+1"><tt>Load</tt></font> do not use the user function argument since they are specialized
to load and save character strings. The function argument can have any value. It has been maintained for compatibility with the rest of the software.

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Double linked lists: iDlist</h2>
<a 
name="Dlist20"></a>
<div class="p"><!----></div>
<img src="DListVocabulary.png" alt="Figure">

<div class="p"><!----></div>
 Differences with the list vocabulary are marked in bold.<BR CLEAR=LEFT><BR><BR>
<a 
name="lists+double linked20"></a>
<div class="p"><!----></div>
Double linked lists have a pair of pointers pointing to the next and to the previous element in the list. It is easy then, to move in  either direction through the list. The price to pay is a higher overhead for each element.
This container shares most of its interface with the single linked list container.  Here we document the functions that aren't already described for the list container.
<a 
name="iDlist20"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagDlistInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Dlist&nbsp;*dl,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(Dlist&nbsp;*l,size_t&nbsp;n,const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Advance)(DlistElement&nbsp;**pDlistElement);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(Dlist&nbsp;*l1,Dlist&nbsp;*l2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Dlist&nbsp;*L,int(Applyfn)(void&nbsp;*elem,void&nbsp;*extraArg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Back)(const&nbsp;Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;Dlist&nbsp;*dl,const&nbsp;void&nbsp;*element);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Copy)(const&nbsp;Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;Dlist&nbsp;*l,size_t&nbsp;idx,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Create)(size_t&nbsp;elementsize);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*CreateWithAllocator)(size_t,const&nbsp;ContainerAllocator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;Dlist&nbsp;*l1,const&nbsp;Dlist&nbsp;*l2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Dlist&nbsp;*AL,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(Dlist&nbsp;*AL,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(Dlist&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Dlist&nbsp;*AL);
&nbsp;&nbsp;&nbsp;DlistElement&nbsp;*(*FirstElement)(Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Front)(const&nbsp;Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;Dlist&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElementData)(DlistElement&nbsp;*le);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;Dlist&nbsp;*AL);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*GetRange)(Dlist&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(const&nbsp;Dlist&nbsp;*AL,const&nbsp;void&nbsp;*SearchedElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*args,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Init)(Dlist&nbsp;*dlist,size_t&nbsp;elementsize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(Dlist&nbsp;*,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*InitWithAllocator)(Dlist&nbsp;*L,size_t&nbsp;element_size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,&nbsp;size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(Dlist&nbsp;*AL,size_t&nbsp;idx,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(Dlist&nbsp;*l,&nbsp;size_t&nbsp;idx,Dlist&nbsp;*newData);
&nbsp;&nbsp;&nbsp;DlistElement&nbsp;*(*LastElement)(Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;loadFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*MoveBack)(DlistElement&nbsp;**pDlistElement);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Dlist&nbsp;*);
&nbsp;&nbsp;&nbsp;DlistElement&nbsp;*(*NextElement)(DlistElement&nbsp;*le);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Dlist&nbsp;*AL,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(Dlist&nbsp;*AL,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;DlistElement&nbsp;*(*PreviousElement)(DlistElement&nbsp;*le);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(Dlist&nbsp;*AL,const&nbsp;void&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(Dlist&nbsp;*AL,const&nbsp;void&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(Dlist&nbsp;*l,size_t&nbsp;start,&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(Dlist&nbsp;*AL,size_t&nbsp;idx,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(Dlist&nbsp;*l,&nbsp;size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(Dlist&nbsp;*l,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;Dlist&nbsp;*L,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(Dlist&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*SelectCopy)(const&nbsp;Dlist&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(Dlist&nbsp;*l,CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(Dlist&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetElementData)(Dlist&nbsp;*l,&nbsp;DlistElement&nbsp;*le,void&nbsp;*data);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Dlist&nbsp;*L,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Dlist&nbsp;*AL,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;Dlist&nbsp;*);
&nbsp;&nbsp;&nbsp;DlistElement&nbsp;*(*Skip)(DlistElement&nbsp;*l,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Splice)(Dlist&nbsp;*list,void&nbsp;*pos,Dlist&nbsp;*toInsert,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;direction);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*SplitAfter)(Dlist&nbsp;*l,&nbsp;DlistElement&nbsp;*pt);
&nbsp;&nbsp;&nbsp;int&nbsp;(*UseHeap)(Dlist&nbsp;*L,const&nbsp;ContainerAllocator&nbsp;*m);
}&nbsp;DlistInterface;

</pre></font>

 
<div class="p"><!----></div>
<br /><a 
name="MoveBack+\container20"></a> <font size="+1"><b>MoveBack</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*MoveBack)(ListElement&nbsp;**ppElement);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Given the address of a pointer to an element, it returns a pointer to the data stored into that element and writes the address of the previous element
into its argument <font size="+1"><tt>ppElement</tt></font>. If ppElement is&nbsp;NULL it returns&nbsp;NULL . If <font size="+1"><tt>*ppElement</tt></font> is&nbsp;NULL it also returns&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the data stored in the given element or&nbsp;NULL if the data can't be retrieved.
 
<div class="p"><!----></div>
<br /><a 
name="PopBack+\container20"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(List&nbsp;*L,void&nbsp;*result);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Pops the element at the last position copying it to the result pointer. If the "result" pointer is &nbsp;NULL , the last element is removed without any 
copying. Otherwise, the library supposes that result points to at least ElementSize bytes of contiguous storage. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the result pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if an element was popped, zero if the list was empty, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.PopBack(L,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("List&nbsp;empty\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error&nbsp;%d\n",r);
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;printf("OK,&nbsp;popped&nbsp;value&nbsp;%g\n",d);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="PreviousElement+\container20"></a> <font size="+1"><b>PreviousElement</b></font> <hr />


<font size=+1><pre>

DlistElement&nbsp;*(*PreviousElement)(DlistElement&nbsp;*le);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the previous element in the list. If the input list is&nbsp;NULL it returns&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>The previous element or&nbsp;NULL .

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="PushBack+\container20"></a> <font size="+1"><b>PushBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(List&nbsp;*L,void&nbsp;*element);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the given element at the last position of the list. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the element pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iList.PushBack(list,&amp;d)&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error\n");

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Splice+\container20"></a> <font size="+1"><b>Splice</b></font> <hr />


<font size=+1><pre>

Synopsis:
Dlist&nbsp;*(*Splice)(Dlist&nbsp;*list,&nbsp;void&nbsp;*Pos,&nbsp;Dlist&nbsp;*toInsert,int&nbsp;direction);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts a list (parameter "toInsert") into another one (parameter "list") at the given position
that should be an element of "list". The direction argument means to insert before the position if zero, after the position if not zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list, the list to be inserted or the element pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;The Vector interface: iVector</h2>
<a 
name="iVector30"></a>
The "vector" container is an array that resizes to accommodate new elements. Access is always checked against the array bounds.
Insertion and deletion of items are more expensive than in lists, and the cost increases linearly with the array size. Access is very cheap, since a 
multiplication suffices to get to any array position.

<div class="p"><!----></div>
Most functions of the interface are shared with the list, Dlist and the other sequential containers.

<div class="p"><!----></div>
      <h4><a name="tth_sEc3.0.1">
3.0.1</a>&nbsp;&nbsp;Special arrays using a modified error function</h4><a 
name="Infinite arrays30"></a>
Some functions of the iVector interface will examine the return value of the error function after an index error is detected. If the error function 
returns a pointer value different than &nbsp;NULL , it will be assumed that that is the value of the API that should be returned to the user. This allows
for the implementation of infinite arrays or arrays where an access into some element beyond the end of the array provokes an automatic 
resize operation of the array up to the required length.

<div class="p"><!----></div>
In case of an index error, this container passes always a pointer to the container and the out of range index to the error function. The functions
where the return value of the error function is used are:


<ul>
<li> CopyElement. If the return value is not &nbsp;NULL the returned pointer is used to copy into the result buffer.
<div class="p"><!----></div>
</li>

<li> GetElement. If the return pointer is not &nbsp;NULL the pointer is the result of the function.
<div class="p"><!----></div>
</li>

<li> InsertAt. If the return pointer is not &nbsp;NULL , the vector is resized up to the index that is required.

<div class="p"><!----></div>
</li>
</ul>


     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;The interface</h3>
<a 
name="iVector31"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagVectorInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Vector&nbsp;*AL,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(Vector&nbsp;*AL,size_t&nbsp;n,const&nbsp;void&nbsp;*newvalues);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(Vector&nbsp;*AL1,&nbsp;Vector&nbsp;*AL2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Vector&nbsp;*AL,int&nbsp;(*Applyfn)(void&nbsp;*element,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Back)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqual)(const&nbsp;Vector&nbsp;*left,const&nbsp;Vector&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqualScalar)(const&nbsp;Vector&nbsp;*left,&nbsp;const&nbsp;void&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;Vector&nbsp;*AL,const&nbsp;void&nbsp;*element,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Copy)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;void&nbsp;**(*CopyTo)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Create)(size_t&nbsp;elementsize,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elemsiz,size_t&nbsp;startsiz,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;Vector&nbsp;*first,const&nbsp;Vector&nbsp;*second);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Vector&nbsp;*AL,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(Vector&nbsp;*AL,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(Vector&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Front)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;void&nbsp;**(*GetData)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;Vector&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*GetRange)(const&nbsp;Vector&nbsp;*AL,&nbsp;size_t&nbsp;start,&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*IndexIn)(Vector&nbsp;*SC,Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(const&nbsp;Vector&nbsp;*AL,const&nbsp;void&nbsp;*data,void&nbsp;*ExtraArgs,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Init)(Vector&nbsp;*r,size_t&nbsp;elementsize,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(Vector&nbsp;*V,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,&nbsp;size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(Vector&nbsp;*AL,void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(Vector&nbsp;*AL,&nbsp;size_t&nbsp;idx,Vector&nbsp;*newData);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Mismatch)(Vector&nbsp;*a1,Vector&nbsp;*a2,size_t&nbsp;*mismatch);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Vector&nbsp;*AL,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(Vector&nbsp;*AL,const&nbsp;void&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(Vector&nbsp;*SC,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reserve)(Vector&nbsp;*src,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(Vector&nbsp;*AL,size_t&nbsp;newSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(Vector&nbsp;*V,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(Vector&nbsp;*V,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;Vector&nbsp;*AL,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SearchWithKey)(Vector&nbsp;*vec,size_t&nbsp;startByte,size_t&nbsp;sizeKey,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;startIndex,void&nbsp;*item,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(Vector&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*SelectCopy)(Vector&nbsp;*src,Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetCapacity)(Vector&nbsp;*AL,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(Vector&nbsp;*l,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(Vector&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Vector&nbsp;*AL,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Vector&nbsp;*AL,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;Vector&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(Vector&nbsp;*AL);
}&nbsp;VectorInterface;

</pre></font>


<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR><img src="VectorVocabulary.png" alt="Figure">
<BR CLEAR=LEFT><BR><BR>


<div class="p"><!----></div>
<a 
name="Vector31"></a>     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container32"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Vector&nbsp;*AL,void&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(TYPEVector,&nbsp;TYPE&nbsp;data);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the end of the container. It is the same operations as the PushBack operation. It is assumed that "data" points to a contiguous memory area of at least ElementSize bytes. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector or the data pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL&nbsp;=&nbsp;iVector.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iVector.Add(AL,&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Template&nbsp;version
&nbsp;&nbsp;&nbsp;&nbsp;#include&nbsp;"doubleVector.h"
&nbsp;&nbsp;&nbsp;&nbsp;doubleVector&nbsp;*AL&nbsp;=&nbsp;idoubleVector.Create();
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;idoubleVector.Add(AL,4.5);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="AddRange+\container32"></a> <font size="+1"><b>AddRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Vector&nbsp;*AL,size_t&nbsp;n,&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(TYPEVector&nbsp;*AL,size_t&nbsp;n,&nbsp;TYPE&nbsp;*data);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the n given elements to the end of the container. It is the same operations as the PushBack operation. It is assumed that "data" points to a contiguous memory area of at least n*ElementSize bytes. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise. If n is zero no error is issued even if the array pointer or the data pointer are &nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector or the data pointers are &nbsp;NULL , and n is not zero.

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data[]&nbsp;=&nbsp;{4.5,&nbsp;4.6,&nbsp;4.7&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;AL&nbsp;=&nbsp;iVector.Create(sizeof(double),5);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iVector.Add(AL,3,&nbsp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Template&nbsp;version
&nbsp;&nbsp;&nbsp;&nbsp;#include&nbsp;"doubleVector.h"
&nbsp;&nbsp;&nbsp;&nbsp;doubleVector&nbsp;*AL&nbsp;=&nbsp;idoubleVector.Create(5);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data[]&nbsp;=&nbsp;{4.5,&nbsp;4.6,&nbsp;4.7&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;idoubleVector.Add(AL,3,&nbsp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Append+\container32"></a> <font size="+1"><b>Append</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;int&nbsp;(*Append)(Vector&nbsp;*AL1,&nbsp;Vector&nbsp;*AL2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds all elements of AL2 at the end of the first container AL1. The two vectors should contain elements of the same type.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of the Vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The first argument is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container32"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Vector&nbsp;l,int&nbsp;(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(TYPEVector&nbsp;l,int&nbsp;(Applyfn)(TYPE,void&nbsp;*),void&nbsp;*arg);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Will call the given function for each element of the array. The first argument of the callback function receives an element of the array. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the array is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either list or Applyfn are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The list is read-only and there is no more memory to allocate the buffer to copy each element.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if no errors or a negative error code.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

static&nbsp;int&nbsp;Callback(void&nbsp;*pelement,void&nbsp;*pResult)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p&nbsp;=&nbsp;pelement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*result&nbsp;=&nbsp;pResult;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*result&nbsp;+=&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;AddVector(Vector&nbsp;*l)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*alist&nbsp;=&nbsp;iVector.Create(sizeof(double),2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(alist,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(alist,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Apply(alist,Callback,&amp;sum);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Here&nbsp;sum&nbsp;should&nbsp;be&nbsp;5.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sum;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;------------------------------Template&nbsp;version
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;Callback(double&nbsp;element,void&nbsp;*pResult)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*result&nbsp;=&nbsp;pResult;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*result&nbsp;+=&nbsp;element;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;AddVector(Vector&nbsp;*l)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doubleVector&nbsp;*alist&nbsp;=&nbsp;idoubleVector.Create(2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idoubleVector.Add(alist,2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idoubleVector.Add(alist,3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idoubleList.Apply(alist,Callback,&amp;sum);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Here&nbsp;sum&nbsp;should&nbsp;be&nbsp;5.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sum;
&nbsp;&nbsp;&nbsp;&nbsp;}


</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Back+\container32"></a> <font size="+1"><b>Back</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*Back)(const&nbsp;Vector&nbsp;*v);
TYPE&nbsp;&nbsp;(*Back)(const&nbsp;TYPEVector&nbsp;*v);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the last element of the given vector or &nbsp;NULL if the vector is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.

<div class="p"><!----></div>
<b>Returns:</b>
The last element or &nbsp;NULL if the vector is empty or an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container32"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Vector&nbsp;*l);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The vector header will not be destroyed, and its contents will be the same as when the array was initially created. It is an error to use this function when there are still active iterators for the container.

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*Al;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m&nbsp;=&nbsp;iVector.Clear(Al);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CompareEqual+\container32"></a> <font size="+1"><b>CompareEqual</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*CompareEqual)(ValArray&nbsp;*left,ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each element of the mask the result of comparing the corresponding elements of the left and right arrays. Conceptually this operation is: 
<font size=+1><pre>
Mask[i]&nbsp;=&nbsp;(left[i]&nbsp;==&nbsp;right[i])

</pre></font> 
If the mask argument is &nbsp;NULL it will be allocated and returned. 
The allocator used is the global memory manager. 
If it is not &nbsp;NULL it should contain at least enough positions to hold the data. If it doesn't it will be finalized using <font size="+1"><tt>iMask.Finalize</tt></font> and 
allocated with the necessary length.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was &nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given mask hasn't enough positions available.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The arrays are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray passed or allocated, or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="CompareEqualScalar+\container32"></a> <font size="+1"><b>CompareEqualScalar</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*CompareEqual)(const&nbsp;Vector&nbsp;*left,const&nbsp;void&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each element of the mask the result of comparing the elements of the left array with the right argument. 
Conceptually this operation is: 

<font size=+1><pre>
bit[i]&nbsp;=&nbsp;(left[i]&nbsp;==&nbsp;right)

</pre></font> 
If the bitarray argument is &nbsp;NULL it will be allocated and returned. The allocator used is the one from the left argument. If it is not &nbsp;NULL it will be allocated if its length is less than the needed length.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was &nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Contains+\container32"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(Vector&nbsp;*a,void&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(TYPEVector&nbsp;*a,TYPE&nbsp;data);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Searches the given data in the array. The "data" argument is supposed to point to an element at least ElementSize bytes. The array's comparison function is used for determining if two elements are equal. This comparison function defaults to memcmp.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either array or data are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
One if the given data is stored in the array, zero otherwise. If either the data pointer or the array pointer are &nbsp;NULL it returns a negative error code.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*a&nbsp;=&nbsp;iVector.Create(sizeof(double),2);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;78.67;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Contains(a,&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;---------------------------Template&nbsp;version
&nbsp;&nbsp;&nbsp;&nbsp;doubleVector&nbsp;*a&nbsp;=&nbsp;iVector.Create(2);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Contains(a,78.67);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container32"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Copy)(Vector&nbsp;*A);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
A shallow copy of the given array is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the given array's allocator.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given vector pointer is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*newVector,*OldVector;
&nbsp;&nbsp;&nbsp;&nbsp;newVector&nbsp;=&nbsp;iVector.Copy(OldVector);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CopyElement+\container32"></a> <font size="+1"><b>CopyElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Copy)(const&nbsp;Vector&nbsp;*A,size_t&nbsp;idx,void&nbsp;*result);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
The element at the given index is copied into the output buffer that should be at least big enough to hold one element. If the index is bigger
than the number of elements the error function is called. If it returns a valid pointer (not &nbsp;NULL ) it is assumed that this is a pointer to a valid
element that should be copied into the output buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
If the <font size="+1"><tt>idx</tt></font> argument is out of range the <font size="+1"><tt>CopyElement</tt></font> function calls the vector error function. If the error function returns a result
different than &nbsp;NULL , the function assumes that it is a pointer to some value that should be copied into the result buffer.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The index is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given vector pointer is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*V;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buffer[16];
&nbsp;&nbsp;&nbsp;&nbsp;newVector&nbsp;=&nbsp;iVector.CopyElement(V,3,buffer);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CopyTo+\container32"></a> <font size="+1"><b>CopyTo</b></font> <hr />


<font size=+1><pre>

void&nbsp;**(*CopyTo)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the whole contents of the given array into a table of pointers to newly allocated elements, finished by a &nbsp;NULL pointer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a table of pointers or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="DeleteIterator+\container32"></a> <font size="+1"><b>DeleteIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;DeleteIterator(Iterator&nbsp;*it);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims the memory used by the given iterator object

<div class="p"><!----></div>
<b>Returns:</b>
Integer smaller than zero with error code or a positive number when the operation completes.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container32"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Create)(size_t&nbsp;element_size,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;&nbsp;TYPEVector&nbsp;*(*Create)(size_t&nbsp;startsize);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
The creation function returns an empty array, initialized with all the default values.
The current memory manager is used to allocate the space needed for the header. The array is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the array with sizeof(void *) as the size parameter.

<div class="p"><!----></div>

<b>Returns:</b>
A pointer to a newly created array or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given element size is zero.

<div class="p"><!----></div>
Any errors provoke the call the current default error function of the library since this is the creation function.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*DArray&nbsp;=&nbsp;iVector.Create(sizeof(double),100);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CreateWithAllocator+\container32"></a> <font size="+1"><b>CreateWithAllocator</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;startsize,ContainerAllocator&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function is identical to <font size="+1"><tt>Create</tt></font> with the difference that it accepts a pointer to an allocator object. Actually, <font size="+1"><tt>Create</tt></font> can
be written as:
<div class="p"><!----></div>
<font size="+1"><tt>return CreateWithAllocator(elementsize,startsize,CurrentAllocator);</tt></font>
 
<div class="p"><!----></div>
<br /><a 
name="Equal+\container32"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(Vector&nbsp;*first,Vector&nbsp;*second);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares the given arrays. If they differ in their length, flags, or element size they compare unequal. If any of their elements differ, they compare unequal.
If both first and second are &nbsp;NULL they compare equal. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
The result is one if the vectors are equal, zero otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container32"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Vector&nbsp;*AL,void&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(TYPEVector&nbsp;*AL,TYPE&nbsp;data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the vector the element that matches the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that at least one match was found and the elements were removed. 
If the element is not in the vector the result value is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Erase(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("2.3&nbsp;erased|n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("No&nbsp;element&nbsp;with&nbsp;value&nbsp;2.3&nbsp;present\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("error&nbsp;code&nbsp;%d\n",r);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="EraseAll+\container32"></a> <font size="+1"><b>EraseAll</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(Vector&nbsp;*v,const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(TYPEVector&nbsp;*v,const&nbsp;TYPE&nbsp;data);&nbsp;&nbsp;&nbsp;&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list all elements that match the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that at least a match was found and the element was removed. If the 
element is not in the list the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="EraseAt+\container32"></a> <font size="+1"><b>EraseAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(Vector&nbsp;*AL,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the array the element at the given position.

<div class="p"><!----></div>

<b>Returns:</b>
A negative error code if an error occurred or a positive value that indicates that the element was removed.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.EraseAt(AL,2);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Element&nbsp;at&nbsp;position&nbsp;2&nbsp;erased\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error&nbsp;code&nbsp;%d\n",r);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container32"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the container, including the array header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The container is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed. A negative error code indicates failure.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Finalize(AL);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container32"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*Front)(const&nbsp;Vector&nbsp;*v);
TYPE&nbsp;&nbsp;(*Front)(const&nbsp;TYPEVector&nbsp;*v);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the first element of the given vector or &nbsp;NULL if the vector is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.

<div class="p"><!----></div>
<b>Returns:</b>
The first element or &nbsp;NULL if the vector is empty or an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="GetCapacity+\container32"></a> <font size="+1"><b>GetCapacity</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements the array can hold before  it needs to reallocate its data<a href="#tthFtNtAEC" name="tthFrefAEC"><sup>42</sup></a>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The array capacity or zero if there was an error.
 
<div class="p"><!----></div>
<br /><a 
name="GetElementSize+\container32"></a> <font size="+1"><b>GetElementSize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the size of the elements stored in the given vector. Note that this value can be different than the value given to the creation function because of alignment requirements. In template containers this function returns
<font size="+1"><tt>sizeof(TYPE)</tt></font>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer is &nbsp;NULL .

<div class="p"><!----></div>

<b>Returns:</b>
The element size.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iVector.GetElementSize(AL);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="GetData+\container32"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

void&nbsp;**(*GetData)(const&nbsp;Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the data area of the container, or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_READONLY

 The container is read-only.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given pointer is &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>The pointer to the array's data or &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="GetElement+\container32"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(Vector&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;*(*GetElement)(TYPEVector&nbsp;*AL,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a read only pointer to the element at the given index, or &nbsp;NULL if the operation failed.  This function will return &nbsp;NULL if the vector is read only. If the index is greater than the number of elements, the error function will be called. If the error function returns a valid pointer
(not &nbsp;NULL ) the result will be that pointer. This allows the construction of infinite arrays, or sparse arrays, etc. By default, the error function
returns always &nbsp;NULL .

<div class="p"><!----></div>
Use the CopyElement function to get a read/write copy of an element of the vector.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given array pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

    The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

    The array is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d&nbsp;=&nbsp;iVector.GetElement(AL,3);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="GetFlags / SetFlags+\container32"></a> <font size="+1"><b>GetFlags / SetFlags</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Vector&nbsp;*AL,unsigned&nbsp;newFlags);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
GetFlags returns the state of the container flags, SetFlags sets the flags to a new value and returns the old value. 

<div class="p"><!----></div>
The Vector container supports the following flags:

<div class="p"><!----></div>
 CONTAINER_READONLY
If this flag is set, no modifications to the container are allowed, and the Clear and Finalize functions will not work. The GetElement function will always return &nbsp;NULL . You should use the CopyElement function to access the data
 
<div class="p"><!----></div>
<br /><a 
name="GetRange+\container32"></a> <font size="+1"><b>GetRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*GetRange)(Vector&nbsp;*AL,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Selects a series of consecutive elements starting at position start and ending at position end.  Both the elements at start and end are included in the result.
If start &#62; end or start &#62; Size(AL), &nbsp;NULL is returned. If end is bigger than the number of elements in the vector AL, only elements up to the number of elements will be used.
The selected elements are copied into a new array. The original array remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array pointer or the element given are &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new vector containing the selected elements or &nbsp;NULL if an error occurs.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*range&nbsp;=&nbsp;iVector.GetRange(AL,2,5);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(range&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="IndexIn+\container32"></a> <font size="+1"><b>IndexIn</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*IndexIn)(Vector&nbsp;*SC,Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns an array built from indexing the first argument ("SC") with the array of indexes &#196;L" that should be an array of size_t elements. The number of elements of the resulting array is equal to the number of elements of the indexes array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array pointer or the indexes array are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 Any given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new array or &nbsp;NULL if an error occurs. No partial results are returned. If any index is out of bounds the whole operation fails.

<div class="p"><!----></div>
 
<br /><a 
name="IndexOf+\container32"></a> <font size="+1"><b>IndexOf</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*IndexOf)(Vector&nbsp;*l,void&nbsp;*data,void&nbsp;*ExtraArgs,size_t&nbsp;*result);
int&nbsp;(*IndexOf)(TYPEVector&nbsp;*l,TYPE&nbsp;data,void&nbsp;*ExtraArgs,size_t&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches for an element in the array. If found its zero based index is returned in the pointer "result". Otherwise the result of the search is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
. The &#235;xtraArgs" argument will be passed to the comparison function, that is used to compare elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array pointer or the element given are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element is found, or a negative number containing an error code or the negative constant 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;6.8;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;pos;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.IndexOf(AL,&amp;data,NULL,&amp;pos);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;CONTAINER_ERROR_NOTFOUND)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Not&nbsp;found\n");

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="InsertAt+\container32"></a> <font size="+1"><b>InsertAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*newData);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(TYPEVector&nbsp;*AL,size_t&nbsp;idx,TYPE&nbsp;newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the new element. The new element will have the given index, that can go from zero to the vector count inclusive, i.e. one more than the number of elements in the vector. If the index is out of bounds, the vector error function is called. If the function returns a valid pointer (a pointer
different than &nbsp;NULL ) it will be assumed that the vector should be increased to the index given. The vector is resized and the data is inserted
at the requested position. This allows the implementation of infinite vectors, sparse vectors, and other data structures.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
When this API detects an index error, it calls the error function. If the error function returns a pointer different from &nbsp;NULL , the API will extend
the requested vector to make possible the insertion. If the API is unable to extend the vector and error is returned and the vector remains unchanged.

<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer or the element given are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.7;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL&nbsp;=&nbsp;iVector.Create(sizeof(double),3);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.InsertAt(AL,2,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;Normal&nbsp;processing&nbsp;*/&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--------------------------Template&nbsp;version
&nbsp;&nbsp;&nbsp;&nbsp;doubleVector&nbsp;*AL&nbsp;=&nbsp;idoubleVector.Create(3);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;idoubleVector.InsertAt(AL,2,2.7);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;Normal&nbsp;processing&nbsp;*/&nbsp;&nbsp;}


</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="InsertIn+\container32"></a> <font size="+1"><b>InsertIn</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(Vector&nbsp;*Destination,&nbsp;size_t&nbsp;pos,&nbsp;Vector&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the array given in  its third argument at the given position in the array pointed to by its first argument. The data is copied, and the source argument is not modified in any way. Both arrays must have elements of the same type. The library only tests the size of each one.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The source or the destination vectors are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The destination vector is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The vectors store elements of different size.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;PrintVector(Vector&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Count&nbsp;%ld,&nbsp;Capacity&nbsp;%ld\n",(long)iVector.Size(AL),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long)iVector.GetCapacity(AL));
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iVector.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*(double&nbsp;*)iVector.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

static&nbsp;void&nbsp;FillVector(Vector&nbsp;*&nbsp;AL,int&nbsp;start)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;i+start;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL&nbsp;=&nbsp;iVector.Create(sizeof(double),10);
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL1&nbsp;=iVector.Create(sizeof(double),10);
&nbsp;&nbsp;&nbsp;&nbsp;FillVector(AL,0);
&nbsp;&nbsp;&nbsp;&nbsp;FillVector(AL1,100);
&nbsp;&nbsp;&nbsp;&nbsp;iVector.InsertIn(AL,5,AL1);
&nbsp;&nbsp;&nbsp;&nbsp;PrintVector(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Count&nbsp;20,&nbsp;Capacity&nbsp;20
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;100&nbsp;101&nbsp;102&nbsp;103&nbsp;104&nbsp;105&nbsp;106&nbsp;107&nbsp;108&nbsp;109&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9
---------------------------------------------Template&nbsp;version
#include&nbsp;&lt;containers.h&#62;
#include&nbsp;"doublevector.h"
static&nbsp;void&nbsp;PrintVector(doubleVector&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Count&nbsp;%ld,&nbsp;Capacity&nbsp;%ld\n",(long)iVector.Size(AL),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long)iVector.GetCapacity(AL));
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iVector.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",idoubleVector.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

static&nbsp;void&nbsp;FillVector(Vector&nbsp;*&nbsp;AL,int&nbsp;start)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idoubleVector.Add(AL,i+start);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL&nbsp;=&nbsp;idoubleVector.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL1&nbsp;=idoubleVector.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;FillVector(AL,0);
&nbsp;&nbsp;&nbsp;&nbsp;FillVector(AL1,100);
&nbsp;&nbsp;&nbsp;&nbsp;iVector.InsertIn(AL,5,AL1);
&nbsp;&nbsp;&nbsp;&nbsp;PrintVector(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Count&nbsp;20,&nbsp;Capacity&nbsp;20
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;100&nbsp;101&nbsp;102&nbsp;103&nbsp;104&nbsp;105&nbsp;106&nbsp;107&nbsp;108&nbsp;109&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9


</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Load+\container32"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads an array previously saved with the Save function from the stream pointed to by stream. If readFn is not &nbsp;NULL , it will be used to read each element. The <font size="+1"><tt>arg</tt></font> argument will be passed to the read function. If the read function is &nbsp;NULL , this argument is ignored and a default read function is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A new array or &nbsp;NULL if the operation could not be completed. Note that the function pointers in the array are NOT saved, nor any special allocator that was in the original vector. Those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new array.
 
<div class="p"><!----></div>
<br /><a 
name="NewIterator+\container32"></a> <font size="+1"><b>NewIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates and initializes a new iterator object to iterate this array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
If no more memory is available it returns &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new iterator or &nbsp;NULL if there is no more memory left.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iVector.NewIterator(AL);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(d=it-&#62;GetFirst(it);&nbsp;d&nbsp;!=&nbsp;NULL;&nbsp;d&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;val&nbsp;=&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;the&nbsp;value&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iVector.DeleteIterator(it);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Mismatch+\container32"></a> <font size="+1"><b>Mismatch</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Mismatch)(const&nbsp;Vector&nbsp;*a1,const&nbsp;Vector&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the index of the first element that is different when comparing both arrays in the passed pointer <i>mismatch</i>. If one array is shorter than the other the comparison stops
when the last element from the shorter array is compared. The comparison stops when the first difference is spotted.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any of the arguments is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The containers have different comparison functions or store elements of different size.

<div class="p"><!----></div>
<b>Returns:</b>
If a mismatch is found the result is greater than zero and the <i>mismatch</i> argument will contain the index of the first element that compared 
unequal. This will be always the case for arrays of different length.

<div class="p"><!----></div>
If both arrays are the same length and no differences are found the result is zero and the value pointed to by the 
<i>mismatch</i> argument is one more than the length of the arrays.

<div class="p"><!----></div>
If an error occurs, a negative error code is returned. The <i>mismatch</i> argument contains zero.
 
<div class="p"><!----></div>
<br /><a 
name="PopBack+\container32"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Vector&nbsp;*AL,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(TYPEVector&nbsp;*AL,TYPE&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the last element into the given result buffer and deletes the element from the container. If the result buffer is &nbsp;NULL , no copy is performed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>

<b>Returns:</b>
A negative value if an error occurs, zero if the array is empty or greater than zero if the operation succeeded.
 
<div class="p"><!----></div>
<br /><a 
name="RemoveRange+\container32"></a> <font size="+1"><b>RemoveRange</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*RemoveRange)(Vector&nbsp;*SC,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes all elements having an index equal or greater than
<font size="+1"><tt><i>start</i></tt></font>
 and less than
<font size="+1"><tt><i>end</i></tt></font>
. If
<font size="+1"><tt><i>end</i></tt></font>
 is greater than the number of elements 
in the collection it will be adjusted to one more than the number of elements. If
<font size="+1"><tt><i>start</i></tt></font>
 is bigger than
<font size="+1"><tt><i>end</i></tt></font>
 the range is still valid and
starts with the value of
<font size="+1"><tt><i>end</i></tt></font>
 and ends with the value of
<font size="+1"><tt><i>start</i></tt></font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
Zero if the vector is empty. Otherwise returns a positive number for success, a negative error code in case of an error.
 
<div class="p"><!----></div>
<br /><a 
name="ReplaceAt+\container32"></a> <font size="+1"><b>ReplaceAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*newData);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(TYPEVector&nbsp;*AL,size_t&nbsp;idx,TYPE&nbsp;newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the array element at position idx with the new data starting at the position pointed to by "newData" and extending ElementSize bytes.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array or the new element pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL&nbsp;=&nbsp;iVector.Create(sizeof(double),2);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;6.7;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.ReplaceAt(AL,2,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--------------------------------Template&nbsp;version
&nbsp;&nbsp;&nbsp;&nbsp;doubleVector&nbsp;*AL&nbsp;=&nbsp;idoubleVector.Create(2);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;idoubleVector.ReplaceAt(AL,2,6.7);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Reserve+\container32"></a> <font size="+1"><b>Reserve</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Reserve)(Vector&nbsp;*AL,&nbsp;size_t&nbsp;newSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The capacity of the vector is increased at least by the given amount in preparation for a planned increase in elements. The size is in element
units.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the space could be reserved, a negative error code if not.
 
<div class="p"><!----></div>
<br /><a 
name="Resize+\container32"></a> <font size="+1"><b>Resize</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Resize)(Vector&nbsp;*AL,&nbsp;size_t&nbsp;newSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Resizes the given vector to the new capacity, expressed in element units. If the new capacity is smaller than the elements in 
the vector some elements will be erased.
For each erased element its destructor (if any) is called. If the requested <font size="+1"><tt>newSize</tt></font> argument is equal to the number of elements in the 
container, all storage beyond what is needed to store exactly <font size="+1"><tt>newSize</tt></font> elements, is released.
This allows to signal the library that the extra storage is no longer needed<a href="#tthFtNtAED" name="tthFrefAED"><sup>43</sup></a>.

<font size=+1><pre>
iVector.Resize(vec,iVector.Size(vec));

</pre></font>

<div class="p"><!----></div>
Obviously under some implementations it is maybe impossible to allocate <b>exactly</b> the space needed, for instance because space can be only 
allocated in chunks bigger than the element size of the vector. In those cases only a "best effort" will be done and the used storage will be reduced 
to a minimum.
If an error occurs, and the container can't be resized, no changes occur and the container is left unmodified.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded. If the requested capacity is equal to the current
capacity  the result is zero.
 
<div class="p"><!----></div>
<br /><a 
name="Reverse+\container32"></a> <font size="+1"><b>Reverse</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Reverse)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reverses the order of the elements of the given Vector.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory for intermediate storage available

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.
 
<div class="p"><!----></div>
<br /><a 
name="RotateRight+\container32"></a> <font size="+1"><b>RotateRight</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(Vector&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates right the array by the indicated amount. The last n elements will be written to the start of
the array, and the rest will be shifted right.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size).

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="RotateLeft+\container32"></a> <font size="+1"><b>RotateLeft</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(Vector&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates left the array by the indicated amount. The first n elements will be written to the end of
the array, and the rest will be shifted left to fill the empty n places.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory for intermediate storage available

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size), or an error code less than zero if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Save+\container32"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;Vector&nbsp;*AL,&nbsp;FILE&nbsp;*out,&nbsp;SaveFunction&nbsp;Fn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given vector are saved into the given stream. If the save function pointer is not &nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer or the stream pointer are &nbsp;NULL .
EOF A disk input/output error occurred.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*outFile;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iVector.Save(AL,outFile,NULL,NULL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SearchWithKey+\container32"></a> <font size="+1"><b>SearchWithKey</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SearchWithKey)(Vector&nbsp;*vec,size_t&nbsp;startByte,size_t&nbsp;sizeKey,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;startIndex,void&nbsp;*item,&nbsp;size_t*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function searches the vector for a match in a region of the stored objects, ignoring the rest of the data. It will start at the object with <i>startIndex</i> and compare (using memcmp) the specified region of each object. The region of interest within the stored object is specified 
by a byte offset and a size.
If a match is found the search stops and the zero based index of the object will
be written into the <i>result</i> pointer. If the index of the start of the iteration is bigger than the number of elements in the array nothing
is searched and the result is zero.

<div class="p"><!----></div>
If the sum of <i>startByte</i> and <i>sizeKey</i> is bigger than the size of the elements stored, the comparison will start at the given offset but will stop
at the end of the stored element.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array or the item element pointers are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, zero if no match was found, or a positive number indicating that a match was found. The given index pointer is
modified only if a match is found.
 
<div class="p"><!----></div>
<br /><a 
name="Select+\container32"></a> <font size="+1"><b>Select</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Select)(Vector&nbsp;*v,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Using the given mask, the elements where the corresponding mask element is zero are eliminated, those with a mask
value different of zero are retained. The mask must have the same length as the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The mask and the array are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, or a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="SelectCopy+\container32"></a> <font size="+1"><b>SelectCopy</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*SelectCopy)(Vector&nbsp;*v,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Using the given mask, the elements where the corresponding mask element is different from zero are copied into a new array, those with a mask
value different of zero are ignored. The mask must have the same length as the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The mask and the array are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, or a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="SetCapacity+\container32"></a> <font size="+1"><b>SetCapacity</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SetCapacity)(Vector&nbsp;*AL,size_t&nbsp;newCapacity);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Resizes the given Vector to a new value. The new capacity means there will be that number of elements allocated, avoiding costly resizing operations when new elements are added to the Vector. If the number given is less than the number of elements present in the array, elements are discarded from the end of the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The Vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
<b>Returns:</b>A positive value if resizing was completed, a negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="SetCompareFunction+\container32"></a> <font size="+1"><b>SetCompareFunction</b></font> <hr />


<font size=+1><pre>

CompareFunction&nbsp;(*SetCompareFunction)(Vector&nbsp;*AL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;f);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
if the f argument is non &nbsp;NULL , it sets the array comparison function to f.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only and the function argument is not &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the comparison function.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

ErrorFunction&nbsp;fn,newfn;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;iVector.SetErrorFunction(AL,newfn);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SetDestructor+\container32"></a> <font size="+1"><b>SetDestructor</b></font> <hr />


<font size=+1><pre>

DestructorFunction&nbsp;(*SetDestructor)(Vector&nbsp;*v,DestructorFunction&nbsp;fn);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Sets the destructor function to its given argument. If the function argument is &nbsp;NULL nothing is changed and the call is interpreted as a query since the return value is the current value of the destructor function. If the vector argument is &nbsp;NULL , the result is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the destructor.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="SetErrorFunction+\container32"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Vector&nbsp;*V,ErrorFunction);&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current error function  for the given vector with the new error function if the
<font size="+1"><tt><i>ErrorFunction</i></tt></font>
parameter is different from &nbsp;NULL . If 
the
<font size="+1"><tt><i>V</i></tt></font>
parameter is &nbsp;NULL the function returns the value of the current default error function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only and the function argument is not &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the error function or &nbsp;NULL if there is an error.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Size+\container32"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the array.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elem&nbsp;=&nbsp;iVector.Size(AL);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Sizeof+\container32"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the vector, including the header, and all data stored in it. If the argument is &nbsp;NULL , the size of the header only is returned.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the vector or the size of the Vector header if the argument is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;size&nbsp;=&nbsp;iVector.Sizeof(AL);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Sort+\container32"></a> <font size="+1"><b>Sort</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Sort(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sorts the given array using the its comparison function. The order of the original array is destroyed. You should copy it if you want to preserve it. 

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if sorting succeeded, a negative error code if not.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iVector.Sort(AL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;The bit-string container: iBitString</h2>
<a 
name="BitString40"></a><img src="bitstrings.png" alt="Figure">
<div class="p"><!----></div>
 BitString vocabulary. Specific items are in bold.
<div class="p"><!----></div>
A bit string is a derivation from the Vector container, specialized to hold a sequence of bits. It is a sequential container designed to save space in the storage of boolean values
<a href="#tthFtNtAEE" name="tthFrefAEE"><sup>44</sup></a>. 

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;The interface</h3>
<a 
name="iBitString41"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagBitStringInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(BitString&nbsp;*BitStr,int);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(BitString&nbsp;*b,&nbsp;size_t&nbsp;bitSize,&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*And)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AndAssign)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(BitString&nbsp;*left,BitString&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(BitString&nbsp;*BitStr,int&nbsp;(*Applyfn)(int&nbsp;,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;uintmax_t&nbsp;(*BitBlockCount)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;int&nbsp;(*BitLeftShift)(BitString&nbsp;*bs,size_t&nbsp;shift);
&nbsp;&nbsp;&nbsp;int&nbsp;(*BitRightShift)(BitString&nbsp;*bs,size_t&nbsp;shift);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(BitString&nbsp;*BitStr,BitString&nbsp;*str,void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Copy)(BitString&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyBits)(BitString&nbsp;*bitstr,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Create)(size_t&nbsp;bitlen);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsiz,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(BitString&nbsp;*BitStr,int&nbsp;bit);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(BitString&nbsp;*BitStr,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*(*GetData)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*GetElement)(BitString&nbsp;*BitStr,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(BitString&nbsp;*BitStr);&nbsp;
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*GetRange)(BitString&nbsp;*b,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(BitString&nbsp;*BitStr,int&nbsp;SearchedBit,void&nbsp;*ExtraArgs,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Init)(BitString&nbsp;*BitStr,size_t&nbsp;bitlen);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(BitString&nbsp;*,void&nbsp;*);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*InitializeWith)(size_t&nbsp;size,void&nbsp;*data);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Insert)(BitString&nbsp;*BitStr,int&nbsp;bit);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*InsertAt)(BitString&nbsp;*BitStr,size_t&nbsp;idx,int&nbsp;bit);
&nbsp;&nbsp;&nbsp;int&nbsp;(*LessEqual)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Memset)(BitString&nbsp;*,size_t&nbsp;start,size_t&nbsp;stop,int&nbsp;newval);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(BitString&nbsp;*);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Not)(BitString&nbsp;*bsl);
&nbsp;&nbsp;&nbsp;int&nbsp;(*NotAssign)(BitString&nbsp;*bsl);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Or)(BitString&nbsp;*left,BitString&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*OrAssign)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;uintmax_t&nbsp;(*PopulationCount)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Print)(BitString&nbsp;*b,size_t&nbsp;bufsiz,unsigned&nbsp;char&nbsp;*out);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(BitString&nbsp;*BitStr,int&nbsp;val);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(BitString&nbsp;*BitStr,size_t&nbsp;idx,int&nbsp;newval);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Reverse)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;BitString&nbsp;*bitstr,FILE&nbsp;*stream,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetCapacity)(BitString&nbsp;*BitStr,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetElement)(BitString&nbsp;*bs,size_t&nbsp;position,int&nbsp;b);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;*(*SetErrorFunction)(BitString&nbsp;*,ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(BitString&nbsp;*BitStr,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(BitString&nbsp;*BitStr);&nbsp;
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*StringToBitString)(unsigned&nbsp;char&nbsp;*);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Xor)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*XorAssign)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
}&nbsp;BitStringInterface;

</pre></font>


     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;API</h3>
Contrary to the other containers presented above like <font size="+1"><tt>iList</tt></font> or <font size="+1"><tt>iVector</tt></font>, bitstring receives and returns not pointers but values of bits. This is an important difference and makes for significant changes in the interface of many functions.

<div class="p"><!----></div>
Other functions like <font size="+1"><tt>Apply</tt></font> do not make much sense for bits and are provided  just to be coherent in the overall design of the library. Obviously a function that needs a function call per bit is not very fast.
The function GetElementSize is provided for compatibility purposes only and returns always 1. Actually it should return 0.125 assuming
8 bits bytes.
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container42"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(BitString&nbsp;*BitStr,int);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds a bit at the end of the given bitstring.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is no memory to carry out the operation.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the bit is added or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="And+\container42"></a> <font size="+1"><b>And</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*And)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical AND between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the newly allocated result or &nbsp;NULL in case of error.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of both bitstring pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b,*c,*d;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(c,i&lt;16);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;AND\n");
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(c,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("=\n");
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;iBitString.And(b,c);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(d,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010
&nbsp;AND
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111
=
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="AndAssign+\container42"></a> <font size="+1"><b>AndAssign</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AndAssign)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical AND of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number or a negative error code in case of error.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b,*c;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(c,i&lt;16);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;AND\n");
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(c,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("=\n");
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.AndAssign(b,c);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010
&nbsp;AND
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111
=
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="BitBlockCount+\container42"></a> <font size="+1"><b>BitBlockCount</b></font> <hr />


<font size=+1><pre>

uintmax_t&nbsp;&nbsp;(*BitBlockCount)(BitString&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of blocks where 1 or more bits are set.

<div class="p"><!----></div>
<b>Returns:</b>
The number of blocks of set bits.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given argument is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b,*c,*d;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(c,i&lt;16);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s&nbsp;BitBlockCount=%ld\n",buf,iBitString.BitBlockCount(b));
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(c,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s&nbsp;BitBlockCount=%ld\n",buf,iBitString.BitBlockCount(c));
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;BitBlockCount=16
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111&nbsp;BitBlockCount=1

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CopyBits+\container42"></a> <font size="+1"><b>CopyBits</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyBits)(BitString&nbsp;*b,&nbsp;void&nbsp;*buffer);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the bits into the given buffer. The size of the buffer is at least:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;1+iBitstring.Size(bitstr)/8

</pre></font>

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either the bitstring or the buffer pointer are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the bits are copied, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="GetData+\container42"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*(*GetData)(BitString&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Returns a pointer to the bits stored in the bitstring. If the string is read-only the result is &nbsp;NULL . The size of the needed buffer can be 
calculated according to:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;BitString&nbsp;*bitstr;
&nbsp;&nbsp;&nbsp;size_t&nbsp;bytesize;

&nbsp;&nbsp;&nbsp;bytesize&nbsp;=&nbsp;1+iBitString.GetSize(bitstr)/CHAR_BIT;

</pre></font>

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The bit string pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The bitstring is read-only.

<div class="p"><!----></div>
 
<br /><a 
name="GetRange+\container42"></a> <font size="+1"><b>GetRange</b></font> <hr />


<font size=+1><pre>

BitString&nbsp;*(*GetRange)(BitString&nbsp;*b,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns all the bits between the start (inclusive) and the end (inclusive) indices. If end is smaller than start, start and end are exchanged.
If end is greater than the size of the bit string, all elements up to the last one are returned. If both start and end are out of range, an error is issued and the result is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A new bit string with the specified contents.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given argument is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;outbuf[256];
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*bs&nbsp;=&nbsp;iBitString.StringToBitString("0001&nbsp;1111&nbsp;0000&nbsp;0000");
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*bs1&nbsp;=&nbsp;iBitString.GetRange(bs,8,14);
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*bs2&nbsp;=&nbsp;iBitString.GetRange(bs,7,14);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(bs,sizeof(outbuf),outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Original:%s&nbsp;\n",outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(bs1,sizeof(outbuf),outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Range&nbsp;8,14:&nbsp;%s\n",outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(bs2,sizeof(outbuf),outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Range&nbsp;7,14:%s\n",outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Original:0001&nbsp;1111&nbsp;&nbsp;0000&nbsp;0000&nbsp;
Range&nbsp;8,14:&nbsp;01&nbsp;1111
Range&nbsp;7,14:001&nbsp;1110

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="BitLeftShift+\container42"></a> <font size="+1"><b>BitLeftShift</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*BitLeftShift)(BitString&nbsp;*bs,size_t&nbsp;shift);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Shifts left the given bit string by the specified number of bits. New bits introduced by the right are zeroed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The bit string pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>An integer bigger than zero if successful, a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
static&nbsp;void&nbsp;Putbs(BitString&nbsp;*bs,char&nbsp;*prompt)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;outbuf[256];
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(bs,sizeof(outbuf),outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s:&nbsp;%s\n",prompt,outbuf);
}
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;outbuf[256];
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ls;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Usage:&nbsp;%s:&nbsp;amount\n",argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ls&nbsp;=&nbsp;atoi(argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*bs&nbsp;=&nbsp;iBitString.StringToBitString("0001&nbsp;1111&nbsp;1010&nbsp;0000");
&nbsp;&nbsp;&nbsp;&nbsp;Putbs(bs,"Original&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.BitLeftShift(bs,ls);
&nbsp;&nbsp;&nbsp;&nbsp;sprintf(outbuf,"Shifted&nbsp;left&nbsp;by&nbsp;%d",ls);
&nbsp;&nbsp;&nbsp;&nbsp;Putbs(bs,outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
~/ccl/test&nbsp;$&nbsp;./a.out&nbsp;1
Original&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0001&nbsp;1111&nbsp;&nbsp;1010&nbsp;0000
Shifted&nbsp;left&nbsp;by&nbsp;1:&nbsp;0011&nbsp;1111&nbsp;&nbsp;0100&nbsp;0000
~/ccl/test&nbsp;$&nbsp;./a.out&nbsp;3
Original&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0001&nbsp;1111&nbsp;&nbsp;1010&nbsp;0000
Shifted&nbsp;left&nbsp;by&nbsp;3:&nbsp;1111&nbsp;1101&nbsp;&nbsp;0000&nbsp;0000

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Not+\container42"></a> <font size="+1"><b>Not</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Not)(BitString&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical NOT of its argument. The result is returned in a new bit string. The length of the resulting bit string is the same as the length of the argument.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the newly allocated bit string or &nbsp;NULL in case of error.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The argument is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.

<div class="p"><!----></div>
 
<br /><a 
name="NotAssign+\container42"></a> <font size="+1"><b>NotAssign</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*NotAssign)(BitString&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical NOT of its argument and assigns the result into it. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The argument is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code in case of error.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&lt;16);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.NotAssign(b);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("NOT&nbsp;b&nbsp;=&nbsp;%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111
NOT&nbsp;b&nbsp;=&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="InitializeWith+\container42"></a> <font size="+1"><b>InitializeWith</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*ObjectToBitString)(size_t&nbsp;size,void&nbsp;*p);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The bits starting by the given pointer are copied into a new bit string using the size (in bytes) indicated by the second parameter <font size="+1"><tt>size</tt></font>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The pointer is &nbsp;NULL 

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough resources to finish the operation.

<div class="p"><!----></div>
<b>Returns:</b>A new bit string or &nbsp;NULL if there is an error.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
/*&nbsp;This&nbsp;example&nbsp;changes&nbsp;the&nbsp;sign&nbsp;of&nbsp;a&nbsp;double&nbsp;precision
number&nbsp;by&nbsp;changing&nbsp;its&nbsp;sign&nbsp;bit&nbsp;*/
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;-0.125;&nbsp;/*&nbsp;Number&nbsp;is&nbsp;negative&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b&nbsp;=&nbsp;iBitString.ObjectToBitString(sizeof(double),&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Now&nbsp;set&nbsp;sign&nbsp;to&nbsp;zero,&nbsp;making&nbsp;the&nbsp;number&nbsp;positive&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.SetElement(b,63,0);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.CopyBits(b,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%g\n",d);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
0.125

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Or+\container42"></a> <font size="+1"><b>Or</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Or)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical OR between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of both bitstring pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="OrAssign+\container42"></a> <font size="+1"><b>OrAssign</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*OrAssign)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical OR of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code in case of error.
 
<div class="p"><!----></div>
<br /><a 
name="PopulationCount+\container42"></a> <font size="+1"><b>PopulationCount</b></font> <hr />


<font size=+1><pre>

uintmax_t&nbsp;&nbsp;(*PopulationCount)(BitString&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of 1 bits in the bit string.

<div class="p"><!----></div>
<b>Returns:</b>
The number of set bits in the string.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given argument is &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Print+\container42"></a> <font size="+1"><b>Print</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;size_t&nbsp;(*Print)(BitString&nbsp;*b,size_t&nbsp;bufsiz,unsigned&nbsp;char&nbsp;*out);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Prints into the given buffer the contents of the bitstring <font size="+1"><tt>b</tt></font> without exceeding the length of the given buffer <font size="+1"><tt>bufsiz</tt></font>. The bits will 
be grouped into 4 bits separated by a space. Each group of 8 bits will be separated from the rest by two spaces.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

. The bit string pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The number of characters written to the output string, including the terminating zero. If the output string pointer is &nbsp;NULL , it returns 
the number of characters that would be needed to print the contents of the bitstring.
 
<div class="p"><!----></div>
<br /><a 
name="Reverse+\container42"></a> <font size="+1"><b>Reverse</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Reverse)(BitString&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The bit sequence of the argument is reversed

<div class="p"><!----></div>
<b>Returns:</b>
A new bit string containing the reversed argument.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given argument is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;pos;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b,*c;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Usage:&nbsp;%s&nbsp;&lt;bitstring&#62;\n",argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.StringToBitString(argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Reversing&nbsp;bits&nbsp;of&nbsp;%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;iBitString.Reverse(b);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(c,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Reversing&nbsp;bits&nbsp;of&nbsp;1111&nbsp;1100&nbsp;&nbsp;0000&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111
1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;0000&nbsp;&nbsp;0011&nbsp;1111

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="RemoveAt+\container42"></a> <font size="+1"><b>RemoveAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveAt)(BitString&nbsp;*bitStr,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes the bit at the specified position. If the position is greater than the length of the string the last position will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given bit string pointer is &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A positive number when the bit was removed, a negative error code otherwise. If the bit string is empty the result is zero.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;pos;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;3)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Usage:&nbsp;%s&nbsp;bitstring&nbsp;pos\n",argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.StringToBitString(argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;=&nbsp;atoi(argv[2]);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Erasing&nbsp;bit&nbsp;%d&nbsp;of&nbsp;%s\n",pos,buf);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.EraseAt(b,pos);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Erasing&nbsp;bit&nbsp;2&nbsp;of&nbsp;11&nbsp;&nbsp;1000&nbsp;1110&nbsp;&nbsp;0011&nbsp;1000
1&nbsp;&nbsp;1100&nbsp;0111&nbsp;&nbsp;0001&nbsp;1100

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Set+\container42"></a> <font size="+1"><b>Set</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Set)(BitString&nbsp;*B,size_t&nbsp;start,size_t&nbsp;stop,bool&nbsp;newvalue);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the range of bits delimited by its <i>start</i> and <i>end</i> arguments to the value given by its <i>newvalue</i> argument. If the new
value is different than zero a '1' bit is written, otherwise the bit is set to zero. If the <i>stop</i> argument is bigger than the length of the
bitstring, the end of the string will be used.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The bit string pointer is NULL.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The <i>start</i> argument is bigger or equal to the length of the bitstring.
 
<div class="p"><!----></div>
<br /><a 
name="StringToBitString+\container42"></a> <font size="+1"><b>StringToBitString</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*StringToBitString)(unsigned&nbsp;char&nbsp;*);

</pre></font>
Reads a bitstring from a character string. The character string should contain only the characters '1', '0', space and tab.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The character string pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the new bitstring or &nbsp;NULL if there was an error or the given character string did not contain any '1' or '0'.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Xor+\container42"></a> <font size="+1"><b>Xor</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Xor)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical XOR between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to its result or &nbsp;NULL in case of error.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of both bitstring pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.
 
<div class="p"><!----></div>
<br /><a 
name="XorAssign+\container42"></a> <font size="+1"><b>XorAssign</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*XorAssign)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical XOR of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code in case of error.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Its argument is &nbsp;NULL .

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;The string collection container: istrCollection, iWstrCollection</h2>
<a 
name="istrCollection50"></a><a 
name="iWstrCollection50"></a><a 
name="WstrCollection50"></a>A string collection is a derivation from the Vector container, specialized to hold character strings.

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;The interface</h3>
To avoid unnecessary repetitions in this document here is documented a generic interface.
The word <font size="+1"><tt>ElementType</tt></font> is either <font size="+1"><tt>char</tt></font> for multi-byte strings, or
<font size="+1"><tt>wchar_t</tt></font> for wide character strings. The word <font size="+1"><tt>strCollection</tt></font> in this context means either 

<ul>
<li> a multi-byte string collection using the <font size="+1"><tt>strCollectionInterface</tt></font>
<div class="p"><!----></div>
</li>

<li> a wide character string collection using the <font size="+1"><tt>WstrCollectionInterface</tt></font>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagstrCollectionInterface&nbsp;{
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(strCollection&nbsp;*SC,const&nbsp;char&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(strCollection&nbsp;*s,size_t&nbsp;n,const&nbsp;char&nbsp;**values);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(strCollection&nbsp;*,strCollection&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(strCollection&nbsp;*SC,int&nbsp;(*Applyfn)(char&nbsp;*,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*Back)(const&nbsp;strCollection&nbsp;*str);
&nbsp;&nbsp;&nbsp;struct&nbsp;_Vector&nbsp;*(*CastToArray)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqual)(const&nbsp;strCollection&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;strCollection&nbsp;*right,Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqualScalar)(const&nbsp;strCollection&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*str,Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*str);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*Copy)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;char&nbsp;**(*CopyTo)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*Create)(size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*CreateFromFile)(const&nbsp;char&nbsp;*fileName);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsiz,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;strCollection&nbsp;*SC1,const&nbsp;strCollection&nbsp;*SC2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(strCollection&nbsp;*SC,const&nbsp;char&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(strCollection&nbsp;*SC,const&nbsp;char&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(strCollection&nbsp;*SC,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*FindFirst)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*text);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*FindNext)(const&nbsp;strCollection&nbsp;*SC,&nbsp;const&nbsp;char&nbsp;*text,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;start);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*FindText)(const&nbsp;strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*text);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*FindTextIndex)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*text);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*FindTextPositions)(const&nbsp;strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*text);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*Front)(const&nbsp;strCollection&nbsp;*str);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;strCollection&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;char&nbsp;**(*GetData)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*GetElement)(const&nbsp;strCollection&nbsp;*SC,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*GetRange)(strCollection&nbsp;*SC,&nbsp;size_t&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*IndexIn)(const&nbsp;strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*SearchedString,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*Init)(strCollection&nbsp;*result,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(strCollection&nbsp;*SC,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*InitWithAllocator)(strCollection&nbsp;*c,size_t&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*InitializeWith)(size_t&nbsp;n,&nbsp;char&nbsp;**data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(strCollection&nbsp;*SC,char&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(strCollection&nbsp;*SC,size_t&nbsp;idx,const&nbsp;char&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(strCollection&nbsp;*source,&nbsp;size_t&nbsp;idx,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*newData);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Mismatch)(const&nbsp;strCollection&nbsp;*a1,const&nbsp;strCollection&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*PopBack)(strCollection&nbsp;*,&nbsp;char&nbsp;*result,size_t&nbsp;bufsize);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*PopFront)(strCollection&nbsp;*SC,char&nbsp;*outbuf,size_t&nbsp;buflen);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(strCollection&nbsp;*,const&nbsp;char&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(strCollection&nbsp;*SC,char&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(strCollection&nbsp;*SC,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(strCollection&nbsp;*SC,size_t&nbsp;idx,char&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;strCollection&nbsp;*SC,FILE&nbsp;*stream,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(strCollection&nbsp;*src,&nbsp;const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*SelectCopy)(const&nbsp;strCollection&nbsp;*src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetCapacity)(strCollection&nbsp;*SC,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;StringCompareFn&nbsp;(*SetCompareFunction)(strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringCompareFn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(strCollection&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(strCollection&nbsp;*SC,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;strCollection&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;int&nbsp;(*WriteToFile)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*filename);
}&nbsp;strCollectionInterface;

</pre></font>


     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;API</h3>
Most of the functions present in the interface are exactly like the functions in Vector. Only those that differ will be documented here.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="AddRange+\container52"></a> <font size="+1"><b>AddRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(strCollection&nbsp;*SC,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;*data[]);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds each string of the array of string pointers at the end of the container. It is assumed that "data" points to a contiguous array of string pointers whose size is given by the "n" parameter. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise.  If n is zero nothing is done and no errors are issued, even if the array pointer or the data pointer are &nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer or the data pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The collection is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.


<div class="p"><!----></div>
 <b>Invariants:</b>
The data added is copied and not modified in any way.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

strCollection&nbsp;*SC&nbsp;=&nbsp;istrCollection.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*data[]&nbsp;=&nbsp;{&nbsp;"one","two,"three"};
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;istrCollection.AddRange(SC,3,data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="CastToArray+\container52"></a> <font size="+1"><b>CastToArray</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*CastToArray)(const&nbsp;strCollection&nbsp;*SC);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Converts a string collection into an vector.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.


<div class="p"><!----></div>
 <b>Invariants:</b>
The given collection is not modified in any way.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="CreateFromFile+\container52"></a> <font size="+1"><b>CreateFromFile</b></font> <hr />


<font size=+1><pre>

strCollection&nbsp;*(*CreateFromFile)(const&nbsp;char&nbsp;*fileName);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads the given text file and stores each line in a string of the collection. The end of line characters are discarded.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The fileName pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_NOENT

 The file doesn't exist or can't be opened for reading.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new string collection with the contents of the file. If an error occurs the result is &nbsp;NULL and the current error function (in the 
iError interface) is called.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="FindFirst+\container52"></a> <font size="+1"><b>FindFirst</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*FindFirstText)(const&nbsp;strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;*text);

</pre></font>
 
<div class="p"><!----></div>
  <b>Description:</b> 
Finds the first occurrence of the given text in the string collection. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
Neither the input collection, nor the given text are modified.

<div class="p"><!----></div>
<b>Returns:</b>
The zero based index of the line that contains the given text or the constant 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
if the text is not found.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="FindNext+\container52"></a> <font size="+1"><b>FindNext</b></font> <hr />


<font size=+1><pre>

Iterator&nbsp;*(*Find)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;ElementType&nbsp;*txt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;start);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Starts searching for the given text at the specified line.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection or the text pointer are &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
Neither the input collection, nor the given text are modified in any way.

<div class="p"><!----></div>
<b>Returns:</b>
An iterator that points to the element found or &nbsp;NULL if nothing was found.
 
<div class="p"><!----></div>
<br /><a 
name="FindTextPositions+\container52"></a> <font size="+1"><b>FindTextPositions</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*FindTextPositions)(const&nbsp;strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;*text);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches all occurrences of the given text in the given string collection.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection or the text pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough storage for holding the resulting array.


<div class="p"><!----></div>
 <b>Invariants:</b>
Neither the input collection, nor the given text are modified.

<div class="p"><!----></div>
<b>Returns:</b>
An array list containing a pair of integers for each occurrence containing the zero based position of the line where the text was found and a second number indicating the character index within the line where the searched text occurs.
The result is &nbsp;NULL if there wasn't any occurrences of the searched text in the string collection or an error was detected.
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container52"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

const&nbsp;CHARTYPE&nbsp;*(*Front)(const&nbsp;strCollection&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the first element of the given list or &nbsp;NULL if the collection is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The collection pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The collection is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input collection is not modified. The resulting pointer should not be modified in any way.

<div class="p"><!----></div>
<b>Returns:</b>
The first element or &nbsp;NULL if the collection is empty or an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Init+\container52"></a> <font size="+1"><b>Init</b></font> <hr />


<font size=+1><pre>

strCollection&nbsp;*(*Init)(strCollection&nbsp;*result,&nbsp;size_t&nbsp;startsize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the given string collection to contain at least the number of strings given. Uses the current memory manager.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is no more memory left to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The string collection pointer is &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the initialized string collection or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="InitWithAllocator+\container52"></a> <font size="+1"><b>InitWithAllocator</b></font> <hr />


<font size=+1><pre>

strCollection&nbsp;*(*InitWithAllocator)(strCollection&nbsp;*result,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;startsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the given string collection to contain at least the number of strings given. Uses the given memory manager.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is no more memory left to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The string collection pointer is &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the initialized string collection or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="InsertIn+\container52"></a> <font size="+1"><b>InsertIn</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*InsertIn)(strCollection&nbsp;*dst,&nbsp;size_t&nbsp;pos,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;strCollection&nbsp;*newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the given strCollection into the destination strCollection at the given position. If the position is greater than the actual length of the string collection the new data will be inserted at the end.
 
<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The source or destination pointers are &nbsp;NULL .
 
<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The destination is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The new data is not modified in any way.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;PrintStringCollection(strCollection&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Count&nbsp;%ld,&nbsp;Capacity&nbsp;%ld\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long)istrCollection.Size(AL),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long)istrCollection.GetCapacity(AL));
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;istrCollection.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s&nbsp;",istrCollection.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

static&nbsp;void&nbsp;FillStringCollection(strCollection&nbsp;*&nbsp;AL,int&nbsp;start)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[256];

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;i+start;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(buf,"%g",d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.Add(AL,buf);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*AL&nbsp;=&nbsp;istrCollection.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*AL1&nbsp;=istrCollection.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;FillStringCollection(AL,0);
&nbsp;&nbsp;&nbsp;&nbsp;FillStringCollection(AL1,100);
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.InsertIn(AL,5,AL1);
&nbsp;&nbsp;&nbsp;&nbsp;PrintStringCollection(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}

</pre></font>
The example creates two string collections, fills them with the string representation of the numbers from 0 to 9 and from 100 to 109, then inserts the second collection into the first one at position 5.

<div class="p"><!----></div>
OUTPUT:

<font size=+1><pre>
Count&nbsp;20,&nbsp;Capacity&nbsp;20
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;100&nbsp;101&nbsp;102&nbsp;103&nbsp;104&nbsp;105&nbsp;106&nbsp;107&nbsp;108&nbsp;109&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Mismatch+\container52"></a> <font size="+1"><b>Mismatch</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Mismatch)(const&nbsp;strCollection&nbsp;*a1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;strCollection&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the index of the first element that is different when comparing both collections in the passed pointer <i>mismatch</i>. If one  is shorter than the other the comparison stops
when the last element from the shorter array is compared. The comparison also stops when the first difference is spotted.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any of the arguments is &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input collections are not modified in any way. Both collections could be the same.

<div class="p"><!----></div>
<b>Returns:</b>
If a mismatch is found the result is greater than zero and the <i>mismatch</i> argument will contain the index of the first element that compared 
unequal. This will be always the case for arrays of different length.

<div class="p"><!----></div>
If both arrays are the same length and no differences are found the result is zero and the value pointed to by the 
<i>mismatch</i> argument is one more than the length of the arrays.

<div class="p"><!----></div>
If an error occurs, a negative error code is returned. The <i>mismatch</i> argument contains zero.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
char&nbsp;*table[]&nbsp;=&nbsp;{"String&nbsp;1",&nbsp;"String&nbsp;2","String&nbsp;3","String&nbsp;4",};

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*sc&nbsp;=&nbsp;istrCollection.Create(4);
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*sc2;
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.AddRange(sc,sizeof(table)/sizeof(table[0]),table);
&nbsp;&nbsp;&nbsp;&nbsp;sc2&nbsp;=&nbsp;istrCollection.Copy(sc);
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.ReplaceAt(sc,2,"String456");
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.Mismatch(sc,sc2,&amp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;printf("String&nbsp;collections&nbsp;differ&nbsp;at&nbsp;position&nbsp;%d\n",idx);
}
OUTPUT:
String&nbsp;collections&nbsp;differ&nbsp;at&nbsp;position&nbsp;2

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="PopBack+\container52"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*PopBack)(strCollection&nbsp;*SC,ElementType&nbsp;*buf,size_t&nbsp;buflen);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
If the string collection is not empty, it will copy at most buflen characters into the given buffer. If the buffer pointer is &nbsp;NULL or the length of the buffer is zero it will return the length of the element that would be popped.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
Zero if the collection was empty, a negative error code if an error occurs, or a positive value if the range was erased.
 
<div class="p"><!----></div>
<br /><a 
name="RemoveRange+\container52"></a> <font size="+1"><b>RemoveRange</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*RemoveRange)(strCollection&nbsp;*SC,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes all strings having an index equal or greater than
<font size="+1"><tt><i>start</i></tt></font>
 and less than
<font size="+1"><tt><i>end</i></tt></font>
. If
<font size="+1"><tt><i>end</i></tt></font>
 is greater than the number of elements 
in the collection it will be adjusted to one more than the number of elements. If
<font size="+1"><tt><i>start</i></tt></font>
 is bigger than
<font size="+1"><tt><i>end</i></tt></font>
 the range is still valid and
starts with the value of
<font size="+1"><tt><i>end</i></tt></font>
 and ends with the value of
<font size="+1"><tt><i>start</i></tt></font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
Zero if the string collection is empty. Otherwise returns a positive number for success, a negative error code in case of an error.
 
<div class="p"><!----></div>
<br /><a 
name="SetCompareFunction+\container52"></a> <font size="+1"><b>SetCompareFunction</b></font> <hr />


<font size=+1><pre>

StringCompareFn&nbsp;(*SetCompareFunction)(strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringCompareFn&nbsp;StrCmp);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the function used for comparing two strings to the given one. If the value of the new function is &nbsp;NULL the current value is returned.

<div class="p"><!----></div>
Note that the definition of the <font size="+1"><tt>StringCompareFn</tt></font> differs from the
normal comparison functions used in all other containers. Its definition is as follows:

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*StringCompareFn)(const&nbsp;void&nbsp;**s1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;**s2,CompareInfo&nbsp;*info);

</pre></font>
<a 
name="StringCompareFn52"></a>
The reason for this change is that a string container holds pointers to characters, hence a double indirection is needed by functions like
<font size="+1"><tt>sort</tt></font>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the comparison function.
 
<div class="p"><!----></div>
<br /><a 
name="WriteToFile+\container52"></a> <font size="+1"><b>WriteToFile</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*WriteToFile)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*fileName);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Writes the contents of the given string collection into a file with the given name. If the collection is empty an empty file is created. The resulting file contains a line for each string in the collection.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer or the fileName are &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input collection is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completes, or a negative error code otherwise. If the collection is empty the result is zero.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;The dictionary container: iDictionary</h2>
<a 
name="Dictionary60"></a>

<div class="p"><!----></div>
A dictionary is an associative container that associates a text key with a piece of data. It can be implemented by means of a hash table that uses a hash function to map the key into a restricted integer range, used to index a table. A common usage is to associate some data with a character key,
but it can also be used to just store character keys without any data associated with them. The container is then used just to see if a given key
is stored there or not. In this case the container should be created with object size of zero.

<div class="p"><!----></div>
The interest of hash tables is that the access to objects using the key is very fast. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;The dictionary interface</h3>
This interface (like the string collection container) comes in two flavors: One with keys of 8 bit characters, another with keys in the wide character
set. Both interfaces are identical, except for the keys parameter.
<a 
name="iDictionary61"></a>
This is the interface for the multi-byte character set.

<div class="p"><!----></div>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagDictionaryInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*key,const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Dictionary&nbsp;*Dict,int&nbsp;(*Applyfn)(const&nbsp;char&nbsp;*Key,
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*CastToArray)(const&nbsp;Dictionary&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;Dictionary&nbsp;*dict,const&nbsp;char&nbsp;*key);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Copy)(const&nbsp;Dictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Create)(size_t&nbsp;ElementSize,size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,size_t&nbsp;hint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;Dictionary&nbsp;*d1,const&nbsp;Dictionary&nbsp;*d2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*Key);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Dictionary&nbsp;*d);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*GetKeys)(const&nbsp;Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;double&nbsp;(*GetLoadFactor)(Dictionary&nbsp;*d);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Init)(Dictionary&nbsp;*dict,size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(Dictionary&nbsp;*dict,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*InitWithAllocator)(Dictionary&nbsp;*D,size_t&nbsp;elemsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hint,const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;**Keys,const&nbsp;void&nbsp;*Values);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*key,const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(Dictionary&nbsp;*dst,Dictionary&nbsp;*src);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*&nbsp;(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Dictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(Dictionary&nbsp;*dict,const&nbsp;char&nbsp;*Key,const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;Dictionary&nbsp;*Dict,FILE&nbsp;*stream,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(Dictionary&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Dictionary&nbsp;*Dict,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;HashFunction&nbsp;(*SetHashFunction)(Dictionary&nbsp;*d,HashFunction&nbsp;newFn);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;Dictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;Dictionary&nbsp;*);
}&nbsp;DictionaryInterface;

</pre></font>


<div class="p"><!----></div>
This is the interface for the wide character set.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagWDictionaryInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*key,const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(WDictionary&nbsp;*Dict,int&nbsp;(*Applyfn)(const&nbsp;wchar_t&nbsp;*Key,
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*CastToArray)(const&nbsp;WDictionary&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;WDictionary&nbsp;*dict,const&nbsp;wchar_t&nbsp;*key);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*Copy)(const&nbsp;WDictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*Create)(size_t&nbsp;ElementSize,size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,size_t&nbsp;hint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;WDictionary&nbsp;*d1,const&nbsp;WDictionary&nbsp;*d2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*Key);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;WDictionary&nbsp;*d);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;WstrCollection&nbsp;*(*GetKeys)(const&nbsp;WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;double&nbsp;(*GetLoadFactor)(WDictionary&nbsp;*d);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*Init)(WDictionary&nbsp;*dict,size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(WDictionary&nbsp;*dict,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*InitWithAllocator)(WDictionary&nbsp;*D,size_t&nbsp;elemsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hint,const&nbsp;ContainerAllocator&nbsp;*mm);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;wchar_t&nbsp;**Keys,const&nbsp;void&nbsp;*Values);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(WDictionary&nbsp;*dst,WDictionary&nbsp;*src);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*&nbsp;(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(WDictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(WDictionary&nbsp;*dict,const&nbsp;wchar_t&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;WDictionary&nbsp;*Dict,FILE&nbsp;*stream,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(WDictionary&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(WDictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(WDictionary&nbsp;*Dict,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;WHashFunction&nbsp;(*SetHashFunction)(WDictionary&nbsp;*d,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHashFunction&nbsp;newFn);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;WDictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;WDictionary&nbsp;*);
}&nbsp;WDictionaryInterface;

</pre></font>


<BR CLEAR=LEFT><BR><BR>

<img src="Dictionary.png" alt="Figure">
<BR CLEAR=LEFT><BR><BR>


<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container62"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Dictionary&nbsp;*Dict,char&nbsp;*key,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the container using the given "key" string. It is assumed that "data" points to a contiguous memory area of at least ElementSize bytes.  Both the key and the data are copied into the container. If the size of dictionary data elements is zero the 
<font size="+1"><tt><i>data</i></tt></font>

<div class="p"><!----></div>
argument is ignored and can be &nbsp;NULL .

<div class="p"><!----></div>
If an element exists with the given key, its contents are replaced with the new data. For a different behavior use <font size="+1"><tt>Insert</tt></font> or <font size="+1"><tt>Replace</tt></font>.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The dictionary, or the key pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The dictionary is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation added a new element, zero if the data was written into an existing element, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*dict;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iDictionary.Add(dict,"Interest&nbsp;rate",&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container62"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(Applyfn)(const&nbsp;char&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Will call the given function for each element of the array. The first argument of the callback function receives they key ,the second is a pointer to the element of the Dictionary. The  third argument of the callback is the &#235;xtraArg" argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable function type cast.
If the dictionary is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

  Either the dictionary pointer or Applyfn are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The dictionary is read-only and there is no more memory to allocate the buffer to copy each element.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

static&nbsp;int&nbsp;print(const&nbsp;char&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pResult)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p&nbsp;=&nbsp;pElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s:&nbsp;%g\n",key,*p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;main(void)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*dict&nbsp;=&nbsp;iDictionary.Create(sizeof(double),5);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Add(dict,"First&nbsp;item",&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Add(dict,"Second&nbsp;item",&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Apply(dict,print,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>

<div class="p"><!----></div>
Output should be:

<font size=+1><pre>
First&nbsp;item:&nbsp;2
Second&nbsp;item:&nbsp;3

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CastToArray+\container62"></a> <font size="+1"><b>CastToArray</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*CastToArray)(Dictionary&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a vector containing all the elements in the dictionary (without any keys). If the element size of the dictionary is zero the result is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

  The dictionary pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The creation of the resulting vector failed or the dictionary is read-only and there is no more memory to allocate 
the buffer to copy each element.

<div class="p"><!----></div>
<b>Returns:</b>The new vector or &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container62"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Dictionary&nbsp;*dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The dictionary header is not destroyed, and its contents will be the same as when it was initially created. It is an error to use this function when there are still active iterators for the container.

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m&nbsp;=&nbsp;iDictionary.Clear(Dict);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Contains+\container62"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*Key);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns one if the given key is stored in the dictionary, zero otherwise.  If an error occurs it returns a negative error code.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either Dict or Key are &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*dict;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iDictionary.Contains(dict,"Item&nbsp;1");

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container62"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Copy)(Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
A shallow copy of the given dictionary is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the allocator in the source dictionary.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a copy of the given dictionary or &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*newDict,*Old;
&nbsp;&nbsp;&nbsp;&nbsp;newDict&nbsp;=&nbsp;iDictionary.Copy(Old);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CopyElement+\container62"></a> <font size="+1"><b>CopyElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*Key,&nbsp;void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
A shallow copy of the given dictionary element is performed. 
Only element size bytes will be copied. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the allocator in the source dictionary. If the element size is zero nothing is copied and the result is zero.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, zero if the element size of the dictionary is zero, or a negative error code.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iDictionary.CopyElement(Dict,"Key",outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;//&nbsp;handle&nbsp;error
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;nothing&nbsp;was&nbsp;copied
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;//&nbsp;Use&nbsp;outbuf&nbsp;data&nbsp;here

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container62"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Create)(size_t&nbsp;ElementSize,size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,size_t&nbsp;hint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator);

</pre></font>
<a 
name="CreateWithAllocator62"></a>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new dictionary with the given element size and with a table big enough to store <font size="+1"><tt>hint</tt></font> entries. The <font size="+1"><tt>Create</tt></font> function
uses the current memory manager as the allocator for the new dictionary. <font size="+1"><tt>CreateWithAllocator</tt></font> uses the given allocator object.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the new dictionary or &nbsp;NULL if there is not enough memory to create it.
 
<div class="p"><!----></div>
<br /><a 
name="DeleteIterator+\container62"></a> <font size="+1"><b>DeleteIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;DeleteIterator(Iterator&nbsp;*it);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims the memory used by the given iterator object

<div class="p"><!----></div>
<b>Returns:</b>
Integer smaller than zero with error code or a positive number when the operation completes.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is &nbsp;NULL .

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Equal+\container62"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(Dictionary&nbsp;*d1,Dictionary&nbsp;*d2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares the given dictionaries using their comparison function. If the dictionaries differ in their size, flags, or hash functions they compare unequal. If any of their elements differ, they compare unequal.
If both d1 and d2 are &nbsp;NULL they compare equal. If Both d1 and d2 are empty they compare equal.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
The result is one if the dictionaries are equal, zero otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container62"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*key);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the dictionary the element that matches the given key.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value that indicates that a match was found and the element was removed. If no element matched the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
. If an error occurs, a negative error code is returned.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Erase(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("2.3&nbsp;erased|n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("No&nbsp;element&nbsp;with&nbsp;value&nbsp;2.3&nbsp;present\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("error&nbsp;code&nbsp;%d\n",r);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container62"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Dictionary&nbsp;*dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the dictionary, including the array header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The dictionary is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed. A negative error code indicates failure.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iDictionary.Finalize(AL);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="GetAllocator+\container62"></a> <font size="+1"><b>GetAllocator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;(*GetAllocator)(Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the memory manager of the given dictionary. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is &nbsp;NULL .

<div class="p"><!----></div>

<b>Returns:</b>
The memory manager object or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetElementSize+\container62"></a> <font size="+1"><b>GetElementSize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the size of the elements stored in the given dictionary. Note that this value can be different than the value given to the creation function because of alignment requirements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is &nbsp;NULL .

<div class="p"><!----></div>

<b>Returns:</b>
The element size or zero if an error.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iDictionary.GetElementSize(Dict);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetElement+\container62"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*GetElement)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*key);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the element at the given index, or &nbsp;NULL if the operation failed.  This function will return &nbsp;NULL if the dictionary is read only.

<div class="p"><!----></div>
Use the CopyElement function to get a read/write copy of an element of the dictionary.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given dictionary pointer or the key are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

    The array is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d&nbsp;=&nbsp;iDictionary.GetElement(Dict,"Index");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="GetFlags+\container62"></a> <font size="+1"><b>GetFlags</b></font> <hr />


<font size=+1><pre>

unsigned&nbsp;(*GetFlags)(Dictionary&nbsp;*dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the flags element of the given dictionary.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given dictionary pointer is &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="GetLoadFactor+\container62"></a> <font size="+1"><b>GetLoadFactor</b></font> <hr />


<font size=+1><pre>

double&nbsp;(*GetLoadFactor)(Dictionary&nbsp;*dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements divided by the size of the table.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given dictionary pointer is &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="InsertIn+\container62"></a> <font size="+1"><b>InsertIn</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*InsertIn)(Dictionary&nbsp;*dst,Dictionary&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts all keys of the
<font size="+1"><tt><i>src</i></tt></font>
dictionary into the
<font size="+1"><tt><i>dst</i></tt></font>
dictionary. If the container changes during the insertion process 
the operation aborts.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given dictionary pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

. There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if successful, zero if the container changed during the operation, or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Init+\container62"></a> <font size="+1"><b>Init</b></font> <hr />


<font size=+1><pre>

	Dictionary&nbsp;*(*Init)(Dictionary&nbsp;*Dict,size_t&nbsp;elementsize,size_t&nbsp;hint);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the indicated storage for use asa dictionary object. This procedure is completely equivalent to <font size="+1"><tt>Create</tt></font> with the difference
that there is no allocation done for the dictionary header. Uses the current memory manager for the allocations of the slot table.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to its first argument if successful or &nbsp;NULL if there is no memory to complete the operation.
 
<div class="p"><!----></div>
<br /><a 
name="InitializeWith+\container62"></a> <font size="+1"><b>InitializeWith</b></font> <hr />


<font size=+1><pre>

Dictionary&nbsp;*(*InitializeWith)(size_t&nbsp;elemSize,&nbsp;size_t&nbsp;n,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;**keys,void&nbsp;*Values);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Construct a dictionary from the given keys and values. The <font size="+1"><tt>Values</tt></font> argument should be either &nbsp;NULL or a valid pointer to <font size="+1"><tt>n</tt></font> elements
of size <font size="+1"><tt>elementSize</tt></font>. The <font size="+1"><tt>keys</tt></font> argument should be a table of string pointers with each string associated with each element of the
<font size="+1"><tt>Values</tt></font> table.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The keys argument is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

. There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>The new dictionary object or &nbsp;NULL if an error occurs
 
<div class="p"><!----></div>
<br /><a 
name="InitWithAllocator+\container62"></a> <font size="+1"><b>InitWithAllocator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;	Dictionary&nbsp;*(*InitWithAllocator)(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elementsize,&nbsp;size_t&nbsp;hint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the indicated storage for use as a dictionary object. This procedure is completely equivalent to <font size="+1"><tt>CreateWithAllocator</tt></font> with the difference
that there is no allocation done for the dictionary header. Uses the given memory manager for the allocations of the slot table.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to its first argument if successful or &nbsp;NULL if there is no memory to complete the operation.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Insert+\container62"></a> <font size="+1"><b>Insert</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Insert)(Dictionary&nbsp;*Dict,&nbsp;const&nbsp;char&nbsp;*key,void&nbsp;*Data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the new key and its corresponding data into the given dictionary. If the key is already present, nothing is changed. This contrasts with the 
behavior of <font size="+1"><tt>Add</tt></font> that will replace an existing key.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any of the given pointers is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

    The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A positive value if the key was inserted, zero if the key was already present, or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Load+\container62"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;Dictionary&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads a dictionary previously saved with the Save function from the stream pointed to by stream. If readFn is not &nbsp;NULL , it will be used to read each 
element. The &#228;rg" argument will be passed to the read function. If the read function is &nbsp;NULL , this argument is ignored and a default read function is 
used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new dictionary or &nbsp;NULL if the operation could not be completed. Note that the function pointers in the array are NOT saved, nor any special allocator 
that was in the original dictionary. Those values will be the values by default. To rebuild the original state the user should replace the pointers 
again in the new array.

<div class="p"><!----></div>
 
<br /><a 
name="NewIterator+\container62"></a> <font size="+1"><b>NewIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates and initializes a new iterator object to iterate this dictionary. The exact sequence is implementation defined but it will be the same for 
the same dictionary with the same number of elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
If no more memory is available it returns &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new iterator or &nbsp;NULL if there is no more memory left.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iDictionary.NewIterator(Dict);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(d=it-&#62;GetFirst(it);&nbsp;d&nbsp;!=&nbsp;NULL;&nbsp;d&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;val&nbsp;=&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;the&nbsp;value&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.DeleteIterator(it);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SetDestructor+\container62"></a> <font size="+1"><b>SetDestructor</b></font> <hr />


<font size=+1><pre>

DestructorFunction&nbsp;SetDestructor(Dictionary&nbsp;*d,DestructorFunction&nbsp;fn);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Sets the destructor function to its given argument. If the function argument is &nbsp;NULL nothing is changed and the call is interpreted as 
a query since the return value is the current value of the destructor function. If the dictionary argument is &nbsp;NULL , the result is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the destructor.

<div class="p"><!----></div>
 
<br /><a 
name="SetHashFunction+\container62"></a> <font size="+1"><b>SetHashFunction</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*SetHashFunction)(Dictionary&nbsp;*dict,HashFunction&nbsp;newFn);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> This function is both a query function  and a function to change the hash function used by the given dictionary.


<ul>
<li> If the dictionary pointer is &nbsp;NULL returns the value of the default hash function used by the library at startup.
<div class="p"><!----></div>
</li>

<li> If the <font size="+1"><tt>newFn</tt></font> parameter is &nbsp;NULL it returns the hash function used by the given dictionary without modifying it.
<div class="p"><!----></div>
</li>

<li> Otherwise it sets the hash function in the given dictionary to the new one, returning the value of the old one.

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
 
<br /><a 
name="Size+\container62"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the dictionary or  SIZE_MAX if the dictionary pointer is &nbsp;NULL .

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given array pointer or the key are &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elem&nbsp;=&nbsp;iDictionary.Size(Dict);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Save+\container62"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;Dictionary&nbsp;*D,&nbsp;FILE&nbsp;*out,&nbsp;SaveFunction&nbsp;Fn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given dictionary are saved into the given stream. If the save function pointer is not &nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The dictionary pointer or the stream pointer are &nbsp;NULL .
EOF A disk input/output error occurred.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*outFile;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iDictionary.Save(Dict,outFile,NULL,NULL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container62"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the dictionary, including the header, and all data stored in the dictionary, including the size of the dictionary header.
If Dict is &nbsp;NULL , the result is the size of the <font size="+1"><tt>Dictionary</tt></font> structure.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the dictionary or the size of the Dictionary structure if the argument is &nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;size&nbsp;=&nbsp;iDictionary.Sizeof(Dict);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="SetErrorFunction+\container62"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

ErrorFunction&nbsp;(*SetErrorFunction)(Dictionary&nbsp;*dict,ErrorFunction&nbsp;efn);&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current error function  for the given dictionary with the new error function if the
<font size="+1"><tt><i>ErrorFunction</i></tt></font>
parameter is 
different from &nbsp;NULL . If the
<font size="+1"><tt><i>dict</i></tt></font>
parameter is &nbsp;NULL the function returns the value of the current default error function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The dictionary pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The dictionary is read only and the function argument is not &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the error function or &nbsp;NULL if there is an error.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container62"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Dictionary&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the dictionary. If the argument is &nbsp;NULL the result is zero.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elem&nbsp;=&nbsp;iDictionary.Size(d);

</pre></font>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;The TreeMap interface: iTreeMap</h2>
<a 
name="TreeMap70"></a>
<a 
name="iTreeMap70"></a>The tree map container uses a tree to associate  keys to values. Trees are extremely efficient data structures that allow access to millions
of items with a few comparisons. Disadvantages include a greater overhead than other containers, and a complex machinery to maintain
them.

<div class="p"><!----></div>
This associative container is special in that it contains no separate key, the elements themselves are the key. Obviously they need imperatively 
a comparison function, and that comparison function could use some parts of the stored object as a key, but that is transparent to the interface.

<div class="p"><!----></div>
An essential point in this container is the comparison function. Since all insertions searches and deletions from/to the tree are done using that
function, it is essential that is defined correctly. Like all other comparison functions it can receive an extra argument that conveys some kind
of context to it. This implies that functions like 'Add' have an extra argument to be able to pass this context to the comparison function.

      <h4><a name="tth_sEc7.0.1">
7.0.1</a>&nbsp;&nbsp;The comparison function must be consistent</h4>
It is important to stress that for this container it is <b>essential</b> that the comparison function returns always the <b>same</b> result for
two given elements. The context passed through this auxiliary arguments must not be used to change the result of the element comparison according
to some external factor. Any inconsistency in the comparison function will destroy completely the whole container and the user will be unable
to retrieve the data stored or (worst) retrieve the wrong data.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;The interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagTreeMapInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(TreeMap&nbsp;*ST,&nbsp;void&nbsp;*Data,void&nbsp;*ExtraArgs);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(TreeMap&nbsp;*ST,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Applyfn)(const&nbsp;void&nbsp;*data,void&nbsp;*arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*Copy)(TreeMap&nbsp;*src);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*CreateWithAllocator)(size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*Create)(size_t&nbsp;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(TreeMap&nbsp;*ST);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(TreeMap&nbsp;*ST);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(TreeMap&nbsp;*ST,void&nbsp;*element,void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(TreeMap&nbsp;*tree,&nbsp;void&nbsp;*element,void&nbsp;*ExtraArgs);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(TreeMap&nbsp;*t1,&nbsp;TreeMap&nbsp;*t2);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(TreeMap&nbsp;*ST);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*Find)(TreeMap&nbsp;*tree,void&nbsp;*element,void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(TreeMap&nbsp;*d);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,&nbsp;size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*Elements);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(TreeMap&nbsp;*RB,&nbsp;const&nbsp;void&nbsp;*Data,&nbsp;void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(TreeMap&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;loadFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(TreeMap&nbsp;*src,FILE&nbsp;*stream,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(TreeMap&nbsp;*ST,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(TreeMap&nbsp;*Tree,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(TreeMap&nbsp;*ST,&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(TreeMap&nbsp;*ST,&nbsp;unsigned&nbsp;flags);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(TreeMap&nbsp;*ST);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(TreeMap&nbsp;*ST);&nbsp;&nbsp;
}&nbsp;TreeMapInterface;

</pre></font>
All the above functions were described for the sequential containers and their syntax is here the same.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Hash Table: iHashTable</h2>
<a 
name="HashTable80"></a>Hash table is a similar container as dictionary, but allows for more features at the expense of a slightly more complicated interface. 
Keys aren't restricted to zero terminated strings but can be any kind of data. 
The table resizes itself as it grows.
Merging two hash tables

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;The interface</h3>
<a 
name="iHashTable81"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagHashTableInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(HashTable&nbsp;*HT,const&nbsp;void&nbsp;*key,size_t&nbsp;klen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(HashTable&nbsp;*HT,int&nbsp;(*Applyfn)(void&nbsp;*Key,size_t&nbsp;klen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*data,void&nbsp;*arg),void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;HashTable&nbsp;*ht,const&nbsp;void&nbsp;*Key,size_t&nbsp;klen);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Copy)(const&nbsp;HashTable&nbsp;*Orig,Pool&nbsp;*pool);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Create)(size_t&nbsp;ElementSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(HashTable&nbsp;*HT,const&nbsp;void&nbsp;*key,size_t&nbsp;klen);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;HashTable&nbsp;*HT,const&nbsp;void&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;klen);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Init)(HashTable&nbsp;*ht,size_t&nbsp;ElementSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(HashTable&nbsp;*SC,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Merge)(Pool&nbsp;*p,&nbsp;const&nbsp;HashTable&nbsp;*overlay,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*base,&nbsp;void&nbsp;*&nbsp;(*merger)(Pool&nbsp;*p,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*key,&nbsp;size_t&nbsp;klen,&nbsp;const&nbsp;void&nbsp;*h1_val,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*h2_val,&nbsp;const&nbsp;void&nbsp;*data),&nbsp;const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(HashTable&nbsp;*);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Overlay)(Pool&nbsp;*p,&nbsp;const&nbsp;HashTable&nbsp;*overlay,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*base);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(HashTable&nbsp;*HT,const&nbsp;void&nbsp;*key,&nbsp;size_t&nbsp;klen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*val);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(HashTable&nbsp;*HT,size_t&nbsp;newSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;HashTable&nbsp;*HT,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Search)(HashTable&nbsp;*ht,int&nbsp;(*Comparefn)(void&nbsp;*rec,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*key,size_t&nbsp;klen,const&nbsp;void&nbsp;*value),&nbsp;void&nbsp;*rec);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(HashTable&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(HashTable&nbsp;*HT,ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(HashTable&nbsp;*HT,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;GeneralHashFunction&nbsp;(*SetHashFunction)(HashTable&nbsp;*ht,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GeneralHashFunction&nbsp;hf);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;HashTable&nbsp;*ht);
}&nbsp;HashTableInterface;

</pre></font>


     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container82"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Add)(HashTable&nbsp;*ht,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;keyLength,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the container using the given "key" string. It is assumed that "data" points to a contiguous memory area of at least ht-&#62;ElementSize bytes.  Both the key and the data are copied into the container.

<div class="p"><!----></div>
If an element exists with the given key, its contents are replaced with the new data.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table, the key or the data pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

: The hash table is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation added a new element, zero if the data was written into an existing element, or a negative error code if an error occurred.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

HashTable&nbsp;*ht;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iHashTable.Add(ht,"Interest&nbsp;rate",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strlen("Interest&nbsp;rate"),&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Apply+\container82"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(HashTable&nbsp;*ht,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(Applyfn)(const&nbsp;char&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;keyLength,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Apply will call the given function for each element of the array. The first argument of the callback function receives they key ,the second is the length of the key. The third is a pointer to one element of the table. The fourth argument of the callback is the &#235;xtraArg" argument that the Apply function receives and passes to the callback. This way some context can be passed to the callback, and from one element to the next.

<div class="p"><!----></div>
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable function type cast.

<div class="p"><!----></div>
If the dictionary is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

  Either the hash table pointer or Applyfn are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The hash table is read-only and there is no more memory to allocate the buffer to copy each element.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

static&nbsp;int&nbsp;print(const&nbsp;char&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pResult)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p&nbsp;=&nbsp;pElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s:&nbsp;%g\n",key,*p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;main(void)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*dict&nbsp;=&nbsp;iDictionary.Create(sizeof(double),5);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Add(dict,"First&nbsp;item",&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Add(dict,"Second&nbsp;item",&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Apply(dict,print,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
Output&nbsp;should&nbsp;be:
First&nbsp;item:&nbsp;2
Second&nbsp;item:&nbsp;3

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container82"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(HashTable&nbsp;*ht);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The hash table header is not destroyed, and its contents will be the same as it was when initially created. It is an error to use this function when there are still active iterators for the container.

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The hash table is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

HashTable&nbsp;*ht;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m&nbsp;=&nbsp;iHashTable.Clear(ht);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Copy+\container82"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Copy)(const&nbsp;HashTable&nbsp;*Orig,Pool&nbsp;*pool);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the given hash table using the given pool. If "pool" is &nbsp;NULL ,the pool of the given hash table will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container82"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Create)(size_t&nbsp;ElementSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new hash table and initializes all fields. The table will use the current memory manager for its pool.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is zero or bigger than the maximum size the implementation supports.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
 
<br /><a 
name="DeleteIterator+\container82"></a> <font size="+1"><b>DeleteIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Releases the memory used by the given iterator.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container82"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(HashTable&nbsp;*HT,void&nbsp;*key,size_t&nbsp;keyLength);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the hash table the element with the given key.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table parameter or the key pointer are &nbsp;NULL , or the keyLength is zero.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, a negative error code otherwise.

<div class="p"><!----></div>
Finalize
Synopsis:
    int (*Finalize)(HashTable *HT);
Description:
Releases all memory used by the hash table and destroys the hash table header itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is &nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="GetElement+\container82"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*GetElement)(const&nbsp;HashTable&nbsp;*H,const&nbsp;void&nbsp;*Key,size_t&nbsp;keyLen);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the given hash table element. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table parameter or the key pointer are &nbsp;NULL , or the keyLen parameter is zero.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the element or &nbsp;NULL if no element with the specified key exists.

<div class="p"><!----></div>
 
<br /><a 
name="GetFlags+\container82"></a> <font size="+1"><b>GetFlags</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;HashTable&nbsp;*HT);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns an unsigned integer with the state of the table.

<div class="p"><!----></div>
 
<br /><a 
name="Load+\container82"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;HashTable&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads a table previously saved with the Save function from the stream pointed to by stream. If readFn is not &nbsp;NULL , it will be used to read each element. The &#228;rg" argument will be passed to the read function. If the read function is &nbsp;NULL , this argument is ignored and a default read function is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new table or &nbsp;NULL if the operation could not be completed. Note that the function pointers in the array are NOT saved in most implementations, nor any special allocator that was in the original table. In most implementations those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new table.

<div class="p"><!----></div>
 
<br /><a 
name="Merge+\container82"></a> <font size="+1"><b>Merge</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Merge)(Pool&nbsp;*p,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*overlay,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*base,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*&nbsp;(*merger)(Pool&nbsp;*p,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;keyLength,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*h1_val,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*h2_val,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Merge two hash tables into one new hash table. If the same key is present in both tables, call the supplied merge function to produce a merged value for the key in the new table. Both hash tables must use the same hash function. 
The arguments should be:

<ol type="1">
<li>The pool to use when allocating memory. If &nbsp;NULL , the pool of the "base" hash table will be used.
<div class="p"><!----></div>
</li>

<li>
The first table to be used in the merge.
<div class="p"><!----></div>
</li>

<li>
The second table
<div class="p"><!----></div>
</li>

<li>
An argument to pass to the merger function.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
 
<br /><a 
name="NewIterator+\container82"></a> <font size="+1"><b>NewIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(HashTable&nbsp;*HT);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates and initializes a new iterator object to iterate this table. The exact sequence of each object returned is implementation defined but it will be the same for the same dictionary with the same number of elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new iterator or &nbsp;NULL if the operation couldn't be completed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

HashTable&nbsp;*HT;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iHashTable.NewIterator(HT);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(d=it-&#62;GetFirst(it);&nbsp;d&nbsp;!=&nbsp;NULL;&nbsp;d&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;val&nbsp;=&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;the&nbsp;value&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iHashTable.DeleteIterator(it);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Overlay+\container82"></a> <font size="+1"><b>Overlay</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Overlay)(Pool&nbsp;*p,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*overlay,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*base);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies overlay into base. If conflicts arise, the data in base will be copied in the result.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of the arguments is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
 
<br /><a 
name="Resize+\container82"></a> <font size="+1"><b>Resize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(HashTable&nbsp;*HT,size_t&nbsp;newSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Will resize the given hash table to a new size. If the given new size is zero, the new size is implementation defined, and equal to the amount when automatic resizing occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation completed, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Replace+\container82"></a> <font size="+1"><b>Replace</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;(*Replace)(HashTable&nbsp;*HT,&nbsp;const&nbsp;void&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;keyLength,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Will replace the contents of the given element if found.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table pointer, the key or the replacement data are &nbsp;NULL , or the keyLength is zero.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element was replaced or zero if the element wasn't found. If the operation didn't complete a negative error code is returned.

<div class="p"><!----></div>
 
<br /><a 
name="Save+\container82"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;HashTable&nbsp;*HT,&nbsp;FILE&nbsp;*out,&nbsp;SaveFunction&nbsp;Fn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given table are saved into the given stream. If the save function pointer is not &nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer or the stream pointer are &nbsp;NULL .

<div class="p"><!----></div>
 EOF A disk input/output error occurred.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

HashTable&nbsp;*HT;
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*outFile;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iHashTable.Save(HT,outFile,NULL,NULL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="SetErrorFunction+\container82"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

ErrorFunction&nbsp;(*SetErrorFunction)(HashTable&nbsp;*HT,ErrorFunction&nbsp;fn);&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current error function  for the given table with the new error function if the
<font size="+1"><tt><i>ErrorFunction</i></tt></font>
parameter is different from &nbsp;NULL . If 
the
<font size="+1"><tt><i>HT</i></tt></font>
parameter is &nbsp;NULL the function returns the value of the current default error function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The table pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The table is read only and the function argument is not &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the error function or &nbsp;NULL if there is an error.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container82"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;HashTable&nbsp;*HT);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the given table.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The table pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The number of elements stored in the table

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container82"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;HashTable&nbsp;*HT);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of bytes of storage used in the given table including the size of the elements stored in it.
If HT is &nbsp;NULL the result is the size of the HashTable header.

<div class="p"><!----></div>
<b>Returns:</b>
The number of elements stored in the table or the size of the HashTable header if the HT pointer is &nbsp;NULL .

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Queues: iQueue</h2>
<a 
name="Queue90"></a>Queues are a type of container adaptors, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other.

<div class="p"><!----></div>
The sample implementation shows how to implement this container as an &#228;daptor" container, i.e. based on another container. The implementation uses a linked list to implement a queue
<a href="#tthFtNtAEF" name="tthFrefAEF"><sup>45</sup></a>.

     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagQueueInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Back)(Queue&nbsp;*Q,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Queue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;Queue&nbsp;*(*Create)(size_t&nbsp;elementSize);
&nbsp;&nbsp;&nbsp;Queue&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Dequeue)(Queue&nbsp;*Q,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Enqueue)(Queue&nbsp;*Q,&nbsp;void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Queue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Front)(Queue&nbsp;*Q,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*GetData)(Queue&nbsp;*q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(Queue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Queue&nbsp;*Q);
}&nbsp;QueueInterface;

</pre></font>


     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;The API</h3>
All methods are exactly like the ones in other containers except for Enqueue, that is equivalent to &#196;dd" since adds one element at the end of the container, and Dequeue, that is the same as PopFront, i.e. pops the first element of the container.
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container92"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;(*Front)(Queue&nbsp;*Q,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the contents of the first element in the given memory area that should be at least the size of the element size of the queue. Note that nothing is changed, and the first element is not erased from the container.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number for success, zero if the queue is empty or a negative error code.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The Queue pointer is &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Back+\container92"></a> <font size="+1"><b>Back</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;(*Back)(Queue&nbsp;*Q,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the contents of the last element in the given memory area that should be at least the size of the element size of the queue. Note that nothing is changed, and the last element is not erased from the container.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number for success, zero if the queue is empty or a negative error code.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The Queue pointer is &nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="GetData+\container92"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*GetData)(Queue&nbsp;*q);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Queues are based on the list container. It is not necessary to duplicate all the list functions in the queue interface: this function allows you to access the underlying list and use all the list specific APIs with it.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the list container or &nbsp;NULL if the queue pointer passed is &nbsp;NULL .

<div class="p"><!----></div>

 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Deque: iDeque</h2>
<a 
name="Deque100"></a>
Deque (usually pronounced like "deck") is an irregular acronym of double-ended queue. Double-ended queues are a kind of sequence containers. As such, their elements are ordered following a strict linear sequence.
Deques may be implemented by specific libraries in different ways, but in all cases they allow for adding and retrieving elements at both ends, with storage always handled automatically (expanding and contracting as needed). 

<div class="p"><!----></div>
Operations to insert and retrieve elements in the middle are not provided because if users need a plain sequential container they can use one. Individual implementation can offer those if they think it is useful. This differs from the C++ implementation.

<div class="p"><!----></div>
Here is a little table with a Rosetta stone for deque:

<div class="p"><!----></div>
<font size="-2">
<table>
<tr><td align="left">C </td><td align="left">Ada </td><td align="left">C++ </td><td align="left">Java </td><td align="left">Perl </td><td align="left">PHP </td><td align="left">Python 
</td></tr>
<tr><td align="left"></td></tr>
<tr><td align="left">PushBack </td><td align="left">Append </td><td align="left">push_back </td><td align="left">offerLast </td><td align="left">push </td><td align="left">array_push </td><td align="left">append 
</td></tr>
<tr><td align="left">PushFront </td><td align="left">Prepend </td><td align="left">push_front </td><td align="left">offerFirst </td><td align="left">unshift </td><td align="left">array_unshift </td><td align="left">appendleft 
</td></tr>
<tr><td align="left">PopBack </td><td align="left">Delete_Last </td><td align="left">pop_back </td><td align="left">pollLast </td><td align="left">pop </td><td align="left">array_pop </td><td align="left">pop 
</td></tr>
<tr><td align="left">PopFront </td><td align="left">Delete_First </td><td align="left">pop_front </td><td align="left">pollFirst </td><td align="left">shift </td><td align="left">array_shift </td><td align="left">popleft 
</td></tr>
<tr><td align="left">Back </td><td align="left">Last_Element </td><td align="left">back </td><td align="left">peekLast </td><td align="left">$array[-1] </td><td align="left">end </td><td align="left"> &lt; obj &gt; [-1]  
</td></tr></table>

</font>

<div class="p"><!----></div>
Some functions that the C++ interface provides like is_empty() can be obtained in this implementation simply by invoking:

<font size=+1><pre>
iDeque.Size(deque)&nbsp;==&nbsp;0

</pre></font>

     <h3><a name="tth_sEc10.1">
10.1</a>&nbsp;&nbsp;Interface</h3>
The interface iDeque is as follows:
<a 
name="iDeque101"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagDequeInterface&nbsp;{
&nbsp;&nbsp;&nbsp;void&nbsp;(*Apply)(Deque&nbsp;*Q,int&nbsp;(*Applyfn)(void&nbsp;*,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Back)(Deque&nbsp;*d,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Deque&nbsp;*Q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Contains)(Deque&nbsp;*&nbsp;d,&nbsp;void*&nbsp;item);
&nbsp;&nbsp;&nbsp;Deque&nbsp;*(*Copy)(Deque&nbsp;*d);
&nbsp;&nbsp;&nbsp;Deque&nbsp;*(*Create)(size_t&nbsp;elementSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(Deque&nbsp;*d1,Deque&nbsp;*d2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Deque&nbsp;*&nbsp;d,&nbsp;const&nbsp;void*&nbsp;item);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(Deque&nbsp;*&nbsp;d,&nbsp;const&nbsp;void*&nbsp;item);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Deque&nbsp;*Q);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Front)(Deque&nbsp;*d,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(Deque&nbsp;*Q);
&nbsp;&nbsp;&nbsp;Deque&nbsp;*(*Init)(Deque&nbsp;*d,size_t&nbsp;elementSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(Deque&nbsp;*dc,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;Deque&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Deque&nbsp;*Deq);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Deque&nbsp;*d,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(Deque&nbsp;*d,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(Deque&nbsp;*Q,const&nbsp;void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(Deque&nbsp;*Q,&nbsp;void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(Deque&nbsp;*&nbsp;d);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;Deque&nbsp;*d,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(Deque&nbsp;*Q,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Deque&nbsp;*d,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Deque&nbsp;*Q,unsigned&nbsp;newFlags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(Deque&nbsp;*Q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Deque&nbsp;*d);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(Deque&nbsp;*);
}&nbsp;DequeInterface;

</pre></font>


<div class="p"><!----></div>
The deque container can be implemented as an adaptor container, for instance based on a double linked list or in an vector. In any case the underlying container interface is not visible.
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container101"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;(*Apply)(Deque&nbsp;*d,int&nbsp;(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Will call the given function for each element. The first argument of the callback function receives an element of the array. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the array is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either the deque or Applyfn are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The list is read-only and there is no more memory to allocate the buffer to copy each element.
 
<div class="p"><!----></div>
<br /><a 
name="Back+\container101"></a> <font size="+1"><b>Back</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Back)(Deque&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the last element stored in the Deque d.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container101"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*Clear)(Deque&nbsp;*Q);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all elements stored in the queue and reclaims the memory used. The Deque object itself is not destroyed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Contains+\container101"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;(*Contains)(Deque&nbsp;*&nbsp;d,&nbsp;void*&nbsp;item);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches the deque for the given data, returning its (index one based) position or zero if not found. 
Errors

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The deque pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The index of element or zero if not found.
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container101"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Deque&nbsp;&nbsp;*(*Copy)(Deque&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a copy of the given deque. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new container or &nbsp;NULL if the operation did not complete.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container101"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Deque&nbsp;&nbsp;*(*Create)(size_t&nbsp;elementSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new Deque container using &#235;lementSize" as the size that each element will have.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The elementSize parameter is zero or bigger than what the implementation supports.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new container or &nbsp;NULL if the operation did not complete.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Deque&nbsp;*d&nbsp;=&nbsp;iDeque.Create(sizeof(myType));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Equal+\container101"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(Deque&nbsp;*d1,Deque&nbsp;*d2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares the given deques using their comparison function. If they differ in their size, flags, or compare functions they compare unequal. If any of their elements differ, they compare unequal.
If both d1 and d2 are &nbsp;NULL they compare equal. If both are empty, they compare equal.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
The result is one if the deques are equal, zero otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container101"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Front)(Deque&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the first element stored in the Deque d.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container101"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Deque&nbsp;*&nbsp;d,&nbsp;void*&nbsp;item);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases the first occurrence of the given element from the container if found, starting from the front.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer or the item pointer are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the item was found and erased, zero if the item wasn't found, or a negative error code if the operation did not complete.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container101"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Deque&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the container erasing all elements, if any. Then it destroys the container object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, a negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetFlags+\container101"></a> <font size="+1"><b>GetFlags</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(Deque&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the state of the flags. If the implementation doesn't support this field this function always returns zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The state of the flags field. 

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Load+\container101"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;Deque&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads a deque previously saved with the Save function from the stream pointed to by stream. If readFn is not &nbsp;NULL , it will be used to read each element. The &#228;rg" argument will be passed to the read function. If the read function is &nbsp;NULL , this argument is ignored and a default read function is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new deque or &nbsp;NULL if the operation could not be completed. Note that the function pointers in the deque are NOT saved in most implementations, nor any special allocator that was in the original table. In most implementations those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new table.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="PopBack+\container101"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Deque&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the last element stored in the Deque d, then erases the element from the deque.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="PopFront+\container101"></a> <font size="+1"><b>PopFront</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(Deque&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the first element stored in the Deque d, then erases the element from the deque.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="PushBack+\container101"></a> <font size="+1"><b>PushBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(Deque&nbsp;*d,void&nbsp;*element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the end of the deque. It is assumed that &#235;lement" points to a contiguous memory area of at least ElementSize bytes.  

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque or the element pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation added a new element, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Deque&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iDeque.PushBack(d,&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="PushFront+\container101"></a> <font size="+1"><b>PushFront</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(Deque&nbsp;*d,void&nbsp;*element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the start of the deque. It is assumed that &#235;lement" points to a contiguous memory area of at least ElementSize bytes.  

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque or the element pointers are &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation added a new element, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Deque&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iDeque.PushFront(d,&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Save+\container101"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;Deque&nbsp;*d,&nbsp;FILE&nbsp;*out,&nbsp;SaveFunction&nbsp;Fn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given deque are saved into the given stream. If the save function pointer is not &nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer or the stream pointer are &nbsp;NULL .
EOF A disk input/output error occurred.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Deque&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*outFile;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iDeque.Save(d,outFile,NULL,NULL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Priority queues</h2>
<a 
name="Priority queues110"></a>Priority queues are queues where each element has a priority associated with it. In this implementation the elements with the lowest priority
associated with the data are served first.

<div class="p"><!----></div>
The value of the priority key must be within the bounds set up by the two manifest constants:

<font size=+1><pre>
CCL_PRIORITY_MIN
CCL_PRIORITY_MAX

</pre></font>

<div class="p"><!----></div>
They are defined by the implementation and they define a subset of an integer or long integer range. This allows the implementation to save some
values for special "markers" if needed. If the implementation doesn't need this feature it can define the bounds as to cover the full
possible range for the key type.

<div class="p"><!----></div>
The key type is defined as the C99 type <font size="+1"><tt>intptr_t</tt></font>: the integer type that can hold a pointer.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagPQueueInterface&nbsp;{
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(PQueue&nbsp;*Q,intptr_t&nbsp;key,const&nbsp;void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(PQueue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;PQueue&nbsp;*(*Copy)(const&nbsp;PQueue&nbsp;*src);
&nbsp;&nbsp;&nbsp;PQueue&nbsp;*(*Create)(size_t&nbsp;elementSize);
&nbsp;&nbsp;&nbsp;PQueue&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;PQueue&nbsp;*q1,const&nbsp;PQueue&nbsp;*q2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(PQueue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;intptr_t&nbsp;(*Front)(const&nbsp;PQueue&nbsp;*Q,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;intptr_t&nbsp;(*Pop)(PQueue&nbsp;*Q,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Push)(PQueue&nbsp;*Q,intptr_t&nbsp;key,const&nbsp;void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;PQueue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;PQueue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;PQueue&nbsp;*(*Union)(PQueue&nbsp;*left,&nbsp;PQueue&nbsp;*right);
}&nbsp;PQueueInterface;

</pre></font>


     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;A complete example</h3>

<font size=+1><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#include&nbsp;&lt;stdlib.h&#62;
#include&nbsp;"containers.h"
#define&nbsp;MAX_ITERATIONS&nbsp;10
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[20];
&nbsp;&nbsp;&nbsp;&nbsp;PQueue&nbsp;*pq&nbsp;=&nbsp;iPQueue.Create(20);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r,i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;MAX_ITERATIONS;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[20];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;d&nbsp;=&nbsp;rand();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(buf,20,"%d",d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;iPQueue.Push(pq,d,buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;queue&nbsp;has&nbsp;%zu&nbsp;elements\n",iPQueue.Size(pq));
&nbsp;&nbsp;&nbsp;&nbsp;printf("It&nbsp;uses&nbsp;%zu&nbsp;bytes.&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;header&nbsp;structure&nbsp;is&nbsp;%zu\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iPQueue.Sizeof(pq),iPQueue.Sizeof(NULL));
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;iPQueue.Size(pq);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;r;&nbsp;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iPQueue.Pop(pq,buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s&nbsp;",buf);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
OUTPUT
The&nbsp;queue&nbsp;has&nbsp;10&nbsp;elements
It&nbsp;uses&nbsp;968&nbsp;bytes.&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;header&nbsp;structure&nbsp;is&nbsp;88
16807&nbsp;101027544&nbsp;282475249&nbsp;470211272&nbsp;984943658&nbsp;1144108930&nbsp;
1457850878&nbsp;1458777923&nbsp;1622650073&nbsp;2007237709

</pre></font>
The example uses two loops: one for filling the priority queue, the other for printing all its elements. 

<div class="p"><!----></div>
We create the priority queue
with an element size of 20. This is more than enough to hold a character string containing the textual representation of the priority.

<div class="p"><!----></div>
In the first loop (lines 9 to 15) we associate a priority that we obtain from the random number generator, to a character string containing
the text representation of it. We use the <font size="+1"><tt>Push</tt></font> primitive to add to the priority queue (line 13). In case of any error we stop. 

<div class="p"><!----></div>
We print some information about the queue in lines 16-18. In line 19 we store the length of the queue in a temporary variable.
This is necessary since we will use the <font size="+1"><tt>Pop</tt></font> primitive that erases the lowest priority element, so the length of the queue will
change. We can't use <font size="+1"><tt>MAX_ITERATIONS</tt></font> either because it could be that the queue doesn't have its full length because an error
in line 13 forced us to break the first loop in line 14 without reaching <font size="+1"><tt>MAX_ITERATIONS</tt></font>
<a href="#tthFtNtAEG" name="tthFrefAEG"><sup>46</sup></a>.

<div class="p"><!----></div>
The output is obviously in sorted order, since the queue releases the data from the lowest priority to the highest.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container113"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Add)(PQueue&nbsp;*q,&nbsp;intptr_t&nbsp;key,void&nbsp;*Element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds to the given queue <font size="+1"><tt>q</tt></font> the given element <font size="+1"><tt>Element</tt></font> with its associated priority <font size="+1"><tt>key</tt></font>. This function is identical to the
<font size="+1"><tt>Push</tt></font> function below.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container113"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*Clear)(PQueue&nbsp;*Q);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all elements stored in the queue and reclaims the memory used. The priority queue object itself is not destroyed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The PQueue pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The queue is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the queue is cleared, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container113"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;PQueue&nbsp;&nbsp;*(*Create)(size_t&nbsp;elementSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new priority queue container using &#235;lementSize" as the size that each element will have.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The elementSize parameter is zero or bigger than what the implementation supports.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new container or &nbsp;NULL if the operation did not complete.
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container113"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;PQueue&nbsp;&nbsp;*(*Copy)(PQueue&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a copy of the given queue. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The queue pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new queue or &nbsp;NULL if the operation did not complete.
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container113"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;PQueue&nbsp;&nbsp;*(*Create)(size_t&nbsp;elementSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new priority queue container using &#235;lementSize" as the size that each element will have.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The elementSize parameter is zero or bigger than what the implementation supports.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new container or &nbsp;NULL if the operation did not complete.
 
<div class="p"><!----></div>
<br /><a 
name="Equal+\container113"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(PQueue&nbsp;*&nbsp;q1,&nbsp;PQueue&nbsp;*q2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares two priority queues for equality. Two &nbsp;NULL pointers compare equal.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the two queues are equal, zero otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container113"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(PQueue&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the container erasing all elements, if any. Then it destroys the container object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The priority queue pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container113"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;intptr_t&nbsp;(*Front)(PQueue&nbsp;*q,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the element with the lowest priority in the queue q.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either the queue pointer or the result pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The value of the priority associated with the lowest priority element. If the queue is empty the result is <font size="+1"><tt>INT_MIN</tt></font>.
 
<div class="p"><!----></div>
<br /><a 
name="Pop+\container113"></a> <font size="+1"><b>Pop</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;intptr_t&nbsp;(*Pop)(PQueue&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the element with the lowest priority in the Deque d, then erases the element from the deque.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The priority value associated with the element or <font size="+1"><tt>INT_MIN</tt></font> if the queue is empty. 
 
<div class="p"><!----></div>
<br /><a 
name="Push+\container113"></a> <font size="+1"><b>Push</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Push)(PQueue&nbsp;*q,&nbsp;intptr_t&nbsp;key,void&nbsp;*Element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds to the given queue <font size="+1"><tt>q</tt></font> the given element <font size="+1"><tt>Element</tt></font> with its associated priority <font size="+1"><tt>key</tt></font>
 
<div class="p"><!----></div>
<br /><a 
name="Size+\container113"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Size)(PQueue&nbsp;*q);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of elements in the given priority queue.
 
<div class="p"><!----></div>
<br /><a 
name="Sizeof+\container113"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Sizeof)(PQueue&nbsp;*q);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of bytes used in the given priority queue. If the argument <font size="+1"><tt>q</tt></font> is &nbsp;NULL it returns the number of bytes used
by the header structure.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Bloom filters</h2>
<a 
name="Bloomfilter120"></a>Bloom filters allow you to determine cheaply and quickly if an element is member of a set without actually looking into the large set. This container
doesn't store any data, just a series of bits indicating whether the element is there. 
It can return false answers, specifically a false positive meaning
it can answer &#255;es, the element is there" when in fact it is not. When it tells you however that the element is <b>not</b> there you can be sure
it is not in the set. The probability that a false answer occurs can be calculated in function of the size reserved for the bit table: the bigger
the table, the smaller the probability of a false answer for a fixed number of elements. <a href="#tthFtNtAEH" name="tthFrefAEH"><sup>47</sup></a>
<img src="BloomFilter.png" alt="Figure">
<div class="p"><!----></div>
     <h3><a name="tth_sEc12.1">
12.1</a>&nbsp;&nbsp;The interface: iBloomFilter</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagBloomFilterInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*CalculateSpace)(size_t&nbsp;maxfElements,double&nbsp;probability);
&nbsp;&nbsp;&nbsp;&nbsp;BloomFilter&nbsp;*(*Create)(size_t&nbsp;maxElements,double&nbsp;probability);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Add)(BloomFilter&nbsp;*b,const&nbsp;void&nbsp;*key,size_t&nbsp;keylen);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Find)(BloomFilter&nbsp;*b,const&nbsp;void&nbsp;*key,size_t&nbsp;keylen);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(BloomFilter&nbsp;*b);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(BloomFilter&nbsp;*b);
}&nbsp;BloomFilterInterface;

</pre></font>

     <h3><a name="tth_sEc12.2">
12.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="CalculateSpace+\container122"></a> <font size="+1"><b>CalculateSpace</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*CalculateSpace)(size_t&nbsp;maxElements,double&nbsp;probability);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the space in bytes that would occupy a bloom filter to hold the given number of elements with the given probability. The probability parameter
should be greater than zero and smaller than 1.0. For values very close to the values zero and one, 
a huge number of bits can be necessary and the filter
creation function will return &nbsp;NULL because of lack memory problems.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The probability is smaller or equal than zero, or bigger or equal than one.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes needed or zero in case of error.
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container122"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BloomFilter&nbsp;*(*Create)(size_t&nbsp;maxElements,double&nbsp;probability);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates and initializes a filter with space enough to hold <i>MaxElements</i> with the given probability for a false answer. The probability parameter
should be greater than zero and smaller than 1.0. For values very close to the values zero and one, 
a huge number of bits can be necessary and the filter
creation function will return NULL because of lack memory problems.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The probability is smaller or equal than zero, or bigger or equal than one.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEM

 There is no memory for the allocation of the necessary data structures.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a newly allocated bloom filter or &nbsp;NULL in case of error.
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container122"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Add)(BloomFilter&nbsp;*b,const&nbsp;void&nbsp;*key,size_t&nbsp;keylen);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given key to the filter. The <font size="+1"><tt>keylen</tt></font> argument should be the length of the key, that should never be zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The filter pointer or the key pointer are &nbsp;NULL , or the <font size="+1"><tt>keylen</tt></font> is zero.

<div class="p"><!----></div>
CONTAINER_ERROR_CONTAINER_FULL

. The maximum number of elements has been reached.

<div class="p"><!----></div>
<b>Returns:</b>
The number of elements in the filter or zero if there is an error.
 
<div class="p"><!----></div>
<br /><a 
name="Find+\container122"></a> <font size="+1"><b>Find</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Find)(BloomFilter&nbsp;*b,const&nbsp;void&nbsp;*key,size_t&nbsp;keylen);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches the given key in the filter.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The filter pointer or the key pointer are &nbsp;NULL , or the <font size="+1"><tt>keylen</tt></font> is zero.

<div class="p"><!----></div>
<b>Returns:</b>
One if the element is found, zero if it is not, or a negative error code if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container122"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(BloomFilter&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes all elements from the filter. No memory is released.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
One if all elements were cleared, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container122"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(BloomFilter&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Releases all memory held by the filter.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
One if all elements were cleared, a negative error code otherwise.
<BR CLEAR=LEFT><BR><BR>
 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;Suffix Trees</h2><a 
name="iSuffixTree130"></a>
<a 
name="SuffixTree130"></a>
Suffix trees are a compressed trie containing all the suffixes of the given text as their keys and positions in the text as their values. Suffix trees allow particularly fast implementations of many important string operations.

<div class="p"><!----></div>
The concept was first introduced by Weiner (1973). The construction was greatly simplified by McCreight (1976) , and also by Ukkonen (1995). Ukkonen provided the first online-construction of suffix trees, now known as Ukkonen's algorithm, with running time that matched the then fastest algorithms. These algorithms are all linear-time for a constant-size alphabet, and have worst-case running time of O(nlogn) in general.

     <h3><a name="tth_sEc13.1">
13.1</a>&nbsp;&nbsp;The interface: iSuffixTree</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagSuffixTreeInterface&nbsp;{
&nbsp;&nbsp;int&nbsp;(*Apply)(SuffixTree&nbsp;*tree,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int(*Applyfn)(void&nbsp;*,void&nbsp;*),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;int&nbsp;(*Clear)(SuffixTree&nbsp;*b);&nbsp;
&nbsp;&nbsp;SuffixTree&nbsp;*(*Create)(char&nbsp;*text);
&nbsp;&nbsp;SuffixTree&nbsp;*(*CreateWithAllocator)(char&nbsp;*text,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator);
&nbsp;&nbsp;int&nbsp;(*Finalize)(SuffixTree&nbsp;*b);&nbsp;
&nbsp;&nbsp;int&nbsp;(*Find)(SuffixTree&nbsp;*Tree,char&nbsp;*key);
&nbsp;&nbsp;void&nbsp;(*Print)(SuffixTree&nbsp;*Tree,FILE&nbsp;*outputStream);
&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(SuffixTree&nbsp;*tree);
}&nbsp;SuffixTreeInterface;

</pre></font>

     <h3><a name="tth_sEc13.2">
13.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container132"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Apply)(SuffixTree&nbsp;*tree,&nbsp;int(*Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Applies the given function to each node of the tree. The argument <font size="+1"><tt>arg</tt></font> will be passed to the given function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

  Either the suffix tree pointer or Applyfn are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if no errors appeared or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container132"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(SuffixTree&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The suffix tree header will not be destroyed, and its contents will be the same as when it was initially created. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container132"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;SuffixTree&nbsp;*(*Create)(char&nbsp;*text);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a suffix tree for the given text. The current allocator is used for memory allocation.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The text pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Insufficient memory to create the object.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new suffix tree or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="CreateWith Allocator+\container132"></a> <font size="+1"><b>CreateWith Allocator</b></font> <hr />


<font size=+1><pre>

&nbsp;SuffixTree&nbsp;*(*Create)(char&nbsp;*text,&nbsp;ContainerAllocator&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a suffix tree for the given text using the given allocator object to allocate memory.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The text pointer is &nbsp;NULL or the allocator object pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Insufficient memory to create the object.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new suffix tree or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container132"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(SuffixTree&nbsp;*tree);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the suffix tree, including the list header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given suffix tree pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed. A negative error code indicates failure.
<BR CLEAR=LEFT><BR><BR>
 <h2><a name="tth_sEc14">
14</a>&nbsp;&nbsp;Value arrays</h2>
<a 
name="iValArray140"></a>
<a 
name="ValArray140"></a>
Value arrays are a group of containers that store the basic types of the language: <font size="+1"><tt>short, int, long, long long, float, double, long double</tt></font>
and have some specialized operations that should be done in hardware when the underlying CPU allows it. The objective here is to simplify the 
<font size="+1"><tt>vector</tt></font> interface replacing the <font size="+1"><tt>void *</tt></font> with the concrete type that these arrays hold.

<div class="p"><!----></div>
We have the following ValArrays:

<center>

<table>
<tr><td align="left"><b>Name</b></td><td align="left"><b>Interface name</b></td><td align="left"><b>Element type</b></td></tr>
<tr><td align="left">ValArrayShort</td><td align="left">iValArrayShort</td><td align="left">short</td></tr>
<tr><td align="left">ValArrayInt</td><td align="left">iValArrayInt</td><td align="left">int</td></tr>
<tr><td align="left">ValArrayUInt</td><td align="left">iValArrayUInt</td><td align="left">unsigned</td></tr>
<tr><td align="left">ValArrayLong</td><td align="left">iValArrayLong</td><td align="left">long</td></tr>
<tr><td align="left">ValArrayDouble</td><td align="left">iValArrayDouble</td><td align="left">double</td></tr>
<tr><td align="left">ValArrayFloat</td><td align="left">iValArrayFloat</td><td align="left">float</td></tr>
<tr><td align="left">ValArrayLongDouble</td><td align="left">iValArrayLongDouble</td><td align="left">long double</td></tr>
<tr><td align="left">ValArrayLLong</td><td align="left">iValArrayLLong</td><td align="left">long long</td></tr>
<tr><td align="left">ValArrayULLong</td><td align="left">iValArrayULLong</td><td align="left">unsigned long long</td></tr>
<tr><td align="left">ValArraySize_t</td><td align="left">iValArraySize_t</td><td align="left">size_t</td></tr></table>

</center>
Some types can be just aliases for other types. For instance when int and long have the same size there is no point in providing a separate
implementation. This will be always the case with the type <font size="+1"><tt>size_t</tt></font> that will be an alias for one of the unsigned types. This type is needed to
represent arrays of indices that can be used to select elements into another array.

<div class="p"><!----></div>
The operations supported are the same as the vector data type with several differences:

<ul>
<li> Simplified interfaces. For instance in the vector container the result of GetElement is always a pointer to the data. ValArray simplifies this by
using directly the underlying type as return value. The functions that change their signature are:

<ol type="1">
<li> Contains. Second parameter is not a pointer but the underlying type.
<div class="p"><!----></div>
</li>

<li> Erase. Second parameter is not a pointer but the underlying type.
<div class="p"><!----></div>
</li>

<li> Apply. The apply function receives the underlying type and not a pointer.
<div class="p"><!----></div>
</li>

<li> Add. The second argument is the underlying type.
<div class="p"><!----></div>
</li>

<li> GetElement. Returns the underlying type.
<div class="p"><!----></div>
</li>

<li> PushBack.Second argument changes.
<div class="p"><!----></div>
</li>

<li> PopFront. Returns the underlying type.
<div class="p"><!----></div>
</li>

<li> InsertAt. Second argument.
<div class="p"><!----></div>
</li>

<li> ReplaceAt. Third argument
<div class="p"><!----></div>
</li>

<li> IndexOf. Second argument.
<div class="p"><!----></div>
</li>

<li> Insert. Second argument
<div class="p"><!----></div>
</li>

<li> AddRange. Second argument is not a void pointer but a pointer to the underlying type.
<div class="p"><!----></div>
</li>

<li> CopyElement. Second argument is not a void pointer but a pointer to the underlying type.
<div class="p"><!----></div>
</li>

<li> CopyTo. The return type is not a <font size="+1"><tt>void **</tt></font> but a pointer to an array of the underlying type.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li> No destructors. There is no point in using destructors with the basic types.
<div class="p"><!----></div>
</li>

<li> No extra arguments used in the comparison function. The comparison is done inline whenever possible. The function <font size="+1"><tt>SetComparisonFunction</tt></font>
is accepted but does nothing.
<div class="p"><!----></div>
</li>

<li> Creation functions do not need the element size parameter.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>GetElementSize</tt></font> returns the size in bytes of the underlying type but doesn't use its argument that can be &nbsp;NULL .
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>Save</tt></font> and <font size="+1"><tt>Load</tt></font> functions do not need a user defined save/load function since it is obvious how the basic
types are to be written to the disk: they contain surely no pointers that need to be followed. Their signature is changed.
<div class="p"><!----></div>
</li>

<li> Iterators are unchanged and still return a pointer to an element <a href="#tthFtNtAEI" name="tthFrefAEI"><sup>48</sup></a>.
<div class="p"><!----></div>
</li>

<li> No tests for &nbsp;NULL arguments in the default version. 
Obviously those tests can be added in other versions or implementations since any &nbsp;NULL arguments
provokes undefined behavior <a href="#tthFtNtAEJ" name="tthFrefAEJ"><sup>49</sup></a>.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc14.1">
14.1</a>&nbsp;&nbsp;Operations</h3>
Each operation described below needs two compatible arrays, i.e. arrays that have the same number of elements. If that is not the case an error
occurs. A single number can be used in place of an array, extending it to the shape of the array. The naming convention is to add the "Scalar" token
to the operation name, so we have for instance <font size="+1"><tt>MultiplyWith</tt></font> and <font size="+1"><tt>MultiplyWithScalar</tt></font>.

<div class="p"><!----></div>
In general all operations use the data of the left argument and write their results into the left argument. The right argument remains unmodified.
This allows to construct efficient RPN evaluators to avoid allocating intermediate results.

     <h3><a name="tth_sEc14.2">
14.2</a>&nbsp;&nbsp;Slices and masks</h3>
A <b>slice</b> is a description of a certain portion of the array. It has three fields:

<ol type="1">
<li> <b>Start</b>, The zero based index of the element that starts the slice.
<div class="p"><!----></div>
</li>

<li> <b>Length</b>. The number of elements that are selected by the slice.
<div class="p"><!----></div>
</li>

<li> <b>Increment</b>. The number of elements that are skipped between elements when passing from one element of the slice to the next.
<div class="p"><!----></div>
</li>
</ol>
When a ValArray is created, the slice used is the default one: <font size="+1"><tt>0, Size(ValArray), 1</tt></font>. The slice starts at element zero,
has the same number of elements that the number of elements in the array, and its increment is 1. Using the API <font size="+1"><tt>SetSlice</tt></font> and
<font size="+1"><tt>ResetSlice</tt></font> you can modify the elements that will be selected for all operations. When a slice is active, all elements that aren't in the
selected slice are ignored.

<div class="p"><!----></div>
Slices are maintained by the library automatically. If you erase elements from the array until the slice is empty, the library automatically
resets the slice. If you add elements, the length of the slice will increase if necessary.

<div class="p"><!----></div>
A <b>Mask</b> is a boolean vector of ones or zeroes that selects elements from the array. It can be implemented as a bitstring or as a sequence
of bytes, this is implementation defined. When used in combination with some ValArray operation, it selects the elements that will be affected
by the operation.

     <h3><a name="tth_sEc14.3">
14.3</a>&nbsp;&nbsp;The interface</h3>
This is a generic interface description. The <font size="+1"><tt>ElementType</tt></font> token is replaced in each ValArray by the underlying type: 
int, double, etc. In the same
style, <font size="+1"><tt>ValArray</tt></font> and the <font size="+1"><tt>ValArrayInterface</tt></font> tokens are replaced with the corresponding value array name and interface name.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagValArrayInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Abs)(ValArray&nbsp;*src);&nbsp;
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Accumulate)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(ValArray&nbsp;*AL,ElementType&nbsp;newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(ValArray&nbsp;*AL,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;*newvalues);
&nbsp;&nbsp;&nbsp;int&nbsp;(*And)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AndScalar)(ValArray&nbsp;*left,&nbsp;const&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(ValArray&nbsp;*AL1,&nbsp;ValArray&nbsp;*AL2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(ValArray&nbsp;*AL,int&nbsp;(*Applyfn)(ElementType&nbsp;element,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*&nbsp;arg),void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Back)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*BitLeftShift)(ValArray&nbsp;*data,int&nbsp;shift);
&nbsp;&nbsp;&nbsp;int&nbsp;(*BitRightShift)(ValArray&nbsp;*data,&nbsp;const&nbsp;int&nbsp;shift);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*Compare)(const&nbsp;ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*bytearray);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqual)(const&nbsp;ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*bytearray);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqualScalar)(const&nbsp;ValArray&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;right,&nbsp;Mask&nbsp;*bytearray);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*CompareScalar)(const&nbsp;ValArray&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;right,char&nbsp;*bytearray);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;ValArray&nbsp;*AL,ElementType&nbsp;data);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Copy)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;idx,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;*(*CopyTo)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Create)(size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*CreateSequence)(size_t&nbsp;n,ElementType&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;increment);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideBy)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideByScalar)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideScalarBy)(ValArray&nbsp;*left,ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;ValArray&nbsp;*first,&nbsp;const&nbsp;ValArray&nbsp;*second);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(ValArray&nbsp;*AL,ElementType&nbsp;elem);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(ValArray&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*FCompare)(const&nbsp;ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*bytearray,ElementType&nbsp;tolerance);
&nbsp;&nbsp;&nbsp;int&nbsp;(*FillSequential)(ValArray&nbsp;*dst,size_t&nbsp;length,ElementType&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;increment);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ForEach)(ValArray&nbsp;*src,ElementType&nbsp;(*ApplyFn)(ElementType));
&nbsp;&nbsp;&nbsp;int&nbsp;(*Fprintf)(const&nbsp;ValArray&nbsp;*src,FILE&nbsp;*out,const&nbsp;char&nbsp;*fmt);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Front)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*(*GetAllocator)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;*(*GetData)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*GetElement)(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*GetRange)(const&nbsp;ValArray&nbsp;*AL,&nbsp;size_t&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*GetSlice)(ValArray&nbsp;*array,size_t&nbsp;*start,size_t&nbsp;*length,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*increment);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*IndexIn)(const&nbsp;ValArray&nbsp;*SC,const&nbsp;ValArraySize_t&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(ValArray&nbsp;*AL,ElementType&nbsp;data,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Init)(ValArray&nbsp;*AL,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(ValArray&nbsp;*AL,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*InitializeWith)(size_t&nbsp;n,&nbsp;ElementType&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(ValArray&nbsp;*AL,ElementType);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(ValArray&nbsp;*AL,size_t&nbsp;idx,ElementType&nbsp;newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(ValArray&nbsp;*AL,&nbsp;size_t&nbsp;idx,&nbsp;ValArray&nbsp;*newData);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Inverse)(ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Load)(FILE&nbsp;*stream);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Max)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Memset)(ValArray&nbsp;*dst,ElementType&nbsp;fillValue,size_t&nbsp;length);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Min)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Mismatch)(const&nbsp;ValArray&nbsp;*a1,const&nbsp;ValArray&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Mod)(ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ModScalar)(ValArray&nbsp;*left,const&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*MultiplyWith)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*MultiplyWithScalar)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Not)(ValArray&nbsp;*left);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*OrScalar)(ValArray&nbsp;*left,&nbsp;const&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(ValArray&nbsp;*AL,ElementType&nbsp;*result);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Product)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(ValArray&nbsp;*AL,ElementType&nbsp;data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(ValArray&nbsp;*src,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(ValArray&nbsp;*AL,size_t&nbsp;idx,ElementType&nbsp;newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ResetSlice)(ValArray&nbsp;*array);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(ValArray&nbsp;*src,&nbsp;size_t&nbsp;newSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(ValArray&nbsp;*AL,&nbsp;size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(ValArray&nbsp;*AL,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;ValArray&nbsp;*AL,FILE&nbsp;*stream);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(ValArray&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*SelectCopy)(const&nbsp;ValArray&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetCapacity)(ValArray&nbsp;*AL,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(ValArray&nbsp;*l,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(ValArray&nbsp;*cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(ValArray&nbsp;*AL,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(ValArray&nbsp;*AL,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetSlice)(ValArray&nbsp;*src,size_t&nbsp;start,size_t&nbsp;length,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;increment);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;ValArray&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractFrom)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractFromScalar)(ElementType&nbsp;left,&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractScalarFrom)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SumScalarTo)(ValArray&nbsp;*left,ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SumTo)(ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Xor)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*XorScalar)(ValArray&nbsp;*left,&nbsp;const&nbsp;ElementType&nbsp;right);
}&nbsp;ValArrayInterface;

</pre></font>


<BR CLEAR=LEFT><BR><BR>

<img src="ValArray.png" alt="Figure">
<BR CLEAR=LEFT><BR><BR>

 
<div class="p"><!----></div>
<br /><a 
name="Abs+\container143"></a> <font size="+1"><b>Abs</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Abs)(ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
If any of the values in the source array is smaller than zero it will be negated. This function is only defined for signed or floating point types.
It has no meaning with unsigned types.

<div class="p"><!----></div>
<b>Returns:</b>Zero if the array was empty, a positive number if successful.
 
<div class="p"><!----></div>
<br /><a 
name="Accumulate+\container143"></a> <font size="+1"><b>Accumulate</b></font> <hr />


<font size=+1><pre>

ElementType&nbsp;(*Accumulate)(ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Calculates the sum of all the elements of the given vector. If a slice definition is active only the slice elements are considered.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None are mandatory but implementations should check for overflow when possible.

<div class="p"><!----></div>
<b>Returns:</b>The sum of the elements.

<div class="p"><!----></div>
 
<br /><a 
name="Add+\container143"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(ValArray&nbsp;*AL,ElementType&nbsp;newval);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds an element at the end of the array. If a slice is active, the increment field (stride) will be used: the new element will be separated by the 
increment field of the slice and empty fields will be filed with zeroes. The length of the slice will be incremented by one.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element was added or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="AddRange+\container143"></a> <font size="+1"><b>AddRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(ValArray&nbsp;*AL,size_t&nbsp;n,ElementType&nbsp;*newvalues);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds a range of elements at the end of the array. If a slice is active, the increment field (stride) will be used: each new element will be separated by 
the increment field of the slice and empty fields will be filed with zeroes. The length of the slice will be incremented by n. If n is zero no error
will be issued and the result is a positive number.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the elements were added or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Apply+\container143"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Apply)(ValArray&nbsp;*AL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Applyfn)(ElementType&nbsp;element,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Calls the given function for each element of the array. If a slice is active only the elements in the slice will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>A positive number

<div class="p"><!----></div>
 
<br /><a 
name="And+\container143"></a> <font size="+1"><b>And</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*And)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise AND operation between each element of the right argument with the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left&nbsp;&amp;=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning. If a slice is active only the slice elements are affected. If both arrays have slices they must be compatible, i.e. they must have the
same length.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays or slices have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="BitLeftShift+\container143"></a> <font size="+1"><b>BitLeftShift</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*BitLeftShift)(ValArray&nbsp;*dst,int&nbsp;shift);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Shifts left each element of the given ValArray by <font size="+1"><tt>shift</tt></font> bits. If <font size="+1"><tt>shift</tt></font> is negative it performs a right shift instead.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors. 

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code if an implementation detects an invalid pointer. This error is not required to be detected.

<div class="p"><!----></div>
 
<br /><a 
name="BitRightShift+\container143"></a> <font size="+1"><b>BitRightShift</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*BitRightShift)(ValArray&nbsp;*dst,int&nbsp;shift);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Shifts right each element of the given ValArray by <font size="+1"><tt>shift</tt></font> bits. If <font size="+1"><tt>shift</tt></font> is negative it performs a left shift instead.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors. 

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code if an implementation detects an invalid pointer. This error is not required to be detected.

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container143"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(ValArray&nbsp;*array);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the number of elements to zero but doesn't release any memory. Any slice definitions are cleared.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>A positive integer.
 
<div class="p"><!----></div>
<br /><a 
name="Compare+\container143"></a> <font size="+1"><b>Compare</b></font> <hr />


<font size=+1><pre>

char&nbsp;*(*Compare)(ValArray&nbsp;*left,ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each byte of the bitarray the result of comparing the corresponding elements of the left and right arrays. Conceptually this operation is: 
<font size=+1><pre>
byte[i]&nbsp;=&nbsp;(left[i]&nbsp;&lt;&nbsp;right[i])&nbsp;?&nbsp;-1&nbsp;:&nbsp;(left[i]&nbsp;==&nbsp;right[i])&nbsp;?&nbsp;0&nbsp;:&nbsp;1

</pre></font>
If the bytearray argument is &nbsp;NULL it will be allocated and returned. The allocator used is the one from the left argument. 
If it is not &nbsp;NULL it will be assumed that it contains at least
<font size="+1"><tt>GetSize(left)</tt></font>
positions available.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was &nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The arrays are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CompareScalar+\container143"></a> <font size="+1"><b>CompareScalar</b></font> <hr />


<font size=+1><pre>

char&nbsp;*(*CompareScalar)(const&nbsp;ValArray&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;right,&nbsp;char&nbsp;*bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each byte of the bitarray the result of comparing the elements of the left array with the right argument. 
Conceptually this operation is: 

<font size=+1><pre>
byte[i]&nbsp;=&nbsp;(left[i]&nbsp;&lt;&nbsp;right)&nbsp;?&nbsp;-1&nbsp;:&nbsp;(left[i]&nbsp;==&nbsp;right)&nbsp;?&nbsp;0&nbsp;:&nbsp;1

</pre></font>
If the bitarray argument is &nbsp;NULL it will be allocated and returned. The allocator used is the one from the left argument. If it is not &nbsp;NULL it will be assumed that it contains at least
<font size="+1"><tt>GetSize(left)</tt></font>
positions available.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was &nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CompareEqual+\container143"></a> <font size="+1"><b>CompareEqual</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*CompareEqual)(ValArray&nbsp;*left,ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each element of the mask the result of comparing the corresponding elements of the left and right arrays. Conceptually this operation is: 
<font size=+1><pre>
bit[i]&nbsp;=&nbsp;(left[i]&nbsp;==&nbsp;right[i])

</pre></font> 
If the bitarray argument is &nbsp;NULL it will be allocated and returned. The allocator used is the global memory manager. 
If it is not &nbsp;NULL it should contain at least enough positions to hold the data.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was &nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given mask hasn't enough positions available.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The arrays are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray passed or allocated, or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CompareEqualScalar+\container143"></a> <font size="+1"><b>CompareEqualScalar</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*CompareEqual)(ValArray&nbsp;*left,ElementType&nbsp;right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each bit of the bitarray the result of comparing the elements of the left array with the right argument. 
Conceptually this operation is: 

<font size=+1><pre>
bit[i]&nbsp;=&nbsp;(left[i]&nbsp;==&nbsp;right)

</pre></font> 
If the bitarray argument is &nbsp;NULL it will be allocated and returned. The allocator used is the one from the left argument. If it is not &nbsp;NULL it will be assumed that it contains at least
<div class="p"><!----></div>
<font size="+1"><tt>1+GetSize(left)/CHAR_BIT</tt></font>
<div class="p"><!----></div>
positions available.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was &nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Contains+\container143"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Contains)(ValArray&nbsp;*a,ElementType&nbsp;data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches the given data in the array. If any slice specifications are active, only the slice is searched.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
One if the given data is stored in the array, zero otherwise. 

<div class="p"><!----></div>
 
<br /><a 
name="Copy+\container143"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Copy)(const&nbsp;ValArray&nbsp;*A);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
A copy of the given array is performed. The new memory will be allocated using the given array's allocator. If any slice specifications are current, 
only the elements of the slice will be copied into the resulting vector, that will have the size of the slice. Slice specifications are not copied.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>The new array. 

<div class="p"><!----></div>
 
<br /><a 
name="CopyTo+\container143"></a> <font size="+1"><b>CopyTo</b></font> <hr />


<font size=+1><pre>

ElementType&nbsp;*(*CopyTo)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the whole contents of the given array into a table of newly allocated elements. If a slice specification is active only the slice will be
returned.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a table or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container143"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

ValArray&nbsp;*(*Create)(size_t&nbsp;capacity);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates an empty array with enough storage to hold <font size="+1"><tt>capacity</tt></font> elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough storage to complete this operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the empty array or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CreateSequence+\container143"></a> <font size="+1"><b>CreateSequence</b></font> <hr />


<font size=+1><pre>

ValArray&nbsp;*(*CreateSequence)(size_t&nbsp;size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;startValue,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;increment);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates an array with <font size="+1"><tt>size</tt></font> elements and fills it with elements of the ValArray data type starting with
the <font size="+1"><tt>startValue</tt></font> argument, and increasing it by the value of <font size="+1"><tt>increment</tt></font> at each step. The <font size="+1"><tt>increment</tt></font> value can be negative or zero. If it is zero the array is filled with the same value. This is equivalent to the <font size="+1"><tt>Fill</tt></font> API<a href="#tthFtNtAFA" name="tthFrefAFA"><sup>50</sup></a>.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough storage to complete this operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the sequence or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="DivideBy+\container143"></a> <font size="+1"><b>DivideBy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideBy)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Divides each element of the left argument by the corresponding element of the right argument. Conceptually this operation is: <font size="+1"><tt>left /= right</tt></font>. 
If any of the elements of the right argument is zero, an error occurs and the computation stops, leaving the left argument with some elements divided
and others not<a href="#tthFtNtAFB" name="tthFrefAFB"><sup>51</sup></a>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
CONTAINER_ERROR_DIVIDE_BY_ZERO

 The second argument has an element that is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="DivideByScalar+\container143"></a> <font size="+1"><b>DivideByScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideByScalar)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Divides each element of the left argument by the right argument. Conceptually this operation is: <font size="+1"><tt>left /= right</tt></font>. If the right argument is zero
an error occurs and the left argument remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_DIVIDE_BY_ZERO

 The second argument is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="DivideScalarBy+\container143"></a> <font size="+1"><b>DivideScalarBy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideScalarBy)(ElementType&nbsp;left,&nbsp;ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Divides each element of the left argument by the right argument. Conceptually this operation is: <font size="+1"><tt>right = left / right</tt></font>. If the left argument is zero
an error occurs and the right argument remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_DIVIDE_BY_ZERO

 The first argument is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Equal+\container143"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Equal)(const&nbsp;ValArray&nbsp;*src1,const&nbsp;ValArray&nbsp;*src2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns 1 if both arrays are equal, zero otherwise. It is legal to compare an array with &nbsp;NULL . If both arrays are &nbsp;NULL they compare equal. Any slice
definitions in the arrays must be equal. If equal, they restrict the number of elements compared. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>True or false depending if the arrays are equal or not.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container143"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(ValArray&nbsp;*AL,ElementType&nbsp;data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the vector the element that matches the given data.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOTFOUND

 No match was found.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that a match was found and the element was removed. If the element is not
in the ValArray the result value is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.
 
<div class="p"><!----></div>
<br /><a 
name="EraseAll+\container143"></a> <font size="+1"><b>EraseAll</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(ValArray&nbsp;*v,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the array all elements that match the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that at least a match was found and the element was removed. If the 
element is not in the list the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
 
<br /><a 
name="EraseAt+\container143"></a> <font size="+1"><b>EraseAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(ValArray&nbsp;*AL,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the array the element at the given position. If a slice specification is defined for the array, the index is understood as an
index within the slice and not as an index in the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred or a positive value that indicates that the element was removed.

<div class="p"><!----></div>
 
<br /><a 
name="FCompare+\container143"></a> <font size="+1"><b>FCompare</b></font> <hr />


<font size=+1><pre>

char&nbsp;*(*FCompare)(const&nbsp;ValArray&nbsp;*left,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*bytearray,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;tolerance);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function is exactly like the Compare function but designed for comparing floating point numbers. Direct comparison of floating point numbers are known to be problematic. This comparison will be realized within the tolerance defined by the fourth parameter

<div class="p"><!----></div>
The sample implementation uses the ideas of Donald Knuth
<a href="#tthFtNtAFC" name="tthFrefAFC"><sup>52</sup></a>
as implemented by Theodore C. Belding
<a href="#tthFtNtAFD" name="tthFrefAFD"><sup>53</sup></a>
In the documentation of its software, Mr Belding writes:

<blockquote>
What is needed is a comparison operator that takes into account a
certain amount of uncertainty:

<font size=+1><pre>
if&nbsp;(fabs(x&nbsp;-&nbsp;y)&nbsp;&lt;=&nbsp;epsilon)&nbsp;{
&nbsp;&nbsp;/*&nbsp;code&nbsp;to&nbsp;be&nbsp;executed&nbsp;if&nbsp;x&nbsp;==&nbsp;y&nbsp;*/
}

if&nbsp;(x&nbsp;-&nbsp;y&nbsp;&#62;&nbsp;epsilon)&nbsp;{
&nbsp;&nbsp;/*&nbsp;code&nbsp;to&nbsp;be&nbsp;executed&nbsp;if&nbsp;x&nbsp;&#62;&nbsp;y&nbsp;*/
}

if&nbsp;(x&nbsp;-&nbsp;y&nbsp;&lt;&nbsp;-epsilon)&nbsp;{
&nbsp;&nbsp;/*&nbsp;code&nbsp;to&nbsp;be&nbsp;executed&nbsp;if&nbsp;x&nbsp;&lt;&nbsp;y&nbsp;*/
}

</pre></font>
In the above code, a neighborhood is defined that extends a distance
epsilon to either side of y on the real number line.  If x falls
within epsilon of y, x is declared to be equal to y (the first case,
above).  If x is greater than y by an amount that is greater than
epsilon, x is declared to be greater than y (the second case, above).
If x is less than y by an amount that is greater than epsilon, x is
declared to be less than y (the third case, above).

<div class="p"><!----></div>
The problem then becomes to determine an appropriate value of epsilon.
A fixed value of epsilon would not work for all x and y; epsilon
should be scaled larger or smaller depending on the magnitudes of the
numbers to be compared.

<div class="p"><!----></div>
A floating point number is represented by two numbers, the significand
(also called the fraction or mantissa) and the exponent, and a sign,
where

<div class="p"><!----></div>
<font size="+1"><tt>0&nbsp;&lt;=&nbsp;significand&nbsp;&lt;&nbsp;1</tt></font> 

<div class="p"><!----></div>
and 

<div class="p"><!----></div>
<font size="+1"><tt>number = sign * significand * pow(2, exponent)</tt></font>.

<div class="p"><!----></div>
Knuth's suggestion is to scale epsilon by the exponent of the larger of the
two floating point numbers to be compared:

<div class="p"><!----></div>
&#8710; =  epsilon &times;maxExponent

<div class="p"><!----></div>
where maxExponent is the exponent of max(x, y).  Delta can then be
substituted for epsilon in the code snippets above.


<div class="p"><!----></div>
<font size="+1"><b>Determining epsilon</b></font>

<div class="p"><!----></div>
Now that we have found a way to scale epsilon to work with a wide
range of x and y, we still need to choose an appropriate epsilon,
before scaling.  

<div class="p"><!----></div>
If the number of binary digits of error, e, is known, then epsilon
can be calculated as follows:

<font size=+1><pre>
epsilon&nbsp;=&nbsp;(pow(2,&nbsp;e)&nbsp;-&nbsp;1)&nbsp;*&nbsp;FLT_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for&nbsp;floats)
epsilon&nbsp;=&nbsp;(pow(2,&nbsp;e)&nbsp;-&nbsp;1)&nbsp;*&nbsp;DBL_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for&nbsp;doubles)

</pre></font>
<font size="+1"><tt>FLT_EPSILON</tt></font> and <font size="+1"><tt>DBL_EPSILON</tt></font> are equivalent to 1 ulp for single- and
double-precision numbers, respectively; they are defined in the
standard C header file <font size="+1"><tt>&lt;float.h&gt;</tt></font>. (An ulp is one unit in the last
place of the significand, or fraction part, of a floating point
number; see Knuth for more details.)
</blockquote>

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was &nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="FillSequential+\container143"></a> <font size="+1"><b>FillSequential</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*FillSequential)(ValArray&nbsp;*a,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;start,ElementType&nbsp;increment);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to all members of the array a sequence that starts at <font size="+1"><tt>start</tt></font>, and is incremented by the given amount at each array position.
The start and increment arguments can hold any value without restrictions, unless they go beyond the maximum value allowed for the given data
type

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors. 

<div class="p"><!----></div>
<b>Returns:</b>A positive number.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

ValArray&nbsp;*myValArray&nbsp;=&nbsp;iValArray.Create(6);
iValArray.FillSequential(myValArray,5,2);
//&nbsp;Now&nbsp;the&nbsp;contents&nbsp;of&nbsp;myValArray&nbsp;are:
5,7,9,11,13,15

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Finalize+\container143"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the container, including the array header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed.

<div class="p"><!----></div>
 
<br /><a 
name="ForEach+\container143"></a> <font size="+1"><b>ForEach</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*ForEach)(ValArray&nbsp;*src,ElementType&nbsp;(*ApplyFn)(ElementType));

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Applies the one argument <font size="+1"><tt>ApplyFn</tt></font> to each element of the array and stores the result in that element.

<div class="p"><!----></div>
<b>Returns:</b>Always 1<a href="#tthFtNtAFE" name="tthFrefAFE"><sup>54</sup></a>.

<div class="p"><!----></div>
 
<br /><a 
name="Fprintf+\container143"></a> <font size="+1"><b>Fprintf</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Fprintf)(ValArray&nbsp;*src,FILE&nbsp;*out,const&nbsp;char&nbsp;*fmt);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Prints in the indicated stream each element of the given array using the indicated format string. If the array is empty nothing is printed and
the result is zero. There is a newline character appended to the output if the array wasn't empty and no error occurred.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_EOF

 An output error occurred: impossible to write to the stream.

<div class="p"><!----></div>
<b>Returns:</b>
The number of characters written to the stream, zero if the array was empty, or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="GetCapacity+\container143"></a> <font size="+1"><b>GetCapacity</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements the array can hold before  it needs to reallocate its data.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
The array capacity.

<div class="p"><!----></div>
 
<br /><a 
name="GetData+\container143"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

ElementType&nbsp;*(*GetData)(const&nbsp;ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the data area of the container, or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_READONLY

 The container is read-only.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given pointer is &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>The pointer to the array's data or &nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="GetElement+\container143"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*GetElement)(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the value stored at the element with the given index.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INDEX

    The given position is out of bounds.

<div class="p"><!----></div>
<b>Returns:</b>The element's value or the minimum value that can be stored in ElementType if the index is out of bounds.

<div class="p"><!----></div>
 
<br /><a 
name="GetElementSize+\container143"></a> <font size="+1"><b>GetElementSize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the size of the elements stored in the ValArray. The argument is not used and can be &nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
 
<br /><a 
name="GetRange+\container143"></a> <font size="+1"><b>GetRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*GetRange)(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Selects a series of consecutive elements starting at position start and ending at position one less than end.
If start  &gt;  end or start  &gt;  Size(ValArray),  &nbsp;NULL is returned. If end is bigger than the number of elements in the array, only elements up to the number of elements will be used.
<div class="p"><!----></div>
If a slice is active in the array, the arguments will be understood as indices in the slice and <b>not</b> in the original array.
<div class="p"><!----></div>
The selected elements are copied into a new array. The original array remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>:
A pointer to a new ValArray containing the selected elements or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="GetSlice+\container143"></a> <font size="+1"><b>GetSlice</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*GetSlice)(ValArray&nbsp;*array,size_t&nbsp;*start,&nbsp;size_t&nbsp;*length,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*increment);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given pointers the contents of the current slice specifications for the given array. If any of the given pointers is &nbsp;NULL nothing is 
copied into it and no error is issued. If the array has no slice specification all fields will be set to zero if not &nbsp;NULL , and the result is zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors

<div class="p"><!----></div>
<b>Returns:</b>Zero if there isn't any slice specification, a positive number otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

/*&nbsp;This&nbsp;expression&nbsp;allows&nbsp;you&nbsp;to&nbsp;determine&nbsp;if&nbsp;there&nbsp;
&nbsp;&nbsp;&nbsp;is&nbsp;a&nbsp;slice&nbsp;defined&nbsp;for&nbsp;a&nbsp;given&nbsp;array&nbsp;*/
if&nbsp;(iValArray.GetSlice(myValArray,NULL,NULL,NULL))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;array&nbsp;has&nbsp;a&nbsp;slice&nbsp;defined&nbsp;into&nbsp;it&nbsp;*/
}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="IndexIn+\container143"></a> <font size="+1"><b>IndexIn</b></font> <hr />


<font size=+1><pre>

ValArray&nbsp;*(*IndexIn)(const&nbsp;ValArray&nbsp;*source,ValArraySize_t&nbsp;*indices);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns an array built from indexing the first argument (&#223;ource") with the array of indexes &#239;ndices" that should be an array of 
size_t elements. The number of elements of the resulting array is equal to the number of elements of the indexes array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INDEX

 Any given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new array or &nbsp;NULL if an error occurs. No partial results are returned. If any index is out of bounds the whole operation fails.

<div class="p"><!----></div>
 
<br /><a 
name="IndexOf+\container143"></a> <font size="+1"><b>IndexOf</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*IndexOf)(const&nbsp;ValArray&nbsp;*l,ElementType&nbsp;data,size_t&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches for an element in the array. If found its zero based index is returned in the pointer "result". Otherwise the result of the search is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
. The &#235;xtraArgs" argument will be passed to the comparison function, that is used to compare elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array pointer or the element given are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element is found, or a negative number containing an error code or the negative constant 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
 
<br /><a 
name="InitializeWith+\container143"></a> <font size="+1"><b>InitializeWith</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*InitializeWith)(size_t&nbsp;n,&nbsp;ElementType&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates and initializes a new ValArray with the given data table. The first argument is the number of items in the table and the second
is a pointer to a storage area that should contain at least the given number of items. 
The data is copied into the new array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the new array or &nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="InsertAt+\container143"></a> <font size="+1"><b>InsertAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(ValArray&nbsp;*src,size_t&nbsp;idx,ElementType&nbsp;newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the new element. The new element will have the given index, that can go from zero to the vector count inclusive, i.e. one more than the number of elements in the vector.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.
 
<div class="p"><!----></div>
<br /><a 
name="Inverse+\container143"></a> <font size="+1"><b>Inverse</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Inverse)(ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes for each element the inverse (1/element) and stores it in-place. 
If a slice definition is active only their elements will be used. If any of the elements is
zero the computation stops and the result is an error code.

<div class="p"><!----></div>
This function is defined for the floating point types only<a href="#tthFtNtAFF" name="tthFrefAFF"><sup>55</sup></a>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_DIVISION_BY_ZERO

 One of the elements is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if successful, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Max+\container143"></a> <font size="+1"><b>Max</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Max)(const&nbsp;ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the biggest element in the container. If the container is empty it returns the smallest element that can be stored into the array's data
type<a href="#tthFtNtAFG" name="tthFrefAFG"><sup>56</sup></a>.

<div class="p"><!----></div>
 
<br /><a 
name="Memset+\container143"></a> <font size="+1"><b>Memset</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Memset)(ValArray&nbsp;*dst,ElementType&nbsp;data,size_t&nbsp;length);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each element of the argument the given data. Conceptually this operation is: <font size="+1"><tt>dst = data</tt></font>. If a slice is active in the destination 
array only the elements described by the slice are modified. If the given length is bigger than the number of elements in the array, the array
will be expanded to accommodate the new elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough resources to expand the array to the desired length.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Min+\container143"></a> <font size="+1"><b>Min</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Min)(const&nbsp;ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the smallest element in the container. If the container is empty it returns the biggest element that can be stored into the array's data
type<a href="#tthFtNtAFH" name="tthFrefAFH"><sup>57</sup></a>.

<div class="p"><!----></div>
 
<br /><a 
name="Mismatch+\container143"></a> <font size="+1"><b>Mismatch</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Mismatch)(const&nbsp;ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the index of the first element that is different when comparing both arrays in the passed pointer <i>mismatch</i>. If one array is shorter than the other the comparison stops
when the last element from the shorter array is compared. The comparison stops when the first difference is spotted.

<div class="p"><!----></div>
If there are slice definitions in one or both arrays, they will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
If a mismatch is found the result is greater than zero and the <i>mismatch</i> argument will contain the index of the first element that compared
unequal. This will be always the case for arrays of different length.

<div class="p"><!----></div>
If both arrays are the same length and no differences are found the result is zero and the value pointed to by the
<i>mismatch</i> argument is one more than the length of the arrays.

<div class="p"><!----></div>
If an error occurs, a negative error code is returned. The <i>mismatch</i> argument contains zero.

<div class="p"><!----></div>
 
<br /><a 
name="MultiplyWith+\container143"></a> <font size="+1"><b>MultiplyWith</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*MultiplyWith)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Multiplies each element of the right argument with the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left *= right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="MultiplyWithScalar+\container143"></a> <font size="+1"><b>MultiplyWithScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*MultiplyWithScalar)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Multiplies each element of the left argument with the right argument. Conceptually this operation is: <font size="+1"><tt>left *= right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None. Some implementations could detect a bad pointer.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Not+\container143"></a> <font size="+1"><b>Not</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Not)(ValArray&nbsp;*v);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise Not operation of each element of the argument. Conceptually this operation is: <font size="+1"><tt>v&nbsp;=&nbsp;~v</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning. If a slice is active, only its elements will be affected.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Or+\container143"></a> <font size="+1"><b>Or</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise or operation between each element of the right argument with the corresponding element of the left argument. Conceptually this
operation is: <font size="+1"><tt>left&nbsp;|=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning. This operation will only affect the elements in the active slice, if a slice is active.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="OrScalar+\container143"></a> <font size="+1"><b>OrScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(ValArray&nbsp;*left,ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise or operation between each element of the left argument with the right argument. Conceptually this operation is: <font size="+1"><tt>left&nbsp;|=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="PopBack+\container143"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*PopBack)(ValArray&nbsp;*AL,ElementType&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the last element into the given result buffer and deletes the element from the container. If the result buffer is &nbsp;NULL , no copy is performed.
If a slice specification is active, the element deleted will be the last element of the slice, and the length of the slice will be reduced by one.
If the slice becomes empty, the slice specifications are reset.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
A negative value if an error occurs, zero if the array is empty or greater than zero if the operation succeeded.

<div class="p"><!----></div>
 
<br /><a 
name="Product+\container143"></a> <font size="+1"><b>Product</b></font> <hr />


<font size=+1><pre>

ElementType&nbsp;(*Product)(ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Calculates the product of all the elements of the given vector. If a slice definition is active only the slice elements are considered.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None are mandatory but implementations should check for overflow when possible.

<div class="p"><!----></div>
<b>Returns:</b>The product of the elements.

<div class="p"><!----></div>
 
<br /><a 
name="Reverse+\container143"></a> <font size="+1"><b>Reverse</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Reverse)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reverses the order of the elements of the given array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory for intermediate storage available

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.

<div class="p"><!----></div>
 
<br /><a 
name="ResetSlice+\container143"></a> <font size="+1"><b>ResetSlice</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ResetSlice)(ValArray&nbsp;*array);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Eliminates any slices specifications from the given array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>If a slice specification was removed returns 1, if no slice was defined in the given array returns zero.

<div class="p"><!----></div>
 
<br /><a 
name="RotateLeft+\container143"></a> <font size="+1"><b>RotateLeft</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(ValArray&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates left the array by the indicated amount. The first n elements will be written to the end of
the array, and the rest will be shifted left to fill the empty n places.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size).


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValArrayInt&nbsp;*&nbsp;vInt&nbsp;=&nbsp;iValArrayInt.CreateSequence(24,0,1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;array:&nbsp;\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Rotating&nbsp;left&nbsp;by&nbsp;4\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.RotateLeft(vInt,4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Rotating&nbsp;left&nbsp;by&nbsp;48\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.RotateLeft(vInt,48);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Rotating&nbsp;left&nbsp;by&nbsp;55\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.RotateLeft(vInt,55);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Finalize(vInt);
}

OUTPUT
Original&nbsp;array:&nbsp;
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;
Rotating&nbsp;left&nbsp;by&nbsp;4
4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;
Rotating&nbsp;left&nbsp;by&nbsp;48
4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;
Rotating&nbsp;left&nbsp;by&nbsp;55
11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="RotateRight+\container143"></a> <font size="+1"><b>RotateRight</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(ValArray&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates right the array by the indicated amount. The last n elements will be written to the start of
the array, and the rest will be shifted right.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size).

<div class="p"><!----></div>
 
<br /><a 
name="Save+\container143"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;ValArray&nbsp;*AL,&nbsp;FILE&nbsp;*out);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given ValArray are saved into the given stream. This function is a simplified version of the Save function in the Vector container
since it doesn't feature a save function. Since ValArrays hold primitive types they are saved in a single write into the output stream.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
EOF A disk input/output error occurred.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="SetCompareFunction+\container143"></a> <font size="+1"><b>SetCompareFunction</b></font> <hr />


<font size=+1><pre>

CompareFunction&nbsp;(*SetCompareFunction)(ValArray&nbsp;*AL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;f);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function does nothing and returns always &nbsp;NULL . It is retained for compatibility purposes with other containers.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>Always &nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="Select+\container143"></a> <font size="+1"><b>Select</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Select)(ValArray&nbsp;*va,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Using the given mask, the elements where the corresponding mask element is zero are eliminated, those with a mask
value different of zero are retained. The mask must have the same length as the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The mask and the array are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m&nbsp;=&nbsp;iMask.Create(18);
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayInt&nbsp;*va&nbsp;=&nbsp;iValArrayInt.CreateSequence(18,0,1);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;18;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMask.Set(m,i,(i&amp;1)&nbsp;?&nbsp;0&nbsp;:&nbsp;1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(va,stdout,"%3d&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Select(va,m);
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(va,stdout,"%3d&nbsp;");
}
OUTPUT:
0&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15&nbsp;&nbsp;16&nbsp;&nbsp;17
0&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;10&nbsp;&nbsp;12&nbsp;&nbsp;14&nbsp;&nbsp;16&nbsp;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SelectCopy+\container143"></a> <font size="+1"><b>SelectCopy</b></font> <hr />


<font size=+1><pre>

ValArray&nbsp;*(*SelectCopy)(ValArray&nbsp;*va,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Using the given mask, the elements where the corresponding mask element is different from zero are copied into a new array, those with a mask
value different of zero are ignored. The mask must have the same length as the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The mask and the array are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="SetSlice+\container143"></a> <font size="+1"><b>SetSlice</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SetSlice)(ValArray&nbsp;*s,size_t&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;length,size_t&nbsp;increment);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Defines a slice for the given array. The slice starts at the given index, and has <font size="+1"><tt>length</tt></font> elements. Between each element and the next
there are <font size="+1"><tt>increment</tt></font> positions. All operations done with the array will be done to the elements defined by the slice.

<div class="p"><!----></div>
Constraints:

<ul>
<li> The <font size="+1"><tt>start</tt></font> argument can't be greater or equal than the number of elements in the array.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>increment</tt></font> argument must be greater than zero
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>length</tt></font> argument must be greater than zero. If it is greater than the number of elements in the array or greater than the number of 
elements that would fit with the given increment and start it will be adjusted accordingly.
<div class="p"><!----></div>
</li>
</ul>
If any slice specification was defined for the given array it will be replaced by the new one.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of the arguments doesn't meet the above constraints.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

. There is no memory to allocate the slice specifications.

<div class="p"><!----></div>
<b>Returns:</b>
Positive number if successful; negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container143"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total number of elements stored in the array. If there is a slice definition it will <font size="+1"><tt>not</tt></font> be used. To know the size of a slice use the<font size="+1"><tt>GetSlice</tt></font> API.

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container143"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the ValArray, including the header, and all data stored in it. If the argument is &nbsp;NULL , the size of the header only is returned.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the vector or the size of the ValArray header if the argument is &nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="Sort+\container143"></a> <font size="+1"><b>Sort</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sorts the given array. The order of the original array is destroyed. You should copy it if you want to preserve it. If a slice specification is active
only the elements in the slice will be sorted.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Temporary storage for the operation is absent.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if sorting succeeded, a negative error code if not.

<div class="p"><!----></div>
 
<br /><a 
name="SubtractFrom+\container143"></a> <font size="+1"><b>SubtractFrom</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractFrom)(ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Subtracts each element of the right argument from the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left -= right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="SubtractFromScalar+\container143"></a> <font size="+1"><b>SubtractFromScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractFromScalar)(ElementType&nbsp;left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Subtracts from the left argument the right argument. Conceptually this operation is: <font size="+1"><tt>right = left - right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="SubtractScalarFrom+\container143"></a> <font size="+1"><b>SubtractScalarFrom</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractScalarFrom)(ValArray&nbsp;*left,ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Subtracts from the left argument the right argument. Conceptually this operation is: <font size="+1"><tt>left -= right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="SumTo+\container143"></a> <font size="+1"><b>SumTo</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SumTo)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds each element of the right argument to the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left += right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="SumToScalar+\container143"></a> <font size="+1"><b>SumToScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SumTo)(ValArray&nbsp;*left,ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds each element of the left argument the right argument. Conceptually this operation is: <font size="+1"><tt>left += right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Xor+\container143"></a> <font size="+1"><b>Xor</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Xor)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise Xor operation between each element of the right argument with the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left&nbsp;^=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="XorScalar+\container143"></a> <font size="+1"><b>XorScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*XorScalar)(ValArray&nbsp;*left,ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise Xor operation between each element of the left argument with the right argument. Conceptually this operation is: <font size="+1"><tt>left&nbsp;^=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc15">
15</a>&nbsp;&nbsp;Buffers</h2>
<a 
name="Buffers150"></a>
The buffers interface is greatly simplified compared to the interface of a general container. 
The usage of a buffer as an intermediate storage means there is no sense in including all  the functionality of a container. The library provides two 
types:

<ol type="1">
<li> Stream buffers provide linear storage that grows automatically as needed.
<div class="p"><!----></div>
</li>

<li> Circular buffers store the last n items of a stream
<div class="p"><!----></div>
</li>
</ol>
Other languages provide similar features:

<ul>
<li> The Java language provides a typed buffer functionality. This buffers are not resizable, have a cursor and other more sophisticated operations 
than the buffers proposed here like slicing and compacting.Their place in the Java class hierarchy is: Object &#8594; Native I/O &#8594; 
ByteBuffer. There are methods for viewing the buffer as float, doubles, etc.
<div class="p"><!----></div>
</li>

<li> The C# language provides also a typed buffer class of the primitive types (char, float, int, etc). It is called System.Buffer and provides a few 
methods for determining its length and read/write a single byte. The language itself doesn't provide any circular buffers class but several 
implementations are available in the net. The same situation applies for Java.
<div class="p"><!----></div>
</li>

<li> The C++ STL doesn't provide circular buffers directly but the <font size="+1"><tt>boost</tt></font> C++ library does provide an implementation. See:

<div class="p"><!----></div>
<font size="-1">http://www.boost.org/doc/libs/1_48_0/libs/circular_buffer/doc/circular_buffer.html</font>

<div class="p"><!----></div>
In the usual simplicity of that language, the class has around 60 entry points, including specialized templates for some functions. Around 14 auxiliary 
types are involved and the documentation for this component goes for around 50 pages. That is the exact opposite of this proposal.
<div class="p"><!----></div>
</li>
</ul>
The design objective in this library is to keep buffers small and, while providing functionality, reduce the interface to a minimum. Compacting is not 
feasible in C due to the wide use of pointers. If there is a pointer to the data in the buffer, moving it would invalidate the pointer making for hard 
to debug crashes <a href="#tthFtNtAFI" name="tthFrefAFI"><sup>58</sup></a>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc15.1">
15.1</a>&nbsp;&nbsp;Stream buffers</h3>

<div class="p"><!----></div>
<img src="StreamBuffer.png" alt="Figure">
<div class="p"><!----></div>
These objects are designed to store sequentially arbitrary data, resizing themselves as necessary. There is a cursor, a pointer that indicates where 
the next data item will be written. You can move the cursor, overwriting old data, or leaving holes in the buffer structure
<a href="#tthFtNtAFJ" name="tthFrefAFJ"><sup>59</sup></a>
.  

<div class="p"><!----></div>
      <h4><a name="tth_sEc15.1.1">
15.1.1</a>&nbsp;&nbsp;The interface</h4>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagStreamBufferInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*Create)(size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*CreateFromFile)(const&nbsp;char&nbsp;*FileName);
&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsize,
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*GetData)(const&nbsp;StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetPosition)(const&nbsp;StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Read)(StreamBuffer&nbsp;*b,&nbsp;void&nbsp;*data,&nbsp;size_t&nbsp;siz);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReadFromFile)(StreamBuffer&nbsp;*b,FILE&nbsp;*f);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(StreamBuffer&nbsp;*b,size_t&nbsp;newSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetPosition)(StreamBuffer&nbsp;*b,size_t&nbsp;pos);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Write)(StreamBuffer&nbsp;*b,void&nbsp;*data,&nbsp;size_t&nbsp;siz);
&nbsp;&nbsp;&nbsp;int&nbsp;(*WriteToFile)(StreamBuffer&nbsp;*b,FILE&nbsp;*f);
}&nbsp;StreamBufferInterface;

</pre></font>


      <h4><a name="tth_sEc15.1.2">
15.1.2</a>&nbsp;&nbsp;The API</h4>
Noteworthy are the two functions that work with with buffers and files: <font size="+1"><tt>ReadFromFile</tt></font> and <font size="+1"><tt>WriteToFile</tt></font>. The allow you to work with a buffer when the file can't be read in one buffer, allowing
piecewise processing of portions of the file. 

<div class="p"><!----></div>
The function <font size="+1"><tt>CreateFromFile</tt></font> allows you to read all the file contents into a buffer.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container151"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the cursor at position zero and zeroes the whole buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given buffer pointer is &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container151"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*Create)(size_t&nbsp;startsize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new buffer with the given start size. If the size is zero it will use a default start value. The allocator used is the current memory manager.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. There is no more memory to create the buffer.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a newly created buffer or &nbsp;NULL if there is no more memory left.

<div class="p"><!----></div>
 
<br /><a 
name="CreateFromFile+\container151"></a> <font size="+1"><b>CreateFromFile</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*CreateFromFile)(const&nbsp;char&nbsp;*FileName);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new buffer with the contents of the given file. The allocator used is the current memory manager. The file is read in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. There is no more memory to create the buffer.

<div class="p"><!----></div>
CONTAINER_ERROR_NOENT

 The file given can't be found (or it exists but the current user has no read permission).

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a newly created buffer or &nbsp;NULL if there is no more memory left or the file can't be opened.
 
<div class="p"><!----></div>
<br /><a 
name="CreateWithAllocator+\container151"></a> <font size="+1"><b>CreateWithAllocator</b></font> <hr />


<font size=+1><pre>

StreamBuffer&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsize,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new buffer using the given allocator and start size. If the start size is zero a default value is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is no more memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the new buffer or &nbsp;NULL if there is no memory left.
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container151"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Releases all memory used by the buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given buffer pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="GetData+\container151"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*(*GetData)(const&nbsp;StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the data stored in the buffer. The data is read-only (const).

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given buffer pointer is &nbsp;NULL 


<div class="p"><!----></div>
 <b>Invariants:</b>
The given buffer is not modified. The returned pointer should not be modified.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the buffer's data or NULL, if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="GetPosition+\container151"></a> <font size="+1"><b>GetPosition</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetPosition)(const&nbsp;StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the current cursor position.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The stream buffer pointer is &nbsp;NULL 

<div class="p"><!----></div>
CONTAINER_ERROR_WRONG_ITERATOR

 The given iterator is not of the correct type.


<div class="p"><!----></div>
 <b>Invariants:</b>
The stream buffer is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The cursor position or <font size="+1"><tt>(size_t)-1</tt></font> if there is an error. Note that <font size="+1"><tt>(size_t)-1</tt></font> is also a valid cursor position.<a href="#tthFtNtAGA" name="tthFrefAGA"><sup>60</sup></a>
 
<div class="p"><!----></div>
<br /><a 
name="Read+\container151"></a> <font size="+1"><b>Read</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Read)(StreamBuffer&nbsp;*b,&nbsp;void&nbsp;*data,&nbsp;size_t&nbsp;siz);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads <i>siz</i> bytes from the given buffer, starting from the position of the cursor. If the buffer finishes before <i>siz</i> characters are
read, reading stops, and less characters than requested are returned. It is assumed that the <i>data</i> buffer contains at least <i>siz</i> 
characters.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either the stream buffer, the data buffer are &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
None. The given buffer is modified since the cursor is updated to the new position. The given buffer is modified since the data is copied 
into it.

<div class="p"><!----></div>
<b>Returns:</b>The number of characters copied or zero if there is an error. Note that if the number of requested characters is zero, this function
will also return zero.
 
<div class="p"><!----></div>
<br /><a 
name="ReadFromFile+\container151"></a> <font size="+1"><b>ReadFromFile</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*ReadFromFile)(StreamBuffer&nbsp;*b,FILE&nbsp;*f);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Fills the given buffer with data from the given file. The cursor is reset to position zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The stream buffer pointer is &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>The number of bytes read or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Resize+\container151"></a> <font size="+1"><b>Resize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(StreamBuffer&nbsp;*b,size_t&nbsp;newSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Resizes the buffer to the requested size. The new size can be bigger or smaller than the current size. All pointers to the data in the buffer 
are invalid after this operation.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The stream buffer pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to satisfy the request.

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs, zero if the requested size is equal to the current size, or a positive number
if the request was satisfied.
 
<div class="p"><!----></div>
<br /><a 
name="SetPosition+\container151"></a> <font size="+1"><b>SetPosition</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SetPosition)(StreamBuffer&nbsp;*b,&nbsp;size_t&nbsp;pos);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the cursor at the given position. If the position is bigger than the size of the buffer the cursor is moved to the end of the buffer.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given buffer pointer is &nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Size+\container151"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Size)(const&nbsp;StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Returns the allocated size of the buffer. If the buffer pointer is &nbsp;NULL returns the size of the buffer header.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None


<div class="p"><!----></div>
 <b>Invariants:</b>
The given buffer is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The size of the buffer.
 
<div class="p"><!----></div>
<br /><a 
name="Write+\container151"></a> <font size="+1"><b>Write</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Write)(StreamBuffer&nbsp;*b,void&nbsp;*data,&nbsp;size_t&nbsp;siz);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Writes into the buffer <i>siz</i> characters from the passed pointer <i>data</i>. The characters are written starting at the cursor
position. If the buffer is too small to hold the data, it will be enlarged using its allocator. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. There is no more memory to enlarge the buffer.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The stream buffer pointer or the data pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The number of characters written.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*sb&nbsp;=&nbsp;iStreamBuffer.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[20],*p;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(buf,"item&nbsp;%d",i+1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iStreamBuffer.Write(sb,buf,1+strlen(buf));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[0]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iStreamBuffer.Write(sb,&amp;buf,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Buffer&nbsp;size&nbsp;is:&nbsp;%d,&nbsp;position&nbsp;is&nbsp;%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)iStreamBuffer.Size(sb),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)&nbsp;iStreamBuffer.GetPosition(sb));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iStreamBuffer.SetPosition(sb,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;iStreamBuffer.GetData(sb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*p)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;+=&nbsp;1&nbsp;+&nbsp;strlen(p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iStreamBuffer.Finalize(sb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
OUTPUT:
Buffer&nbsp;size&nbsp;is:&nbsp;82,&nbsp;position&nbsp;is&nbsp;72
item&nbsp;1
item&nbsp;2
item&nbsp;3
item&nbsp;4
item&nbsp;5
item&nbsp;6
item&nbsp;7
item&nbsp;8
item&nbsp;9
item&nbsp;10

</pre></font>
This example does the following:

<ul>
<li> Creates a stream buffer. It assumes success and does not test the return value of the creation function. The buffer is dimensioned too small 
for the data it will contain so it has to resize several times.
<div class="p"><!----></div>
</li>

<li> Prepares a string buffer with sprintf and writes the resulting string including its terminating zero in the stream buffer. Note that
zeroes have no special significance in buffers. It loops ten times doing this operation.
<div class="p"><!----></div>
</li>

<li> It ends the buffer with a terminating double zero.
<div class="p"><!----></div>
</li>

<li> It prints the buffer size and the number of characters it has written. Note that they are not the same. The buffer has been resized 
several times, and at each time the new capacity is determined by an internal algorithm. Since we did not move the cursor the position of the
cursor give us the number of characters written.
<div class="p"><!----></div>
</li>

<li> It obtains a pointer to the data in the buffer
<div class="p"><!----></div>
</li>

<li> It prints all the strings in the buffer to standard output. Each character string from 1 to 9 is 7 bytes long, including its terminating zero.
The tenth string is 9 bytes, also including the terminating zero. We have then: (7*9)+9 = 72.
<div class="p"><!----></div>
</li>

<li> It destroys the buffer.
<div class="p"><!----></div>
</li>
</ul>
 
<div class="p"><!----></div>
<br /><a 
name="WriteToFile+\container151"></a> <font size="+1"><b>WriteToFile</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*WriteToFile)(StreamBuffer&nbsp;*b,FILE&nbsp;*outfile);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Writes all the contents of the given buffer to the given file. The cursor is reset to the begin of the buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The stream buffer pointer or the file pointer is&nbsp;NULL 
returns The number of bytes written.

     <h3><a name="tth_sEc15.2">
15.2</a>&nbsp;&nbsp;Circular buffers</h3>
<img src="Circular.png" alt="Figure">
<div class="p"><!----></div>
This objects are designed to store the last n items of a stream. When they are full, the new items are stored in the same place as the oldest
item <a href="#tthFtNtAGB" name="tthFrefAGB"><sup>61</sup></a>. 

      <h4><a name="tth_sEc15.2.1">
15.2.1</a>&nbsp;&nbsp;The interface: iCircularBuffer</h4>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagCircularBufferInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(&nbsp;CircularBuffer&nbsp;*&nbsp;b,&nbsp;const&nbsp;void&nbsp;*data_element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(CircularBuffer&nbsp;*cb);
&nbsp;&nbsp;&nbsp;&nbsp;CircularBuffer&nbsp;*(*CreateWithAllocator)(size_t&nbsp;sizElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;sizeBuffer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;&nbsp;CircularBuffer&nbsp;*(*Create)(size_t&nbsp;sizElement,size_t&nbsp;sizeBuffer);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(CircularBuffer&nbsp;*cb);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(CircularBuffer&nbsp;*b,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PeekFront)(CircularBuffer&nbsp;*b,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;CircularBuffer&nbsp;*cb);
&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;SetDestructor(CircularBuffer&nbsp;*cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;NewFn);
}&nbsp;CircularBufferInterface;

</pre></font>

      <h4><a name="tth_sEc15.2.2">
15.2.2</a>&nbsp;&nbsp;The API</h4>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container152"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*Add)(&nbsp;CircularBuffer&nbsp;*&nbsp;b,&nbsp;const&nbsp;void&nbsp;*data_element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given data element to the circular buffer. If the buffer is full, the oldest element's place will be overwritten with the new data
and the container remains full with the same number of elements. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The given data element is not modified but copied into the container.

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs. If the container is full zero is returned. If a new element was added a positive number is returned.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container152"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*Clear)(CircularBuffer&nbsp;*cb);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Resets the number of elements inside the container to empty without freeing the memory used by the buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer b is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs, or a positive number when the container is reset.
 
<div class="p"><!----></div>
<br /><a 
name="CreateWithAllocator+\container152"></a> <font size="+1"><b>CreateWithAllocator</b></font> <hr />


<font size=+1><pre>

	CircularBuffer&nbsp;*(*CreateWithAllocator)(size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;sizeBuffer,&nbsp;ContainerAllocator&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates an empty circular buffer that can hold at most sizeBuffer elements, each element being of size ElementSize. Uses the given allocator
to allocate memory.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both sizes are zero, or the allocator pointer is &nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEM

 There is no memory left.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new circular buffer or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container152"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

	CircularBuffer&nbsp;*(*Create)(size_t&nbsp;ElementSize,&nbsp;size_t&nbsp;sizeBuffer);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates an empty circular buffer that can hold at most sizeBuffer elements, each element being of size ElementSize. Uses the CurrentAllocator
to allocate memory.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are zero.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEM

 There is no memory left.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new circular buffer or &nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container152"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*Finalize)(CircularBuffer&nbsp;*cb);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the given buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if the container is destroyed, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="PeekFront+\container152"></a> <font size="+1"><b>PeekFront</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*PeekFront)(CircularBuffer&nbsp;*b,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies one item from the front of the circular buffer into the given buffer without removing the item from the container. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer or the result buffer are &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs, zero if the buffer was empty, or a positive number if an item was copied.

<div class="p"><!----></div>
 
<br /><a 
name="PopFront+\container152"></a> <font size="+1"><b>PopFront</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*PopFront)(CircularBuffer&nbsp;*b,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies one item from the front of the circular buffer into the given buffer and removes the item from the container. If the result pointer is &nbsp;NULL 
the item is removed but nothing is copied.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer is &nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs, zero if the buffer was empty, or a positive number if an item was removed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;CircularBuffer&nbsp;*cb&nbsp;=&nbsp;iCircularBuffer.Create(sizeof(int),10);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,integer;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;20;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iCircularBuffer.Add(cb,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("There&nbsp;are&nbsp;%d&nbsp;elements\n",iCircularBuffer.Size(cb));
&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;container&nbsp;uses&nbsp;%d&nbsp;bytes\n",iCircularBuffer.Sizeof(cb));
&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;size&nbsp;of&nbsp;the&nbsp;header&nbsp;is&nbsp;%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iCircularBuffer.Sizeof(NULL));
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Print&nbsp;all&nbsp;elements&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(iCircularBuffer.PopFront(cb,&amp;integer)&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d&nbsp;",integer);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
There&nbsp;are&nbsp;10&nbsp;elements
The&nbsp;container&nbsp;uses&nbsp;88&nbsp;bytes
The&nbsp;size&nbsp;of&nbsp;the&nbsp;header&nbsp;is&nbsp;48
10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Size+\container152"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Size)(const&nbsp;CircularBuffer&nbsp;*cb);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of items in the given circular buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer is &nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The given buffer is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The number of items in the buffer.
 
<div class="p"><!----></div>
<br /><a 
name="Sizeof+\container152"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Sizeof)(const&nbsp;CircularBuffer&nbsp;*cb);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of bytes used by given circular buffer. If the pointer is &nbsp;NULL returns the size of the circular buffer header structure.


<div class="p"><!----></div>
 <b>Invariants:</b>
the given buffer is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The number of bytes used by the buffer.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc16">
16</a>&nbsp;&nbsp;The generic interfaces</h2>
This interface allows the user to use containers in a generic way, ignoring its specific type.
Note that there is no "GenericContainer" object; you can't create any generic container. Once a specific container is created, it can be used as a generic container at any time since all containers comply with the generic interface. This interface just dispatches internally to the actual container and therefore incurs in a slight performance cost.
<a href="#tthFtNtAGC" name="tthFrefAGC"><sup>62</sup></a>

<div class="p"><!----></div>
Conceptually, the generic interfaces represent a base class (GenericContainer) and two derived classes: Sequential and Associative containers.
It would be possible to derive more classes, for instance a numeric container class that could be implemented in the future, This is left open for future releases of this specification.
<a href="#tthFtNtAGD" name="tthFrefAGD"><sup>63</sup></a>

     <h3><a name="tth_sEc16.1">
16.1</a>&nbsp;&nbsp;Generic containers</h3>
The general generic interface that encloses associative and sequential containers is as follows:
<a 
name="iGenericContainer161"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;GenericContainer&nbsp;GenericContainer;
typedef&nbsp;struct&nbsp;tagGenericContainerInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(GenericContainer&nbsp;*Gen,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(GenericContainer&nbsp;*Gen,void&nbsp;*Value);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(GenericContainer&nbsp;*Gen,void&nbsp;*objectToDelete);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;(*Apply)(GenericContainer&nbsp;*Gen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Applyfn)(void&nbsp;*,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(GenericContainer&nbsp;*Gen1,GenericContainer&nbsp;*Gen2);
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainer&nbsp;*(*Copy)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(GenericContainer&nbsp;*Gen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DeleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(GenericContainer&nbsp;*Gen,FILE&nbsp;*stream,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainer&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReadFunction&nbsp;readFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;GetElementSize(GenericContainer&nbsp;*Gen);
}&nbsp;GenericContainerInterface;
extern&nbsp;GenericContainerInterface&nbsp;iGenericContainer;

</pre></font>
This functions return the obvious results already described in the documentation of their container-specific counterparts and not repeated here. We only note the absence of a creation function, or any means to add an object.
<a href="#tthFtNtAGE" name="tthFrefAGE"><sup>64</sup></a>

<div class="p"><!----></div>
Based on the generic interface, we have generic sequential and associative interfaces. They contain generic functions for adding and removing objects.

     <h3><a name="tth_sEc16.2">
16.2</a>&nbsp;&nbsp;Sequential containers</h3>
These containers include all the functions of the GenericContainer interface, adding functions to use any sequential container as a stack, and functions for managing object replacement or addition.
<a 
name="iSequentiaContainer162"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;SequentialContainer&nbsp;SequentialContainer;
typedef&nbsp;struct&nbsp;tagSequentialContainerInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainerInterface&nbsp;Generic;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(SequentialContainer&nbsp;*SC,void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(SequentialContainer&nbsp;*SC,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Push)(SequentialContainer&nbsp;*Gen,void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Pop)(SequentialContainer&nbsp;*Gen,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(SequentialContainer&nbsp;*SC,size_t&nbsp;idx,&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(SequentialContainer&nbsp;*SC,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(SequentialContainer&nbsp;*SC,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx,&nbsp;void&nbsp;*element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(SequentialContainer&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ElementToFind,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(SequentialContainer&nbsp;*SC1,SequentialContainer&nbsp;*SC2);
}&nbsp;SequentialContainerInterface;
extern&nbsp;SequentialContainerInterface&nbsp;iSequentialContainer;

</pre></font>

     <h3><a name="tth_sEc16.3">
16.3</a>&nbsp;&nbsp;Associative containers</h3>
These containers include all the functions of the GenericContainer interfaces and add functions for inserting and removing objects.
<a 
name="iAssociativeContainer163"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;AssociativeContainer&nbsp;AssociativeContainer;
typedef&nbsp;struct&nbsp;tagAssociativeContainerInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainerInterface&nbsp;Generic;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(SequentialContainer&nbsp;*SC,void&nbsp;*key,void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(AssociativeContainer&nbsp;*SC,void&nbsp;*Key);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(AssociativeContainer&nbsp;*SC,&nbsp;void&nbsp;*Key,&nbsp;void&nbsp;*element);
}&nbsp;AssociativeContainerInterface;
extern&nbsp;AssociativeContainerInterface&nbsp;iAssociativeContainer;

</pre></font> 

 <h1><a name="tth_chAp7">
Chapter 7 </a><br />Enhancing the library</h1>
No design can ever cover all special cases that can arise during development. The advantage of the interface design is that you can enhance the library by subclassing functions that add functionality you need when absent.
Subclassing means in this context that you replace a function of the library with a new function written by you that either replaces completely the functionality of the library or that either before or after the library function adds some code that implements an enhancement.

<div class="p"><!----></div>
There are several ways to enhance the library in this way:

<ol type="1">
<li> Replace the function in the container interface object. This affects all containers of this type, including those that are already created. This involves simply assigning to the function you want to replace a new function pointer that points to a compatible function. You can save the old value and add some functionality, call the old function pointer to do what the library does, then you can add code that runs after the old library function has finished.
<div class="p"><!----></div>
</li>

<li> Replace the function in a copy of the functions table of a single object. This way is less intrusive than the former, since only one container is affected: the one where you modify the function table. The downside is that instead of using the simple syntax:
<div class="p"><!----></div>
 <font size="+1"><tt>iList.Add</tt></font> 
<div class="p"><!----></div>
 you have to use the container's table:
<div class="p"><!----></div>
 <font size="+1"><tt>Container-&#62;VTable-&#62;Add(...)</tt></font> 
<div class="p"><!----></div>
 This represents quite a different syntax, but this can be less of a problem if you hide it under some convenient macros <a href="#tthFtNtAGF" name="tthFrefAGF"><sup>65</sup></a>.

<div class="p"><!----></div>
On the up side, another advantage of this syntax is that you do not need to change your source code if you change the type of the container. If you write: 
<div class="p"><!----></div>
  <font size="+1"><tt>myContainer-&#62;Vtable-&#62;Add(myContainer,object);</tt></font>
<div class="p"><!----></div>
  this will stay the same for lists, arrays, string collections or whatever sequential container you are using. You can then change completely the type of the container just by changing the declaration.
<div class="p"><!----></div>
</li>
</ol>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Adding conversions between containers</h2>
Converting one type of container into another, or creating a new container with some or all the data of an existing one are routine operations not
specified in the core library.

<div class="p"><!----></div>
The reason is that there is a downside to the interface definitions as presented here: all functions within an interface module are declared 
<font size="+1"><tt>static</tt></font> to avoid polluting the user name space with those names. This has the consequence that interfaces are a monolithic  piece of
code that can't be cut in smaller pieces.

<div class="p"><!----></div>
Converting an object from type &#196;" to another of type "B" implies then that we have <b>both</b> interfaces present. If for every container
we would define a conversion into all others, the function table of each container would need all other interfaces and if a user uses just
a single container it would need to link with the <b>whole</b> library. To avoid this problem, no conversions are specified even when surely
converting a ValArrayInt into a ValArrayDouble is an operation that will be needed sooner or later.

<div class="p"><!----></div>
There are many solutions to this problem using the existing APIs:

<ol type="1">
<li> Using a simple loop:

<font size=+1><pre>
ValArrayDouble&nbsp;*CastToDouble(ValArrayInt&nbsp;*src)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iValArrayInt.Size(src);
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayDouble&nbsp;*result&nbsp;=&nbsp;iValArrayDouble.Create(siz);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;siz;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;iValArrayInt.GetElement(src,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iValArrayDouble.Add(result,d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
This function stops at an error returning a partial result. Other error handling strategies could be to finalize the 
incomplete container and return &nbsp;NULL , or call the iError interface and then do a long jump to a recovery point, etc.
<div class="p"><!----></div>
</li>

<li> Using iterators:

<font size=+1><pre>
ValArrayDouble&nbsp;*CastToDouble(ValArrayInt&nbsp;*src)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iValArrayInt.Size(src);
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayDouble&nbsp;*result&nbsp;=&nbsp;iValArrayDouble.Create(siz);
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iValArrayInt.NewIterator(src);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*ip;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(ip&nbsp;=&nbsp;it-&#62;GetFirst(src);&nbsp;ip;ip&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iValArrayDouble.Add(result,*ip);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.DeleteIterator(it);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
<div class="p"><!----></div>
</li>

<li> Using the Apply API.
There are surely more complex requirements for conversions. For instance we could need to extract only certain parts of the input 
container. In that case
writing a special function to be called by <font size="+1"><tt>Apply</tt></font> is justified. For instance if we have an array of structures representing customers
we could want to make a string collection with the names of all of them. 

<font size=+1><pre>
//&nbsp;We&nbsp;want&nbsp;to&nbsp;extract&nbsp;the&nbsp;second&nbsp;field&nbsp;of&nbsp;this&nbsp;structure
struct&nbsp;customer&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;NumericID;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*Name;
&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;double&nbsp;Balance;
};

int&nbsp;ApplyFn(void&nbsp;*data,void&nbsp;*container)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;customer&nbsp;*pData&nbsp;=&nbsp;(struct&nbsp;customer&nbsp;*)data;
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*Collection&nbsp;=&nbsp;(strCollection&nbsp;*)container;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;istrCollection.Add(Collection,pData-&#62;Name);
}&nbsp;&nbsp;

strCollection&nbsp;*GetAllNames(Vector&nbsp;*CustomerDB)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iVector.Size(CustomerDB);
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*result&nbsp;=&nbsp;istrCollection.Create(siz);
&nbsp;&nbsp;&nbsp;&nbsp;iVector.Apply(CustomerDB,ApplyFn,result);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
<div class="p"><!----></div>
</li>
</ol>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Infinite arrays</h2>
We can conceptually define an array as a function that maps an input value <i>index</i> into some output that is the <i>value</i> of the
array at that position.

<div class="p"><!----></div>
In this context, an infinite array is a function that maps any member from the set of positive natural numbers  (a <font size="+1"><tt>size_t</tt></font>) into some resulting value. This function must have a value for all possible input values of its <font size="+1"><tt>size_t</tt></font> argument. For instance the function
value=(index+5)/(index&#8722;5) is not usable since it would provoke a division by zero at index=5.

<div class="p"><!----></div>
Infinite arrays exist in many computer languages.


<ul>
<li> In APL they were proposed by McDonnel and Shallit in their paper &#203;xtending APL to Infinity" <a href="#tthFtNtAGG" name="tthFrefAGG"><sup>66</sup></a>.
<div class="p"><!----></div>
</li>

<li> Common lisp has the "Series" construct that is similar to infinite arrays.
<div class="p"><!----></div>
</li>

<li> The Translucid computer language features each variable as an infinite array of all its values
<a href="#tthFtNtAGH" name="tthFrefAGH"><sup>67</sup></a>

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
Since in the C language arrays must contain elements of the same type, obvious restrictions apply: all C types have specific bounds (defined in the
appropriate headers) so that a conceptually correct function like the Fibonacci function for instance, is not usable beyond a certain value of the
input index because of output overflow: the Fibonacci numbers grow without limit.

<div class="p"><!----></div>
To implement an infinite array using the library is relatively easy. The <font size="+1"><tt>iVector</tt></font> interface has the necessary hooks for doing this.
When an index error occurs, the library calls the error function of the given vector passing it the name of the function, the integer constant 
<font size="+1"><tt>CONTAINER_ERROR_INDEX</tt></font> and a pointer to the array and the requested index. If the error function returns any other value than &nbsp;NULL ,
the Library will assume that it is a valid pointer to some result where the real value of the array at that position is stored.

<div class="p"><!----></div>
Using this information we can write this first simple implementation of an infinite array. The array function will be the <i>identity</i> function
i.e. the array will contain the value of the index at each position.

<font size=+1><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#include&nbsp;&lt;stdarg.h&#62;
#include&nbsp;&lt;stdlib.h&#62;
#include&nbsp;"containers.h"
static&nbsp;ErrorFunction&nbsp;oldErrorFn;

static&nbsp;void&nbsp;*Fn(const&nbsp;char&nbsp;*msg,int&nbsp;errorCode,...)
{
&nbsp;&nbsp;&nbsp;&nbsp;va_list&nbsp;ap;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*v;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(errorCode&nbsp;!=&nbsp;CONTAINER_ERROR_INDEX)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;oldErrorFn(msg,errorCode);
&nbsp;&nbsp;&nbsp;&nbsp;va_start(ap,errorCode);
&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;va_arg(ap,Vector&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;va_arg(ap,size_t);
&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;va_end(ap);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&amp;value;
}

Vector&nbsp;*CreateInfiniteArray(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;VectorInterface&nbsp;*ivct;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*result&nbsp;=&nbsp;iVector.Create(sizeof(int),1);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;result;
&nbsp;&nbsp;&nbsp;&nbsp;oldErrorFn&nbsp;=&nbsp;iVector.SetErrorFunction(result,&nbsp;Fn);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*v&nbsp;=&nbsp;CreateInfiniteArray();
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=20;&nbsp;i&lt;30;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d&nbsp;",*(int&nbsp;*)iVector.GetElement(v,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
&nbsp;&nbsp;&nbsp;&nbsp;iVector.Finalize(v);
}


</pre></font>
The central piece of the implementation is the <font size="+1"><tt>Fn</tt></font> function (lines 6 to 20) 
that will be our replacement of the default vector error function. This function
will only return something if the error is an error index (line 12). Otherwise it calls the default function stored in a static pointer.

<div class="p"><!----></div>
If the error is the expected index error, we fetch the arguments (lines 15 and 16) and we set the value. 
The address of the static area is returned.

<div class="p"><!----></div>
We have to write a special creation function (lines 22 to 29) that creates a vector and replaces its error function 
with our own, saving the old
value in a global variable. This value will be used if the error is not an index error.

<div class="p"><!----></div>
We can now write our test program that returns 10 integers from our array. Its output is
<div class="p"><!----></div>
<font size="+1"><tt>20&nbsp;21&nbsp;22&nbsp;23&nbsp;24&nbsp;25&nbsp;26&nbsp;27&nbsp;28&nbsp;29&nbsp;</tt></font>

<div class="p"><!----></div>
Note that our &#239;nfinite" array is still a perfectly valid vector object and if you use it in a "normal" way it will store the data you give it and 
return that data when you index it as any array. What it is shown in the example above is just how we can change the return value of the functions when 
an index error is detected by the library. All other uses are untouched and the vector will still behave as a normal vector.

<div class="p"><!----></div>
Note also that if the error is something different than the error the software wants to modify the old procedure is called. This means that
this type of changes can be built in a cascade, each one handling only a definite type of error.

<div class="p"><!----></div>
We have used here the generic interface using void pointers. Obviously we could use an integer vector instead of the generic one. To do that it would 
be necessary to change all lines that contain <font size="+1"><tt>Vector</tt></font> into <font size="+1"><tt>intVector</tt></font> and then call the <font size="+1"><tt>iintVector.Create</tt></font> function
instead of the plain <font size="+1"><tt>iVector.Create</tt></font>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Zero extensible arrays</h3>
To make a zero extensible array (used in  signal processing) you would just change the line 17 above and instead of writing

<div class="p"><!----></div>
<font size="+1"><tt>value&nbsp;=&nbsp;idx;</tt></font>

<div class="p"><!----></div>
you would write:

<div class="p"><!----></div>
<font size="+1"><tt>value&nbsp;=&nbsp;0;</tt></font>

<div class="p"><!----></div>
This type of array would return always zero for any index outside the limits of the array.

     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Arrays extensible by insert</h3>
Within the error procedure it is possible to call any function of the library. For instance, we can detect that the index error is the
result of the &#207;nsertAt" API, and decide to enlarge the array automatically. To do this we should return a non &nbsp;NULL value from within  our
error procedure.

<div class="p"><!----></div>
As you can see, that is <b>already the case</b>! That is why the next section is called:

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Pitfalls</h3>
When you change the default procedure you must be careful to ensure that the <b>only</b> situations where you modify the library's behavior are
the ones you want to modify. 

<div class="p"><!----></div>
 <h1><a name="tth_chAp8">
Chapter 8 </a><br />Applications</h1>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Unique</h2>
The main point in using the C containers library is the increase in
program abstraction. In this example we will see how the library
can be used to solve in a few lines a classroom problem.

<div class="p"><!----></div>
      <h4><a name="tth_sEc1.0.1">
1.0.1</a>&nbsp;&nbsp;Task description</h4>
Given a text file, print in standard output the lines that are
unique in it, i.e. filtering all duplicated lines.

<div class="p"><!----></div>
      <h4><a name="tth_sEc1.0.2">
1.0.2</a>&nbsp;&nbsp;Algorithm</h4>
Normally this involves keeping a sorted list/array of lines
and testing if a line is in the set or  not.

<div class="p"><!----></div>
      <h4><a name="tth_sEc1.0.3">
1.0.3</a>&nbsp;&nbsp;Solution using the CCL</h4>

<font size=+1><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;#include&nbsp;&lt;containers.h&#62;
&nbsp;int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i=1,r;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*dict;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[8192];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"%s&nbsp;&lt;file&nbsp;name&#62;\n",argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;fopen(argv[1],"r");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(f&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict&nbsp;=&nbsp;iDictionary.Create(0,500);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dict&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(fgets(buf,sizeof(buf),f))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=&nbsp;iDictionary.Add(dict,buf,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("[%3d]&nbsp;%s",i,buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Finalize(dict);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(f);
&nbsp;}

</pre></font>

      <h4><a name="tth_sEc1.0.4">
1.0.4</a>&nbsp;&nbsp;Algorithm</h4>
A hash table will be used to determine if a line is a duplicate
or not.

<div class="p"><!----></div>
      <h4><a name="tth_sEc1.0.5">
1.0.5</a>&nbsp;&nbsp;Commentary</h4>
We use the following local variables (lines 4-7):

<div class="p"><!----></div>

<table>
<tr><td align="left">Name   </td><td align="left">Usage</td></tr>
<tr><td align="left">f      </td><td align="left">Input stream bound to the file to read</td></tr>
<tr><td align="left">i      </td><td align="left">Counter for lines read</td></tr>
<tr><td align="left">r      </td><td align="left">Result of adding a line</td></tr>
<tr><td align="left">dict   </td><td align="left">Dictionary (Hash table)</td></tr>
<tr><td align="left">buf    </td><td align="left">Line buffer limited to 8K per line</td></tr></table>


<div class="p"><!----></div>
Lines 9-15 are concerned with opening the input file, with some error
checking.

<div class="p"><!----></div>
In line 16 we create a dictionary, requesting a size of zero for the
data associated with the key since we aren't storing any data, just the
key, and we suppose that the table will contain more or less 500
entries. If the file contains much more lines performance could
suffer but the algorithm would still work.

<div class="p"><!----></div>
Lines 19-25 are the main loop of the program. We read each line into
the buffer and add it to then dictionary. If the &#196;dd" API returns
a positive number the line wasn't there, if it returns zero the
line was already in the dictionary. If the result is negative it
is an error code and we stop the loop aborting the operation. Failure
can be provoked only by lack of memory.

<div class="p"><!----></div>
If the result is positive we print the line.

<div class="p"><!----></div>
Cleanup is performed in lines 26 and 27: we dispose of the dictionary
and close the file.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Paste</h2>

      <h4><a name="tth_sEc2.0.6">
2.0.6</a>&nbsp;&nbsp;Task description</h4>
Given two text files, print each line of them in the same line separated by a tab character. If files have a different number of lines
stop when the first file is exhausted.

<div class="p"><!----></div>
Note that this specifications may be different from the Unix utility of the same name.

      <h4><a name="tth_sEc2.0.7">
2.0.7</a>&nbsp;&nbsp;Solution</h4>

<font size=+1><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*f1,*f2;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*line1,*line2;
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*file1,*file2;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it1,*it2;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;3)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"%s:&nbsp;file1&nbsp;file2\n",argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;file1&nbsp;=&nbsp;istrCollection.CreateFromFile(argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;file2&nbsp;=&nbsp;istrCollection.CreateFromFile(argv[2]);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(file1&nbsp;!=&nbsp;NULL&nbsp;&amp;&amp;&nbsp;file2&nbsp;!=&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it1&nbsp;=&nbsp;istrCollection.NewIterator(file1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it2&nbsp;=&nbsp;istrCollection.NewIterator(file2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line2&nbsp;=&nbsp;it2-&#62;GetFirst(it2);&nbsp;line1&nbsp;=&nbsp;it1-&#62;GetFirst(it1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;line1;&nbsp;line1&nbsp;=&nbsp;it1-&#62;GetNext(it1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(line2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\t%s\n",line1,line2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line2&nbsp;=&nbsp;it2-&#62;GetNext(it2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;printf("%s\n",line1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.DeleteIterator(it1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.DeleteIterator(it2);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.Finalize(file1);
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.Finalize(file2);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}

</pre></font>

      <h4><a name="tth_sEc2.0.8">
2.0.8</a>&nbsp;&nbsp;Commentary</h4>
We create two string collections containing the text (lines 13-14). Two iterators are used to get each line of both files( lines 16 17). The rest
is just cleanup: we delete the iterators (lines 26-27) and finalize the string collections (lines 29 30).

<div class="p"><!----></div>
This solution using the library is shorter and easier to write than a solution reading each line with <font size="+1"><tt>fgets()</tt></font> but needs enough memory
to hold both files in memory at the same time.

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Mapcar</h2>
<a 
name="mapcar30"></a>
The lisp function "mapcar" produces a map by applying a given function to each element of a list.

<font size=+1><pre>
(mapcar&nbsp;#'abs&nbsp;'(3&nbsp;-4&nbsp;2&nbsp;-5&nbsp;-6))&nbsp;=&#62;&nbsp;(3&nbsp;4&nbsp;2&nbsp;5&nbsp;6)&nbsp;

</pre></font>
We can reproduce this function by using &#196;pply". In the extra argument we pass a structure of two members: 

<ul>
<li> A function to call (in the above example it would be a function to calculate the absolute value)
<div class="p"><!----></div>
</li>

<li> A list container where the result would be stored
<div class="p"><!----></div>
</li>
</ul>
Our function receives then (as all functions called by Apply) two arguments, the element and a pointer to our structure. Here is a sketch of how could it be done:

<font size=+1><pre>
#include&nbsp;&lt;containers.h&#62;
struct&nbsp;MapcarArgs&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*(*fn)(void&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*Result;
};

</pre></font>
We keep some generality by using a general prototype and definition for the function we are using. We could have defined the callback as:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*fn)(int&nbsp;*);

</pre></font>
That prototype would have been unusable for lists that use doubles, for instance. With the current definition we can use this "MapcarArgs" structure with any other list.

<div class="p"><!----></div>
The actual function we are calling encapsulates all knowledge about the data stored in the list and the operation we perform with that data. The other parts of the software do not need to know anything about it.  It returns a static pointer to the result of the operation it performs using the given element as data that will be overwritten at each call. The intended usage is to save that result before making the next call.
It can be defined as follows:

<font size=+1><pre>
void&nbsp;*DoAbsValue(void&nbsp;*element)
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;result&nbsp;=&nbsp;*(int&nbsp;*)element;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-result;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&amp;result;
}
/*&nbsp;This&nbsp;function&nbsp;will&nbsp;be&nbsp;directly&nbsp;called&nbsp;by&nbsp;"Apply".&nbsp;*/
static&nbsp;int&nbsp;Applyfn(void&nbsp;*element,&nbsp;struct&nbsp;MapcarArgs&nbsp;*args)
{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*result&nbsp;=&nbsp;args-&#62;fn(element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.Add(args-&#62;Result,result);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}
List&nbsp;*mapcar(List&nbsp;*li,void&nbsp;*(*fn)(void&nbsp;*))
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;MapcarArgs&nbsp;args;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args.fn&nbsp;=&nbsp;fn;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args.Result&nbsp;=&nbsp;iList.Create(iList.GetElementSize(li));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(args.Result&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Apply(li,Applyfn,(void&nbsp;*)&amp;args);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;args.Result;
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*li&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*newList;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;tab[]&nbsp;=&nbsp;{3,-4,2,-5,6};
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;5;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(li,&amp;tab[i]);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;newList&nbsp;=&nbsp;mapcar(li,DoAbsValue);
}

</pre></font>
Still, our version of mapcar is still specific to lists. A more general version would use a sequential container to make a mapcar function that would be able to work with any type of sequential container. 

<div class="p"><!----></div>
The basic idea is to provide an empty container of the desired result type as an extra argument to mapcar. We use an iterator instead of &#196;pply", obtaining a single compact function that will take any sequential container as input an add the result of the function to any type of sequential container.

<font size=+1><pre>
int&nbsp;mapcar(SequentialContainer&nbsp;*src,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;source&nbsp;container&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*fn)(void&nbsp;*),/*&nbsp;Function&nbsp;to&nbsp;call&nbsp;with&nbsp;each&nbsp;element&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SequentialContainer&nbsp;*result)&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;resulting&nbsp;container&nbsp;*/
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iSequentialContainer.NewIterator(src);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*obj;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(it&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(obj&nbsp;=&nbsp;it-&#62;GetFirst(it);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;!=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*tmp&nbsp;=&nbsp;fn(obj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iSequentialContainer.Add(result,tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;In&nbsp;case&nbsp;of&nbsp;any&nbsp;error&nbsp;return&nbsp;a&nbsp;partial&nbsp;result&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;error&nbsp;code&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteIterator(it);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}

</pre></font>
Other similar functions can be built from this model. For instance "mapcon", a function that needs two containers to build a resulting container. The result is  made out of the results of a binary function that will receive one element from each container. 

<div class="p"><!----></div>
Its implementation is trivially deduced from the above function:
<a 
name="mapcon30"></a>

<font size=+1><pre>
int&nbsp;mapcon(SequentialContainer&nbsp;*src1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SequentialContainer&nbsp;*src2,&nbsp;&nbsp;/*&nbsp;The&nbsp;input&nbsp;containers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*fn)(void&nbsp;*,void&nbsp;*),&nbsp;&nbsp;/*&nbsp;Function&nbsp;with&nbsp;2&nbsp;arguments&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SequentialContainer&nbsp;*result)&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;resulting&nbsp;container&nbsp;*/
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it1&nbsp;=&nbsp;iSequentialContainer.NewIterator(src1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it2&nbsp;=&nbsp;iSequentialContainer.NewIterator(src2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*obj1,*obj2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(it&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iSequentialContainer.GetElementSize(src1)&nbsp;!=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iSequentialContainer.GetElementSize(src2))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INCOMPATIBLE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(obj1&nbsp;=&nbsp;it1-&#62;GetFirst(it1),obj2&nbsp;=&nbsp;it2-&#62;GetFirst(it2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj1&nbsp;!=&nbsp;NULL&nbsp;&amp;&amp;&nbsp;obj2&nbsp;!=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj2&nbsp;=&nbsp;it2-&#62;GetNext(it2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj1&nbsp;=&nbsp;it1-&#62;GetNext(it1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*tmp&nbsp;=&nbsp;fn(obj1,obj2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iSequentialContainer.Add(result,tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;In&nbsp;case&nbsp;of&nbsp;any&nbsp;error&nbsp;return&nbsp;a&nbsp;partial&nbsp;result&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;error&nbsp;code&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteIterator(it1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteIterator(it2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}

</pre></font>
We can use it with a function  that adds its two arguments to add two containers:

<font size=+1><pre>
void&nbsp;*DoAdd(void&nbsp;*element1,void&nbsp;*element2)
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;result&nbsp;=&nbsp;*(int&nbsp;*)element1&nbsp;+&nbsp;*(int&nbsp;*)element2;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&amp;result;
}

</pre></font>
Note that not all errors are detected, and we stop at the smallest container, producing a result compatible with the smallest of both arguments.
Note too that we make a very superficial compatibility test to see if the arguments contain the same type of object, using their size as an indication. This test would ignore elements of the same size but incompatible, for instance floats and 32 bit integers, or 64 bit integers and double precision elements, etc.

<div class="p"><!----></div>
The standard answer to the above problems is to point out that C has a tradition of keeping things simple and expecting programmers that take care of low level details. If you want more error support, you will find out with minimal research a lot of languages ready to make all kinds of hand holding for you.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Word offsets</h2>
The objective here is not so much to give a working program but to show different ways of using the CCL.

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Task description</h3>
For each line of a text file, build a vector of offsets from the beginning of the line, that records where each word ends. Print each line and the associated offsets.

     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Algorithm</h3>
We define an associative structure called "pair" that will hold a pointer to each line of text, and an integer vector that holds the offsets.
We load the file into memory, and for each line we calculate the offsets. The resulting vector of lines and offsets is iterated to print the data.

<font size=+1><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#include&nbsp;"containers.h"

#define&nbsp;isSeparator(c)&nbsp;(ispunct(c)&nbsp;||&nbsp;isspace(c))

struct&nbsp;pair&nbsp;{&nbsp;char&nbsp;*txt;&nbsp;ValArrayInt&nbsp;*positions;&nbsp;};
ValArrayInt&nbsp;*GetPositions(char&nbsp;*txt)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*p&nbsp;=&nbsp;txt;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;position&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayInt&nbsp;*result&nbsp;=&nbsp;iValArrayInt.Create(20);

&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*p&nbsp;&amp;&amp;&nbsp;isSeparator(*p))&nbsp;p++;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*p)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isSeparator(*p))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position&nbsp;=&nbsp;(int)(p&nbsp;-&nbsp;txt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Add(result,position);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(isSeparator(*p))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;p++;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iValArrayInt.Size(result)&nbsp;&#62;&nbsp;0)&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Add(result,p-txt);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*myData&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.CreateFromFile(argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;istrCollection.Size(myData);
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;pair&nbsp;Current,*pPair;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*Map&nbsp;=&nbsp;iVector.Create(sizeof(struct&nbsp;pair),50);
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(size_t&nbsp;i=0;&nbsp;i&lt;siz;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current.txt&nbsp;=&nbsp;istrCollection.GetElement(myData,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current.positions&nbsp;=&nbsp;GetPositions(Current.txt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(Map,&amp;Current);
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;=&nbsp;iVector.NewIterator(Map);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(pPair=it-&#62;GetFirst(it);pPair;pPair=it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*itPositions;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*pPos;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",pPair-&#62;txt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itPositions&nbsp;=&nbsp;iValArrayInt.NewIterator(pPair-&#62;positions);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(pPos=itPositions-&#62;GetFirst(itPositions);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pPos&nbsp;!=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pPos&nbsp;=&nbsp;itPositions-&#62;GetNext(itPositions)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d&nbsp;",*pPos);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.DeleteIterator(itPositions);
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;iVector.DeleteIterator(it);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}

</pre></font>
<font size="-1">

<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table border="1">
<tr><td width="39">Line</td><td width="533">Explanation</td></tr>
<tr><td width="39">1 </td><td width="533">Include the standard header of the CCL.</td></tr>
<tr><td width="39">3 </td><td width="533">A handy macro to separate words from punctuation.
  This can be changed at will, all logic that defines what a &#223;eparator" is, is in this macro.</td></tr>
<tr><td width="39">5 </td><td width="533">We define a structure "pair" that will hold two values:

<div class="p"><!----></div>
 1: the pointer to the text, 
<div class="p"><!----></div>
 2: the pointer to a
   flexible array that will hold the offsets of each
   word in the character array. 
<div class="p"><!----></div>
 This is done to show how you can include containers in other data structures.
 Note that this is NOT
   a general vector but a specialized one, fit to hold
   only integers.</td></tr>
<tr><td width="39">6 </td><td width="533">We define a function that will determine where the
   words end and store that offset in the integer array.</td></tr>
<tr><td width="39">10</td><td width="533">We create the integer array.</td></tr>
<tr><td width="39">12</td><td width="533">Ignore leading whitespace</td></tr>
<tr><td width="39">13</td><td width="533">While there are characters left, we loop testing if it
   is a separator.
<div class="p"><!----></div>
 If it is, we add the integer to the array
   and we ignore the following separator characters.</td></tr>
<tr><td width="39">22</td><td width="533">We add the last position if the array is not empty and</td></tr>
<tr><td width="39">25</td><td width="533">return as a result the integer array.</td></tr>
<tr><td width="39">26</td><td width="533">The <font size="+1"><tt>main</tt></font> function</td></tr>
<tr><td width="39">28</td><td width="533">Create a string collection from a file given in the
   command line.</td></tr>
<tr><td width="39">32</td><td width="533">Create a normal generic vector that can hold an array
   of our "pair" structures. We call it "Map".</td></tr>
<tr><td width="39">35</td><td width="533">We fill the generic array of "pair" structures in lines</td></tr>
<tr><td width="39">39</td><td width="533">35 to 39.</td></tr>
<tr><td width="39">40</td><td width="533">A new iterator is built for going through the array of
   pairs.</td></tr>
<tr><td width="39">41</td><td width="533">We loop through the array of pairs printing the string and
   the offsets of the words.</td></tr>
<tr><td width="39">46</td><td width="533">To print the words offsets we use another iterator that
   loops through</td></tr>
<tr><td width="39">52</td><td width="533">We destroy the iterator for the integers since we are done
   with it.</td></tr>
<tr><td width="39">54</td><td width="533">We destroy the main iterator </td></tr>
<tr><td width="39"></td></tr></table>
</center>
<div class="p"><!----></div>
</font>Note that there are two important statements <b>missing</b> from the program above: we never call the <font size="+1"><tt>finalize</tt></font> method to reclaim the memory used by the containers we have created. This is because we are in the <font size="+1"><tt>main</tt></font> function and all memory will be reclaimed by the OS when we leave the <font size="+1"><tt>main</tt></font> function.

 <h1><a name="tth_chAp9">
Chapter 9 </a><br />The sample implementation</h1>
The objective of the sample implementation is to serve as a guide for the implementors of this proposal. It is not the fastest implementation and it is not the most efficient or compact one. As any other software, it contains bugs, that I hope to iron out with time.

<div class="p"><!----></div>
Please note that all the decisions done for the sample implementation are <b>not</b> part of the specifications of the containers library. Other
implementations could do completely different things<a href="#tthFtNtAGI" name="tthFrefAGI"><sup>68</sup></a>.

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;The different source files</h2>

<div class="p"><!----></div>
The sample implementation has two types of files:

<ol type="1">
<li> Source files that implement a specific container: list.c vector.c, etc. This containers use a void pointer to receive their arguments and return
a void pointer when retrieving their data.
<div class="p"><!----></div>
</li>

<li> Source files that implement a <i>templated</i> container, i.e. the file needs a <i>parameter file</i> and a <i>templated implementation</i> 
file. In this type of files we have a small file that defines the templated file parameters (in the form of pre-processor macros) and then just 
includes the templated implementation file. This containers receive data of a concrete type passed by value and return the same data passed by value.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
<font size="-1">
<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table border="1">
<tr><td width="138"><b>File</b></td><td width="434"><b>Description</b></td></tr><tr><td></td></tr>
<tr><td width="138">bitstrings.c</td><td width="434">The bitstring container.</td></tr>
<tr><td width="138">bloom.c</td><td width="434">The bloom filter container</td></tr>
<tr><td width="138">buffer.c</td><td width="434">Growable buffers and circular buffers</td></tr>
<tr><td width="138">ccl_internal.h</td><td width="434">Definitions of all the types defined internally by the library.</td></tr>
<tr><td width="138">containers.h</td><td width="434">Main header file of the library. It defines all the user visible interfaces.</td></tr>
<tr><td width="138">deque.c</td><td width="434">The deque container</td></tr>
<tr><td width="138">dlistgen.h</td><td width="434">Generic definition of the double linked list data-type specific containers.</td></tr>
<tr><td width="138">dictionary.c</td><td width="434">Hash tables using ASCII text as key. This is just a small file that sets the parameters for the <font size="+1"><tt>dictionarygen.c</tt></font> file</td></tr>
<tr><td width="138">dictionarygen.c</td><td width="434">Common code for the dictionary container using either ASCII or wide characters keys</td></tr>
<tr><td width="138">dlist.c</td><td width="434">Double linked list container using void pointers to store the data.</td></tr>
<tr><td width="138">dlistgen.c</td><td width="434">Double linked list container using a specific data type. Needs a parameter file</td></tr>
<tr><td width="138">dlistgen.h</td><td width="434">Double linked list container data definitions and interface definitions using a specific data type. Needs a parameter file</td></tr>
<tr><td width="138">doubledlist.c</td><td width="434">Double linked list for double data. This is a parameter file for dlistgen.c</td></tr>
<tr><td width="138">doubledlist.h</td><td width="434">Single linked list header file for double data. This is a parameter file for dlistgen.h</td></tr>
<tr><td width="138">doublelist.c</td><td width="434">Parameter file for listgen.c producing the doubleList container</td></tr>
<tr><td width="138">doublelist.h</td><td width="434">Parameter file for listgen.h for doubleList container</td></tr>
<tr><td width="138">error.c</td><td width="434">The error interface</td></tr>
<tr><td width="138">fgetline.c</td><td width="434">Reads a line of text from a file. Used in the string container</td></tr>
<tr><td width="138">generic.c</td><td width="434">The generic container interface</td></tr>
<tr><td width="138">hashtable.c</td><td width="434">Hash table featuring binary keys</td></tr>
<tr><td width="138">heap.c</td><td width="434">Small object allocator</td></tr>
<tr><td width="138">iMask.c</td><td width="434">Mask interface implementation</td></tr>
<tr><td width="138">intdlist.c</td><td width="434">Parameter file for dlistgen.c defining the intDlist container</td></tr>
<tr><td width="138">intdlist.h</td><td width="434">Parameter header for dlistgen.h declaring intDlist container</td></tr>
<tr><td width="138">intlist.c</td><td width="434">Parameter file for listgen.c defining intList container</td></tr>
<tr><td width="138">intlist.h</td><td width="434">Parameter header for listgen.h declaring intList container</td></tr>
<tr><td width="138">list.c</td><td width="434">Generic type list container using void pointers</td></tr>
<tr><td width="138">listgen.c</td><td width="434">Template file for List container</td></tr>
<tr><td width="138">longlongdlist.c</td><td width="434">Parameter file for dlistgen.c defining longlongDlist container.</td></tr>
<tr><td width="138">longlonglist.c</td><td width="434">Parameter file for listgen.c</td></tr>
<tr><td width="138">malloc_debug.c</td><td width="434">Debug implementation of malloc</td></tr>
<tr><td width="138">Makefile</td><td width="434">Make file for Unix systems using the gcc compiler</td></tr>
<tr><td width="138">Makefile.lcc</td><td width="434">Make file for windows systems using the 32 bit lcc compiler</td></tr>
<tr><td width="138">Makefile.lcc64</td><td width="434">Make file for windows systems using the 64 bit lcc compiler</td></tr>
<tr><td width="138">Makefile.msvc</td><td width="434">Make file for windows systems using the Microsoft compiler</td></tr>
<tr><td width="138">memoryanager.c</td><td width="434">Very short file describing the CurrentAllocator mechanism.</td></tr>
<tr><td width="138">observer.c</td><td width="434">The implementation of the observer pattern</td></tr>
<tr><td width="138">pool.c</td><td width="434">Pooled memory manager</td></tr>
<tr><td width="138">pooldebug.c</td><td width="434">Debug version of the pool memory manager</td></tr>
<tr><td width="138">priorityqueue.c</td><td width="434">Priority queues implementation</td></tr>
<tr><td width="138">qsortex.c</td><td width="434">Quick sort algorithm</td></tr>
<tr><td width="138">queue.c</td><td width="434">Queue container</td></tr>
<tr><td width="138">redblacktree.c</td><td width="434">Red black tree implementation. Not yet documented</td></tr>
<tr><td width="138">scapegoat.c</td><td width="434">"Scapegoat" trees implementation</td></tr>
<tr><td width="138">searchtree.c</td><td width="434">AVL trees. Not documented</td></tr>
<tr><td width="138">sequential.c</td><td width="434">Implementation of the general sequential container interface</td></tr>
<tr><td width="138">smallpool.c</td><td width="434">Not documented yet</td></tr>
<tr><td width="138">suffixtree.c</td><td width="434">Not documented yet</td></tr>
<tr><td width="138">strcollection.c</td><td width="434">Specialized vector for ascii character strings. This is a parameter file for strcollectiongen.c.</td></tr>
<tr><td width="138">stringlist.c</td><td width="434">Specialized version of single linked lists using strings</td></tr>
<tr><td width="138">stringlistgen.c</td><td width="434">Common code for ascii and wide character strings specialized vector</td></tr>
<tr><td width="138">valarraydouble.c</td><td width="434">Value array of double data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarrayfloat.c</td><td width="434">Value array of float data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarrayint.c</td><td width="434">Value array of int data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarraylongdouble.c</td><td width="434">Value array of long double data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarraylonglong.c</td><td width="434">Value array of long long data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarrayshort.c</td><td width="434">Value array of short data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarraysize_t.c</td><td width="434">Value array of size_t data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarrayuint.c</td><td width="434">Value array of unsigned int data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarrayulonglong.c</td><td width="434">Value array of unsigned long long data. Parameter file for valarraygen.c</td></tr>
<tr><td width="138">valarraygen.c</td><td width="434">Common code for all val array implementations.</td></tr>
<tr><td width="138">valarraygen.h</td><td width="434">Common header file for all val array implementations. Needs a parameter file</td></tr>
<tr><td width="138">vector.c</td><td width="434">Code for the vector container</td></tr>
<tr><td width="138">vectorgen.h</td><td width="434">Header file for the template form of the vector container</td></tr>
<tr><td width="138">vectorgen.c</td><td width="434">Implementation of the template form of the vector container</td></tr>
<tr><td width="138">wdictionary.c</td><td width="434">Dictionary for a dictionary using wide character strings</td></tr>
<tr><td width="138">wstrcollection.c</td><td width="434">String collection using wide character data. Parameter file for strcollectiongen.c</td></tr><tr><td></td></tr>
<tr><td width="138"></td></tr></table>
</center>
<div class="p"><!----></div>
</font> 
     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Building the software</h3>
The library comes with several "makefiles" to build it automatically. Those makefiles build a library called <font size="+1"><tt>libccl.a</tt></font> under Unix systems, or <font size="+1"><tt>ccl.lib</tt></font> under windows.


<ul>
<li> Type <font size="+1"><tt>make</tt></font> for building the files under Unix
<div class="p"><!----></div>
</li>

<li> Type <font size="+1"><tt>make&nbsp;-f&nbsp;Makefile.lcc</tt></font> for building under windows 32 bit with the lcc compiler
<div class="p"><!----></div>
</li>

<li> Type <font size="+1"><tt>make&nbsp;-f&nbsp;Makefile.lcc64</tt></font> for building under windows 64 bit with the lcc64 compiler
<div class="p"><!----></div>
</li>

<li> Type <font size="+1"><tt>nmake&nbsp;-f&nbsp;Makefile.msvc</tt></font> for building under windows with the Microsoft MSVC compiler

<div class="p"><!----></div>
</li>
</ul>


 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Partitioning</h2>
An interface is a table of functions. This tables are a monolithic construct: if you use only one of the functions of the
interface you will have to link with all of the interface functions, whether you use them or not.

<div class="p"><!----></div>
It is important then, that each interface doesn't "pull in" other interfaces since then you would end up linking with the whole library even if
you use a small fraction of it.

<div class="p"><!----></div>
Some of this is inevitable though. All interfaces use the observer interface, so if you use any interface the observer interface will be
pulled in. It is important then, that the dependencies of the observer interface be kept to a minimum 
<a href="#tthFtNtAGJ" name="tthFrefAGJ"><sup>69</sup></a>. Problem is, it is necessary for the
observer interface to set the flags of the container being registered as an observed object. This means that the generic interface is needed.

<div class="p"><!----></div>
Go avoid pulling in the whole generic interface, the observer functions use the <font size="+1"><tt>vTable</tt></font>. In the sample implementation all containers
have a table of functions as first interface field. Since the description of the generic container object is published in "containers.h" it can
use the generic notation.

<font size=+1><pre>
GenericContainer&nbsp;*gen&nbsp;=&nbsp;(GenericContainer&nbsp;*)InputObject;
unsigned&nbsp;flags&nbsp;=&nbsp;gen-&#62;vTable-&#62;GetFlags(gen);

</pre></font>

<div class="p"><!----></div>
This works because the sample implementation has carefully designed all interface to be binary compatible, allowing an easy implementation
of the generic interface. All vTables have the <font size="+1"><tt>GetFlags</tt></font> function at the same place, so we always call the correct function.

<div class="p"><!----></div>
Another interface that is used by all other interfaces is the error interface. It has been kept as small as possible to avoid pulling in too much
data into the fixed overhead.

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Data structures</h2>
All container data structures are composed of two parts:

<ol type="1">
<li> A header part, containing a pointer to the functions table and some other fields. This 'generic' part is at the start of all container header structures.
<div class="p"><!----></div>
</li>

<li> A container specific part, containing auxiliary structures and data needed for the specific container at hand.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;The generic part</h3>
The first part of all container data structures is the same for each container. This allows to implement conceptually an abstract class of objects: the 'generic' container.
<a 
name="Generic Container+structure31"></a>

<font size=+1><pre>
struct&nbsp;GenericContainer&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainerInterface&nbsp;*vTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;Size;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
};

</pre></font>

<ol type="1">
<li> <font size="+1"><tt>Vtable</tt></font>. All containers in the sample implementation contain a pointer to the table of functions of their interface.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Size</tt></font>. The number of elements this container stores.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Flags</tt></font>. Stores the state of the container. The only flag the sample implementation uses is the <font size="+1"><tt>READ_ONLY_FLAG</tt></font> but many others 
are possible, for instance a 'locked' flag for multi-threading access, or a 'copy on write' flag for lazy copy, etc.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>ElementSize</tt></font>. All containers in the sample implementation can store objects of the same size. This is not really a limitation since you 
can store objects of ANY size by storing a pointer in the container.
An alternative design would store objects of any size but it would need to store the size of each object in addition to the data used by the object. 
The specialized containers like bitstrings, string collections or integer/double arrays do not need this field obviously, and its presence is optional.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Lists</h3>
<img src="List.png" alt="Figure">

<div class="p"><!----></div>
Single linked lists use a single pointer to the next element. The data for the element comes right behind that pointer to avoid the overhead that yet 
another pointer would represent.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_list_element&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;_list_element&nbsp;*Next;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;Data[MINIMUM_ARRAY_INDEX];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;See&nbsp;below
}&nbsp;list_element;

</pre></font>
The list header uses this structure to store the elements<a href="#tthFtNtAHA" name="tthFrefAHA"><sup>70</sup></a>. As you can see, there is no space wasted in a pointer to the element stored. The element stored is placed just behind the <font size="+1"><tt>Next</tt></font> pointer. The 
downside of this decision is that we can't recycle this object to store other different objects of different size.

     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Source files</h3>

<center>
<img src="ListContainerSourceFiles.png" alt="Figure">
</center>

<div class="p"><!----></div>
The figure shows the files associated with the two implementations of the list container. The generic pointers implementation is <font size="+1"><tt>list.c</tt></font> and the 
<i>templated</i> implementation is in <font size="+1"><tt>listgen.c</tt></font>. The files depending on <font size="+1"><tt>listgen.c</tt></font> are <i>parameter</i> files for <font size="+1"><tt>listgen.c</tt></font>.

      <h4><a name="tth_sEc3.3.1">
3.3.1</a>&nbsp;&nbsp;Alignment</h4>
Some machines require that data be stored at particular addresses, always a multiple of two. For instance SPARC machines require that doubles be
aligned at a multiple of 8. The structure for our list element above would provoke a crash when used to store doubles
<a href="#tthFtNtAHB" name="tthFrefAHB"><sup>71</sup></a>. 

<div class="p"><!----></div>
In those machines the list element structure is defined as follows:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_ListElement&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;_ListElement&nbsp;*Next;
#ifdef&nbsp;SPARC32
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*alignment;
#endif
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;Data[MINIMUM_ARRAY_INDEX];
}&nbsp;ListElement;

</pre></font>

<div class="p"><!----></div>
This assumes that <font size="+1"><tt>sizeof(void&nbsp;*)</tt></font> is 4. 

<div class="p"><!----></div>
In machines that handle unaligned data gracefully without crashing alignment requirements aren't useless, since in most cases they 
provoke a performance loss.
<a 
name="lists+structure33"></a>

<font size=+1><pre>
struct&nbsp;_List&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ListInterface&nbsp;*VTable;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;	
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*Last;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*First;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;Compare;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*Heap;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*Allocator;
};

</pre></font>
In the public <font size="+1"><tt>containers.h</tt></font> header file we refer always to an abstract structure <font size="+1"><tt>_List</tt></font>. We define it here. This schema allows other 
implementation to use the same header with maybe radically different implementations of their data structure.

<ol type="1">
<li> <font size="+1"><tt>Vtable</tt></font>, <font size="+1"><tt>count</tt></font>, <font size="+1"><tt>Flags</tt></font>, <font size="+1"><tt>ElementSize</tt></font>. This fields were described in the generic container section.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>timestamp</tt></font>. This field is incremented at each modification of the list, and allows the iterators to detect if the container changes 
during an iteration: they store the value of this field at the start of the iteration, and before each iteration they compare it with its current 
value. If there are any changes, they return &nbsp;NULL .
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Last</tt></font>. Stores a pointer to the last element of the list. This allows the addition of an element at the end of the list to be fast, 
avoiding a complete rescan of the list. This field is an optimization, all algorithms of a single linked list would work without this field.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>First</tt></font>. The start of the linked list.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Compare</tt></font>. A comparison function for the type of elements stored in the list.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>RaiseError</tt></font>. A function that will be called when an error occurs. This field is necessary only if you want to keep the flexibility of 
having a different error function for each list that the client software builds. An alternative implementation would store a pointer to an error 
function in the interface.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Allocator</tt></font>. A set of functions that allocates memory for this list. In an implementation that needs less flexibility and is more 
interested in saving space it could be replaced by the default allocator.
<div class="p"><!----></div>
</li>
</ol>
The sample implementation has certainly a quite voluminous header because of a design decision to keep things very flexible. Other implementations 
could trim most of the fields, and an absolute minimal implementation would trim <font size="+1"><tt>Last</tt></font>, <font size="+1"><tt>Compare</tt></font>, <font size="+1"><tt>RaiseError</tt></font>, <font size="+1"><tt>Heap</tt></font>, 
and <font size="+1"><tt>Allocator</tt></font>. If the implementation assumes that only one iterator per container is allowed, the <font size="+1"><tt>timestamp</tt></font> field could be replace by 
a single bit ('changed') in the <font size="+1"><tt>Flags</tt></font> field.<a href="#tthFtNtAHC" name="tthFrefAHC"><sup>72</sup></a>

     <h3><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;Double linked lists</h3>
This container has a very similar structure to the single linked ones

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_dlist_element&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;_dlist_element&nbsp;*Next;
	struct&nbsp;_dlist_element&nbsp;*Previous;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;Data[MINIMUM_ARRAY_INDEX];&nbsp;&nbsp;&nbsp;/*&nbsp;(1)&nbsp;*/
}&nbsp;dlist_element;

</pre></font>

<div class="p"><!----></div>
(1): In the <i>templated</i> versions of the container this field is defined as: <font size="+1"><tt>TYPE&nbsp;Data;</tt></font> where <font size="+1"><tt>TYPE</tt></font> is a type 
definition passed to the file as a parameter.

<div class="p"><!----></div>
We have now two pointers followed by the stored data. All other fields are exactly identical to the ones in the single linked list. The single 
difference is the existence of a free list. This could have been done in the single linked list implementation too.
<a 
name="Dlist+structure definition34"></a>

<font size=+1><pre>
struct&nbsp;Dlist&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;DlistInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;dlist_element&nbsp;*Last;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;dlist_element&nbsp;*First;
&nbsp;&nbsp;&nbsp;&nbsp;dlist_element&nbsp;*FreeList;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*Heap;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*Allocator;
};

</pre></font>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;Vector</h3>
Arrays are the containers that use the smallest overhead per element: zero. The only overhead is the header structure, whose cost is amortized since it is fixed for all elements that the array can hold.

<div class="p"><!----></div>
This is a 'flexible' array however, what means that there is some spare space allocated for allowing further growth, and that different allocation strategies can be followed when allocating a new chunk of array space when the existing array is full.
<a 
name="Vector+structure35"></a>

<font size=+1><pre>
struct&nbsp;_Vector&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;VectorInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;	
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*contents;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;CompareFn;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*Allocator;
}&nbsp;;

</pre></font>

<ol type="1">
<li> <font size="+1"><tt>Vtable</tt></font>, <font size="+1"><tt>count</tt></font>, <font size="+1"><tt>Flags</tt></font>, <font size="+1"><tt>ElementSize</tt></font>. This fields were described in the generic container section.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>CompareFn, RaiseError, timestamp</tt></font> and <font size="+1"><tt>Allocator</tt></font> were described in the <font size="+1"><tt>List</tt></font> container.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>capacity</tt></font>. Stores the number of elements (of <font size="+1"><tt>ElementSize</tt></font> bytes each) this container can hold without resizing.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>contents</tt></font>. Points to an array of <font size="+1"><tt>capacity</tt></font> elements, each of size <font size="+1"><tt>ElementSize</tt></font>.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;Dictionary</h3>
This container consists of an array of single linked lists. It could have been done with an <font size="+1"><tt>Vector</tt></font> of <font size="+1"><tt>List</tt></font> containers but a dedicated implementation is justified because of a greater efficiency. The advantages of the <font size="+1"><tt>Vector</tt></font> container (secured access, flexible expansion) are not needed since the array has a fixed length that never changes.
<a 
name="Dictionary+structure definition36"></a>

<font size=+1><pre>
struct&nbsp;_Dictionary&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;DictionaryInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*Allocator;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*hash)(const&nbsp;char&nbsp;*Key);
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;*Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*Key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;(1)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*Value;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;**buckets;
};

</pre></font>

<div class="p"><!----></div>
(1): In the wide character version of this structure, this field will be defined as: <font size="+1"><tt>wchar_t&nbsp;*Key;</tt></font>
<div class="p"><!----></div>

<ol type="1">
<li> <font size="+1"><tt>Vtable</tt></font>, <font size="+1"><tt>count</tt></font>, <font size="+1"><tt>Flags</tt></font>, <font size="+1"><tt>ElementSize</tt></font>. This fields were described in the generic container section.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>RaiseError, timestamp</tt></font> and <font size="+1"><tt>Allocator</tt></font> were described in the <font size="+1"><tt>List</tt></font> container.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>size</tt></font>. The number of different lists that the hash table can contain. This is normally a prime number.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>hash</tt></font>. A hash function for character strings.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>buckets</tt></font>. A table of pointers to lists of <font size="+1"><tt>DataList</tt></font> structures.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc3.7">
3.7</a>&nbsp;&nbsp;String collection</h3>
String collections are just flexible arrays of pointers to C character strings. They share all the fields of the Vector container, the only specific 
field is a context that is passed to the string comparison function. This context can contain flags or other information to use with special text 
encodings (wide characters for instance) or other data like regular expressions, etc.
<a 
name="strCollection+structure37"></a>

<font size=+1><pre>
struct&nbsp;strCollection&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;strCollectionInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;**contents;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;(1)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;StringCompareFn&nbsp;strcompare;
&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;*StringCompareContext;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*Allocator;
};

</pre></font>
(1): In the wide character version of this structure this field is defined as:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;wchar_t&nbsp;**&nbsp;contents;

</pre></font>

     <h3><a name="tth_sEc3.8">
3.8</a>&nbsp;&nbsp;Masks</h3>
There were two alternatives for implementing masks: 
<a 
name="Mask+structure definition38"></a>


<ul>
<li> Bit strings. Each bit position can hold a boolean value.
<div class="p"><!----></div>
</li>

<li> A character array. Each position can hold more values, for instance -1, 0, and 1, to hold the results of comparisons. This solution was retained
for the sample implementation. Item access is simplified and faster, at the expense of course of more memory.

<div class="p"><!----></div>
</li>
</ul>


<font size=+1><pre>
struct&nbsp;_Mask&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;length;
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*Allocator;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;data[];
};

</pre></font>

     <h3><a name="tth_sEc3.9">
3.9</a>&nbsp;&nbsp;Bit strings</h3>
Bit strings do not need the ElementSize field obviously. The <font size="+1"><tt>BIT_TYPE</tt></font> macro is defined as unsigned char. In general it should be an
unsigned integer type that could be different from char, maybe a 32 bit type or even larger.
<a 
name="BitString+structure definition39"></a>

<font size=+1><pre>
struct&nbsp;_BitString&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;BitStringInterface&nbsp;*VTable;&nbsp;/*&nbsp;The&nbsp;table&nbsp;of&nbsp;functions&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;of&nbsp;bits&nbsp;in&nbsp;the&nbsp;array&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;BIT_TYPE&nbsp;*contents;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;contents&nbsp;of&nbsp;the&nbsp;collection&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;allocated&nbsp;space&nbsp;in&nbsp;the&nbsp;contents&nbsp;vector&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;&nbsp;&nbsp;&nbsp;/*&nbsp;Modifications&nbsp;counter&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;&nbsp;&nbsp;&nbsp;/*&nbsp;Read-only&nbsp;or&nbsp;other&nbsp;flags&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerAllocator&nbsp;*Allocator;
}&nbsp;;

</pre></font>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.10">
3.10</a>&nbsp;&nbsp;The iterator implementation</h3>
This data structure has two main parts:

<ul>
<li> A public part:
<a 
name="Iterator+structure310"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_Iterator&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetNext)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetPrevious)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetFirst)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetCurrent)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetLast)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*Seek)(struct&nbsp;_Iterator&nbsp;*,size_t);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;(*Replace)(struct&nbsp;_Iterator&nbsp;*,void&nbsp;*data,int&nbsp;direction);
}&nbsp;Iterator;

</pre></font> 
This part contains only the functions that the interface offers. It is defined in the public header <font size="+1"><tt>containers.h</tt></font>.
<div class="p"><!----></div>
</li>

<li> A private, container specific part that comes right behind the public part and stores additional information that is needed for each container. 
For instance the list container will add following fields:
<a 
name="ListIterator310"></a>

<font size=+1><pre>
struct&nbsp;ListIterator&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;it;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Includes&nbsp;the&nbsp;public&nbsp;part
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;List&nbsp;this&nbsp;iterator&nbsp;is&nbsp;going&nbsp;through
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;index;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;position&nbsp;where&nbsp;we&nbsp;are&nbsp;in&nbsp;the&nbsp;list
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*Current;//&nbsp;The&nbsp;current&nbsp;element
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;timestamp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;timestamp&nbsp;of&nbsp;the&nbsp;list&nbsp;when&nbsp;this
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;iterator&nbsp;was&nbsp;created
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;ElementBuffer[1];//&nbsp;The&nbsp;current&nbsp;element&nbsp;if&nbsp;needed
};

</pre></font>
User code should only see and use the public part, as if the iterator was only the public part. Internally all iterator functions are completely 
different functions, specific for the container they should iterate. It looks like from user code, as you were always calling the same function because 
the syntax and name is the same. This allows for a certain abstraction in the source code that uses this functions, allowing to express a whole range 
of algorithms in terms of general concepts.

<div class="p"><!----></div>
Each of the functions that implement <font size="+1"><tt>GetNext</tt></font> <font size="+1"><tt>GetFirst</tt></font>, etc starts with a cast of the input argument that is declared as an 
<font size="+1"><tt>Iterator</tt></font> structure to a concrete container iterator like our <font size="+1"><tt>ListIterator</tt></font> above.

<div class="p"><!----></div>
In all those structures there is a common ground. They have:

<ol type="1">
<li> A pointer to the container the iterator is using.
<div class="p"><!----></div>
</li>

<li> Some fields for storing the current position within the container, i.e. a cursor.
<div class="p"><!----></div>
</li>

<li> A <font size="+1"><tt>timestamp</tt></font> field to detect if the container has changed during the iteration.
<div class="p"><!----></div>
</li>

<li> A buffer that allows the iterator to store an element of the container. This area contains a copy of the current element. Normally the
iterators return a pointer to the data of each element, but in the case of read only containers a pointer to this area will be returned. 
This allows to maintain the read only semantics.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc3.11">
3.11</a>&nbsp;&nbsp;The timestamp field</h3>
This field will be incremented by each modification of the list. When an iterator is created it will copy the current value of the time stamp, and for
each subsequent operation it will compare the value of the container with its saved copy. They should be always equal, otherwise the iterator will
return always &nbsp;NULL . The only exception to this rule is the iterator <font size="+1"><tt>Replace</tt></font> function that will modify the container without invalidating
the iterator that calls it. Other iterators to the same container will be invalidated.

<div class="p"><!----></div>
The timestamp field should be incremented in all operations that somehow modify the container, not only in the operations that modify the number of 
elements.


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
Implementation issues

<ul>
<li>There is currently no way to know when you delete a container if there are iterators that are still
pointing to it. This could be detected by simply having a counter of the number of iterators a container has, but that would mean more overhead for the 
already fat header objects...
<div class="p"><!----></div>
</li>

<li> The current interface requires that the user calls the <font size="+1"><tt>DeleteIterator</tt></font> function when you are done using the iterator. This is
a source of memory leaks if you forget
to do it. An easier way to do this would be to maintain a list of current iterators, to be freed automatically when the container is 
destroyed. Obviously this supposes that you do not create thousands of iterators but that you reuse the iterators for different loops.
<div class="p"><!----></div>
</li>
</ul>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;The code</h2>
Only one container will be shown here in full: the List container. For the others, only some functions will be explained to save space. You are 
invited to read the distributed code of course that is part of this work.

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;List</h3>

<div class="p"><!----></div>
<a 
name="lists+code41"></a><br />
<b>Add</b><a 
name="Add+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Add_nd(List&nbsp;*l,void&nbsp;*elem)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*newl;

&nbsp;&nbsp;&nbsp;&nbsp;newl&nbsp;=&nbsp;new_link(l,elem,"iList.Add");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newl&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;newl;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;newl;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;newl;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;++l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

static&nbsp;int&nbsp;Add(List&nbsp;*l,void&nbsp;*elem)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL&nbsp;||&nbsp;elem&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NullPtrError("Add");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;CONTAINER_READONLY)&nbsp;return&nbsp;ErrorReadOnly(l,"Add");
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;Add_nd(l,elem);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&amp;&amp;&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l,CCL_ADD,elem,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}

</pre></font>
This function adds one element at the end. The <font size="+1"><tt>Add</tt></font> entry point performs the error checking and calls <font size="+1"><tt>Add_nd</tt></font> an internal
function that does the actual work. This is needed because other functions call internally <font size="+1"><tt>Add</tt></font> after they have already performed
the error checking.

<div class="p"><!----></div>
The <font size="+1"><tt>Add_nd</tt></font> function requests a new list element (5). If that succeeds the new element must be inserted in the list.
If the list is empty it just establishes the start of the list (9), if not, it adds it after the last element (12). The new 
list element is the last one (14). Errors leave the list unchanged. Exclusive access to the list is needed between the line 8 and the line 16 in the code. 
This operation is a modification of the list, and it needs to update the <font size="+1"><tt>timestamp</tt></font> value to notify possible iterators
that they are invalid.

<div class="p"><!----></div>
If the <font size="+1"><tt>Add_nd</tt></font> function was successful and this container has a registered observer we notify the observer of this
event.
<br />

<div class="p"><!----></div>
<b>AddRange</b><a 
name="AddRange+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;AddRange(List&nbsp;*&nbsp;AL,size_t&nbsp;n,&nbsp;void&nbsp;*data)
{
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*p;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*oldLast;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NullPtrError("AddRange");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;RaiseError("iList.AddRange",CONTAINER_ERROR_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(data&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;RaiseError("iList.AddRange",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;data;
&nbsp;&nbsp;&nbsp;&nbsp;oldLast&nbsp;=&nbsp;AL-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;Add_nd(AL,p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;Last&nbsp;=&nbsp;oldLast;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Last)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*removed&nbsp;=&nbsp;oldLast-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(removed)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*tmp&nbsp;=&nbsp;removed-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Heap)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.FreeObject(AL-&#62;Heap,removed);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;Allocator-&#62;free(removed);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;Last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;+=&nbsp;AL-&#62;ElementSize;&nbsp;/*&nbsp;Point&nbsp;to&nbsp;the&nbsp;next&nbsp;element&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n--;&nbsp;/*&nbsp;Count&nbsp;the&nbsp;items&nbsp;added&nbsp;so&nbsp;far&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(AL,CCL_ADDRANGE,data,(void&nbsp;*)n);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function calls repeatedly <font size="+1"><tt>Add_nd</tt></font> for each element of the given array. Any error provokes an abort and the original 
list is left unchanged.

<div class="p"><!----></div>
Error checking is done in lines 6 to 15, testing for &nbsp;NULL for the list and the data. If the number of elements is zero the
function does nothing and returns zero. The code accepts data as &nbsp;NULL if the number of elements is zero. If <font size="+1"><tt>n</tt></font> is
zero this code still checks  that the list is not &nbsp;NULL , and that the list is not read only, considering both to be errors.
Nothing is specified for those cases and you can't rely on this behavior for other implementations.

<div class="p"><!----></div>
Note that at compile time we do not know the 
size of each element and we can't index into this array. We just setup a generic pointer to the start of the data area (16), and 
increment it by the size of each element at each iteration (line 35). 
This implementation supposes that the size of the elements as assumed by the list is the same as the size of then element as assumed by the calling program.

<div class="p"><!----></div>
If an error occurs when adding elements the new elements are discarded, the list is reset to its previous state and an
error code is returned. (lines 20-33). The eventually added elements are discarded (lines 24-30).

<div class="p"><!----></div>

  <b>Notes:</b>
<div class="p"><!----></div>
It would be far more efficient to test at the start of the loop if there is enough space for the
<font size="+1"><tt><i>n</i></tt></font>
list elements than
doing it within the loop. That would eliminate the code for reclaiming the already allocated items. This isn't done because
the list allocator could be the default malloc function that doesn't allow queries of this type.

<div class="p"><!----></div>
<br />
<b>Append</b><a 
name="Append+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Append(List&nbsp;*l1,List&nbsp;*l2)
{

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1&nbsp;==&nbsp;NULL&nbsp;||&nbsp;l2&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;RaiseError("iList.Append",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Append",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((l1-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;(l2-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;RaiseError("iList.Append",CONTAINER_ERROR_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l2-&#62;ElementSize&nbsp;!=&nbsp;l1-&#62;ElementSize)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;RaiseError("iList.Append",CONTAINER_ERROR_INCOMPATIBLE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INCOMPATIBLE;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l1,CCL_APPEND,l2,NULL);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l2-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l2,CCL_FINALIZE,NULL,NULL);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;count&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;First&nbsp;=&nbsp;l2-&#62;First;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;Last&nbsp;=&nbsp;l2-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(l2-&#62;count&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l2-&#62;First)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;Last-&#62;Next&nbsp;=&nbsp;l2-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l2-&#62;Last)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;Last&nbsp;=&nbsp;l2-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;count&nbsp;+=&nbsp;l2-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;l2-&#62;Allocator-&#62;free(l2);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function  adds the second argument list to the first one. The second list is destroyed because all its elements are inserted into the first one. The result is obtained by pointer manipulation: no data is moved at all, and any pointers to the objects in the second list remain valid.

<div class="p"><!----></div>
Error checking is done in lines 4 to 19. Then, the observer interface is considered. Since the second list will be destroyed
a notification is sent to any observers that listen to events in that list. A notification is sent to the first list also,
informing the observers of this event.

<div class="p"><!----></div>
The actual work can then begin (lines 26 to 36):
<font size="+1"><tt><i>l2</i></tt></font>
is appended to
<font size="+1"><tt><i>l1</i></tt></font>
and the list header of
<font size="+1"><tt><i>l2</i></tt></font>
is freed.


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
The test for compatibility between both lists is done with the size of an element,
assuming elements of the same size are of the same type. This could
very well be false but there is no portable way of test this at run time. Anyway, since a container doesn't care what is
inside the objects it manages you can store elements of different types but the same size in a single container.

<div class="p"><!----></div>
<br />
<b>Apply</b><a 
name="Apply+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Apply(List&nbsp;*L,int&nbsp;(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*le;
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pElem=NULL;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L&nbsp;==&nbsp;NULL&nbsp;||&nbsp;Applyfn&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("iList.Apply",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Apply",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;Flags&amp;CONTAINER_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pElem&nbsp;=&nbsp;L-&#62;Allocator-&#62;malloc(L-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pElem&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("iList.Apply",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(le)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pElem)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(pElem,le-&#62;Data,L-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applyfn(pElem,arg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;Applyfn(le-&#62;Data,arg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;le-&#62;Next;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pElem)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;Allocator-&#62;free(pElem);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function calls the given function for each element. If the container is read only, a copy of each element is passed to the called function. This 
copy is allocated with "malloc" because it is used for internal purposes, and the standard allocator for the list could be a heap based, i.e. one that 
doesn't really free any memory. That could be a problem if repeated calls to <font size="+1"><tt>Apply</tt></font> are done.

<div class="p"><!----></div>
This function does not pass any pointer to the called function to mark the list as changed if the data passed to it is rewritten. This means that 
there is no way to let the called function inform the rest of the software of any modifications. This can be justified by the fact that only the data, 
not the container itself can be modified, but this can be tricky in multi-threaded environments. Other implementations could pass some pointer or away 
to inform the rest of the software that a modification has been done.
<br />

<div class="p"><!----></div>
<b>Clear</b><a 
name="Clear+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Clear_nd(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l,CCL_CLEAR,NULL,NULL);
#ifdef&nbsp;NO_GC
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Heap)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.Finalize(l-&#62;Heap);
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp&nbsp;=&nbsp;l-&#62;First,*tmp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;DestructorFn)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;DestructorFn(tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Allocator-&#62;free(tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
#endif
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Heap&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;Last&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Flags&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}&nbsp;&nbsp;&nbsp;

static&nbsp;int&nbsp;Clear(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NullPtrError("Clear");
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Clear",CONTAINER_ERROR_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Clear_nd(l);
}&nbsp;

</pre></font>
This function should clear all stored elements and reset some fields of the header structure so that the resulting list header is almost the same as when it was created. The only difference is that any functions like the comparison function or the error function are not cleared. If they were changed by the user they still remain changed.

<div class="p"><!----></div>
Like in other functions we have a no-debug function (named <font size="+1"><tt>Clear_nd</tt></font>) that assumes all its parameters are correct, and the 
official entry point that checks its arguments. If we are compiling with a garbage collector in mind we can save us all the
work of releasing each element since the collector will do that automatically.
<br />

<div class="p"><!----></div>
<b>Copy</b><a 
name="Copy+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;List&nbsp;*Copy(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*elem,*newElem;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NullPtrError("Copy");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;iList.CreateWithAllocator(l-&#62;ElementSize,l-&#62;Allocator);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Copy",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Flags&nbsp;=&nbsp;l-&#62;Flags;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;l-&#62;VTable;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Compare&nbsp;=&nbsp;l-&#62;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;RaiseError&nbsp;=&nbsp;l-&#62;RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(elem)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newElem&nbsp;=&nbsp;new_link(result,elem-&#62;Data,"iList.Copy");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newElem&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Copy",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable-&#62;Finalize(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elem&nbsp;==&nbsp;l-&#62;First)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;First&nbsp;=&nbsp;newElem;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Last-&#62;Next&nbsp;=&nbsp;newElem;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Last&nbsp;=&nbsp;newElem;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;=&nbsp;elem-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l,CCL_COPY,result,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}


</pre></font>
This function requires a non null list pointer. It creates a header structure, and fills some of it fields with the corresponding fields of the source list:

<ol type="1">
<li> The allocator
<div class="p"><!----></div>
</li>

<li> The flags.
<div class="p"><!----></div>
</li>

<li> The table of functions. This is necessary in case some of those functions have been sub-classed.
<div class="p"><!----></div>
</li>

<li> The comparison function
<div class="p"><!----></div>
</li>

<li> The error function
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
Note that the timestamp is not copied, and starts in the copy with zero.

<div class="p"><!----></div>
If an error occurs during the copy, probably because of lack of memory, the new list is destroyed and the result is &nbsp;NULL .
Otherwise elements are added at the growing end of the list.
<br />

<div class="p"><!----></div>
<b>Contains</b><a 
name="Contains+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Contains(List&nbsp;*l,void&nbsp;*data)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(IndexOf(l,data,NULL,&amp;idx)&nbsp;&lt;&nbsp;0)&nbsp;?&nbsp;0&nbsp;:&nbsp;1;
}

</pre></font>
The <font size="+1"><tt>Contains</tt></font> function is just a cover function for <font size="+1"><tt>IndexOf</tt></font>.
<br />

<div class="p"><!----></div>
<b>CopyElement</b><a 
name="CopyElement+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;CopyElement(List&nbsp;*l,size_t&nbsp;position,void&nbsp;*outBuffer)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;

&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Error&nbsp;checking&nbsp;elided&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(position)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memcpy(outBuffer,rvp-&#62;Data,l-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
After the error checking, this function positions at the given element and copies its contents into the  given buffer.
Other designs are obviously possible. 

<ul>
<li> This function could return a newly allocated buffer. This poses other problems like the type of allocator to use. If we use the list allocator we could run into problems if it is a specialized allocator that is designed for allocating list elements from a pool where no 'free' operation exists. Another, more important problem with that solution is that it forces an allocation when none is necessary if the buffer you use is stack based.
<div class="p"><!----></div>
</li>

<li> The function could require the buffer length to be sure there are no buffer overflows. This solution was discarded because it actually increases the chances of errors: you have to pass the size of the buffer, and if you pass the wrong one more problems arise. Is it an error if you pass more space than is actually needed? It could be an error if the passed size differs from the size of the elements stored or it could be just a consequence that you used the <font size="+1"><tt>sizeof(buffer)</tt></font> expression with a bigger buffer than necessary.
<div class="p"><!----></div>
</li>
</ul>
<br />

<div class="p"><!----></div>
<b>Create</b><a 
name="Create+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;List&nbsp;*Create(size_t&nbsp;elementsize)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CreateWithAllocator(elementsize,CurrentAllocator);
}

</pre></font>
This function just calls <font size="+1"><tt>CreateWithAllocator</tt></font> using the current memory manager.
<br />

<div class="p"><!----></div>
<b>CreateWithAllocator</b><a 
name="CreateWithAllocator+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;List&nbsp;*CreateWithAllocator(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elementsize&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Create",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;allocator-&#62;malloc(sizeof(List));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Create",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memset(result,0,sizeof(List));
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;ElementSize&nbsp;=&nbsp;elementsize;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;&amp;iList;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Compare&nbsp;=&nbsp;DefaultListCompareFunction;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;RaiseError&nbsp;=&nbsp;iError.RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Allocator&nbsp;=&nbsp;allocator;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
After doing some error checking, the creation function allocates and initializes the new container with its default values.

<div class="p"><!----></div>
A big question is the alignment problem for the given size. This can't be checked and could lead to problems if you pass to this function any argument that is not the product of a sizeof expression.
<br />

<div class="p"><!----></div>
<b>DefaultListCompareFunction</b><a 
name="DefaultListCompareFunction+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;DefaultListCompareFunction(const&nbsp;void&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;*ExtraArgs)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz=((List&nbsp;*)ExtraArgs-&#62;Container)-&#62;ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;memcmp(left,right,siz);
}

</pre></font>
The default element compare function is just a cover for <font size="+1"><tt>memcmp</tt></font>. It is assumed that the user will replace it with a comparison function of its own if necessary.
<br />

<div class="p"><!----></div>
<b>DefaultListLoadFunction</b><a 
name="DefaultListLoadFunction+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;size_t&nbsp;DefaultLoadFunction(void&nbsp;*element,void&nbsp;*arg,&nbsp;FILE&nbsp;*Infile)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;len&nbsp;=&nbsp;*(size_t&nbsp;*)arg;

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fread(element,1,len,Infile);
}

</pre></font>
This function just reads an element from the disk file. Returns the result value of <font size="+1"><tt>fread</tt></font>, what is OK for our purposes.
<br />

<div class="p"><!----></div>
<b>DefaultSaveFunction</b><a 
name="DefaultSaveFunction+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;size_t&nbsp;DefaultSaveFunction(const&nbsp;void&nbsp;*element,void&nbsp;*arg,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*Outfile)
{
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;unsigned&nbsp;char&nbsp;*str&nbsp;=&nbsp;element;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;len&nbsp;=&nbsp;*(size_t&nbsp;*)arg;

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fwrite(str,1,len,Outfile);
}

</pre></font>
This function just writes the given element to the disk. Together with the default load function they allow for a very effective serialization package for containers. Obviously here we have a shallow copy, and all this will never work for recursive saves, i.e. for elements that contain pointers.
<br />

<div class="p"><!----></div>
<b>DeleteIterator</b><a 
name="DeleteIterator+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;DeleteIterator(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(it&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("DeleteIterator",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;li-&#62;L;
&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;Allocator-&#62;free(it);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This routine retrieves the list header object from the hidden part of the iterator and uses its allocator object to free the memory used by the iterator.

<div class="p"><!----></div>
The functions <font size="+1"><tt>NewIterator</tt></font> and <font size="+1"><tt>DeleteIterator</tt></font> should occur in pairs like many others in C: malloc and free, fopen and fclose, etc. It would be very easy to have in the header object a counter of iterators that should be zero when the list is destroyed or cleared.
<br />

<div class="p"><!----></div>
<b>Equal</b><a 
name="Equal+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Equal(List&nbsp;*l1,List&nbsp;*l2)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*link1,*link2;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn;
&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;ci;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1&nbsp;==&nbsp;l2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1&nbsp;==&nbsp;NULL&nbsp;||&nbsp;l2&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;count&nbsp;!=&nbsp;l2-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;ElementSize&nbsp;!=&nbsp;l2-&#62;ElementSize)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;Compare&nbsp;!=&nbsp;l2-&#62;Compare)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;l1-&#62;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;link1&nbsp;=&nbsp;l1-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;link2&nbsp;=&nbsp;l2-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;ci.Container&nbsp;=&nbsp;l1;
&nbsp;&nbsp;&nbsp;&nbsp;ci.ExtraArgs&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(link1&nbsp;&amp;&amp;&nbsp;link2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fn(link1-&#62;Data,link2-&#62;Data,&amp;ci))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link1&nbsp;=&nbsp;link1-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link2&nbsp;=&nbsp;link2-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(link1&nbsp;||&nbsp;link2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
If two null pointers are passed to the <font size="+1"><tt>Equal</tt></font> function it returns true. This is a design decision: <font size="+1"><tt>Equal</tt></font> doesn't have any error result. Either the two objects are equal or not.

<div class="p"><!----></div>
A redundant test is done at the end of the function: if the lists have the same count and all elements are equal, link1 and link2 should be &nbsp;NULL . If they aren't that means there is a memory overwrite problem somewhere...
<br />

<div class="p"><!----></div>
<b>Erase</b><a 
name="Erase+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Erase(List&nbsp;*l,void&nbsp;*elem)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Erase",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elem&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Erase",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOTFOUND;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;IndexOf(l,elem,NULL,&amp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;RemoveAt(l,idx);
}

</pre></font>
This is a very inefficient implementation. The list will be traversed twice, the first by <font size="+1"><tt>IndexOf</tt></font>, and the second by <font size="+1"><tt>RemoveAt</tt></font>. The obvious solution is to merge both into one function.
<br />

<div class="p"><!----></div>
<b>EraseRange</b><a 
name="EraseRange+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;EraseRange(List&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp,*start_pos,*tmp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;toremove;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(end&nbsp;&#62;&nbsp;l-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;=&nbsp;l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&nbsp;&#62;=&nbsp;l-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&nbsp;&#62;=&nbsp;end)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;toremove&nbsp;=&nbsp;end&nbsp;-&nbsp;start+1;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp&nbsp;&amp;&amp;&nbsp;start&nbsp;&#62;&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;start_pos&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(toremove&nbsp;&#62;&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Heap)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.FreeObject(l-&#62;Heap,rvp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Allocator-&#62;free(rvp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toremove--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;start_pos-&#62;Next&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
</pre></font>
This function positions the cursor <a href="#tthFtNtAHD" name="tthFrefAHD"><sup>73</sup></a> at the element before
the one where the range starts, and then erases until it reaches the end of the range.
<br />

<div class="p"><!----></div>
<b>Finalize</b><a 
name="Finalize+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Finalize(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;t=0;

&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;Clear(l);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;t;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Allocator-&#62;free(l);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function should free the memory used by the header object. It is fundamental that this will never be done with an object not allocated with that iterator in the first place, i.e. when the user has called <font size="+1"><tt>Init</tt></font> instead of <font size="+1"><tt>Create</tt></font>. This can't be tested in a portable manner since there is no function to verify that a given memory space belongs or not to a given allocator.<a href="#tthFtNtAHE" name="tthFrefAHE"><sup>74</sup></a>
<br />

<div class="p"><!----></div>
<b>GetCurrent</b><a 
name="GetCurrent+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;void&nbsp;*GetCurrent(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;L-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;index&nbsp;==&nbsp;(size_t)-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;L-&#62;RaiseError("GetCurrent",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;L-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;ElementBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;Current-&#62;Data;
}

</pre></font>
Returns the current object pointed by the given iterator. This function should be called only after <font size="+1"><tt>GetFirst</tt></font> is called. It verifies this by testing if a correct value is stored in the <font size="+1"><tt>index</tt></font> field. This value is stored by the <font size="+1"><tt>NewIterator</tt></font> function. This simple algorithm avoids the usage of an uninitialized iterator at the cost of one integer comparison per call.

<div class="p"><!----></div>
<br />
<b>GetFirst</b><a 
name="GetFirst+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;void&nbsp;*GetFirst(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;


&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;li-&#62;L;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;timestamp&nbsp;!=&nbsp;L-&#62;timestamp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("iList.GetFirst",CONTAINER_ERROR_OBJECT_CHANGED);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(li-&#62;ElementBuffer,L-&#62;First-&#62;Data,L-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;ElementBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;L-&#62;First-&#62;Data;
}

</pre></font>
This function should set the iteration at the first element of the container, ready to get the iteration started. After the error checking phase it returns a pointer to the data in the first element, or a pointer to a copy of that data if the container is read only.
<br />

<div class="p"><!----></div>
<b>GetFlags</b><a 
name="GetFlags+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;unsigned&nbsp;GetFlags(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.GetFlags",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(unsigned)CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;l-&#62;Flags;
}

</pre></font>
Just returns the value of the flags.
<br />

<div class="p"><!----></div>
<b>GetNext</b><a 
name="GetNext+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;void&nbsp;*GetNext(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*result;


&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.GetNext",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;li-&#62;L;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;index&nbsp;&#62;=&nbsp;(L-&#62;count-1)&nbsp;||&nbsp;li-&#62;Current&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;L-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;timestamp&nbsp;!=&nbsp;L-&#62;timestamp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("GetNext",CONTAINER_ERROR_OBJECT_CHANGED);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;li-&#62;Current-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index++;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(li-&#62;ElementBuffer,li-&#62;Current-&#62;Data,L-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;ElementBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;li-&#62;Current-&#62;Data;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
Advances the cursor to the next element and returns either a pointer to it or a pointer to a copy if the list is read only. The test for the cursor being &nbsp;NULL avoids using <font size="+1"><tt>GetNext</tt></font> with an uninitialized iterator.
<br />

<div class="p"><!----></div>
<b>GetPrevious</b><a 
name="GetPrevious+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;void&nbsp;*GetPrevious(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;li-&#62;L;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;index&nbsp;&#62;=&nbsp;L-&#62;count&nbsp;||&nbsp;li-&#62;index&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;timestamp&nbsp;!=&nbsp;L-&#62;timestamp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("GetPrevious",CONTAINER_ERROR_OBJECT_CHANGED);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;i=0;
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index--;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;index&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp&nbsp;&amp;&amp;&nbsp;i&nbsp;&lt;&nbsp;li-&#62;index)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;rvp-&#62;Data;
}

</pre></font>
There were heated discussions about this function. In single linked lists it is necessary to go through the whole list at each call to this function. This is extremely inefficient and its usage should be avoided, it is much better to use double linked lists if you are interested in bi-directional cursor positioning. In the other hand this should be a required iterator feature, and rather than filling this function pointer with a function that just returns an error, the user is better served with a function that actually returns the previous item. Besides for short lists the performance lost is quite small, and would justify using lists with smaller overhead per item.<a href="#tthFtNtAHF" name="tthFrefAHF"><sup>75</sup></a>.
<br />

<div class="p"><!----></div>
<b>GetRange</b><a 
name="GetRange+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;List&nbsp;*GetRange(List&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;counter;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;;

&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;iList.Create(l-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;l-&#62;VTable;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(end&nbsp;&#62;=&nbsp;l-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;=&nbsp;l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&nbsp;&#62;&nbsp;end&nbsp;||&nbsp;start&nbsp;&#62;&nbsp;l-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&nbsp;==&nbsp;l-&#62;count-1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(counter&nbsp;&lt;&nbsp;start)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(start&nbsp;&lt;&nbsp;end&nbsp;&amp;&amp;&nbsp;rvp&nbsp;!=&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;result-&#62;VTable-&#62;Add(result,&amp;rvp-&#62;Data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finalize(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
A new list is constructed from the given range of elements. The elements are copied. Any error during the construction of the new list provokes a &nbsp;NULL result: the copied elements are destroyed. Only correctly constructed ranges are returned. A recurring problem arises because it is impossible to report any details about the error that stops the copy. The result is actually boolean, either everything worked and there is a non &nbsp;NULL result, or something didn't. 

<div class="p"><!----></div>
An alternative design would have an integer return code, and a pointer to a result. This option was discarded because it is cumbersome and the most likely reason for <font size="+1"><tt>Add</tt></font> to fail is lack of memory.
<br />

<div class="p"><!----></div>
<b>IndexOf</b><a 
name="IndexOf+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;IndexOf(List&nbsp;*l,void&nbsp;*ElementToFind,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs,size_t&nbsp;*result)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r,i=0;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn;
&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;ci;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL&nbsp;||&nbsp;ElementToFind&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.IndexOf",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.IndexOf",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;l-&#62;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;ci.Container&nbsp;=&nbsp;l;
&nbsp;&nbsp;&nbsp;&nbsp;ci.ExtraArgs&nbsp;=&nbsp;ExtraArgs;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;fn(&amp;rvp-&#62;Data,ElementToFind,&amp;ci);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*result&nbsp;=&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOTFOUND;
}

</pre></font>
The design of this function went through several iterations. The big problem was the result type: a <font size="+1"><tt>size_t</tt></font>, that in most cases is an unsigned quantity. A negative error result then was out of the question. But then, how would you indicate an error? <a href="#tthFtNtAHG" name="tthFrefAHG"><sup>76</sup></a>

<div class="p"><!----></div>
A first solution was to return a 1 based index and reserve zero for the 'not found' value. That could work, but was the source of many bugs in the rest of the software when the value was used without decrementing it first. 

<div class="p"><!----></div>
A second solution was to reserve a value within the <font size="+1"><tt>size_t</tt></font> range to represent the 'not found' result. That works, and it is doable, but produced other, more subtle, problems in the rest of the software since in all checks of a size_t, it could be that <i>this</i> size_t has a value that is actually the sentinel value of <font size="+1"><tt>IndexOf</tt></font>: the tests tended to multiply and the handling of those tests started to become a problem.

<div class="p"><!----></div>
Here you see the third iteration: the function receives a pointer to a size_t that will be set if the function returns with a result greater than zero.

<div class="p"><!----></div>
Another, completely different issue is the fact that in lists, this function is inefficient since it forces the function that uses the result to restart a list traversal to access the nth element. Much more efficient would be to do something immediately with the result, or to return a list element that allows the calling software to use it without going again through the list. 

<div class="p"><!----></div>
Problems with those solutions is that they are not portable, and that they would expose the inner workings of the list container to the users. The <font size="+1"><tt>list_element</tt></font> structure is not even mentioned in the public containers.h.

<div class="p"><!----></div>
<br />
<b>InitWithAllocator</b><a 
name="InitWithAllocator+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;List&nbsp;*InitWithAllocator(List&nbsp;*result,size_t&nbsp;elementsize,
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elementsize&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Init",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memset(result,0,sizeof(List));
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;ElementSize&nbsp;=&nbsp;elementsize;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;&amp;iList;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Compare&nbsp;=&nbsp;DefaultListCompareFunction;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;RaiseError&nbsp;=&nbsp;iError.RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Allocator&nbsp;=&nbsp;allocator;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
This function initializes a piece of storage to a list container. This allows the user to use stack storage for the list container, saving an allocation from the heap, and the corresponding need to free that storage.
<br />

<div class="p"><!----></div>
<b>Init</b><a 
name="Init+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;List&nbsp;*Init(List&nbsp;*result,size_t&nbsp;elementsize)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;InitWithAllocator(result,elementsize,CurrentAllocator);
}

</pre></font>
Uses the current memory manager to call InitWithAllocator.
<br />

<div class="p"><!----></div>
<b>InsertAt</b><a 
name="InsertAt+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;InsertAt(List&nbsp;*l,size_t&nbsp;pos,void&nbsp;*pdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*elem;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL&nbsp;||&nbsp;pdata&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertAt",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.InsertAt",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pos&nbsp;&#62;&nbsp;l-&#62;count)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertAt",CONTAINER_ERROR_INDEX);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INDEX;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertAt",CONTAINER_ERROR_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pos&nbsp;==&nbsp;l-&#62;count)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;l-&#62;VTable-&#62;Add(l,pdata);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;=&nbsp;new_link(l,pdata,"iList.&nbsp;InsertAt");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elem&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertAt",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pos&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem-&#62;Next&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;elem;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(--pos&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem-&#62;Next&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp-&#62;Next&nbsp;=&nbsp;elem;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count++;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This inserts before the given index. It would have been equally possible to insert after, that is a more or less random decision.
<br />

<div class="p"><!----></div>
<b>InsertIn</b><a 
name="InsertIn+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;InsertIn(List&nbsp;*l,&nbsp;size_t&nbsp;idx,List&nbsp;*newData)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;newCount;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*le,*nle;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;&nbsp;l-&#62;count)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertIn",CONTAINER_ERROR_INDEX);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INDEX;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;ElementSize&nbsp;!=&nbsp;newData-&#62;ElementSize)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertIn",CONTAINER_ERROR_INCOMPATIBLE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INCOMPATIBLE;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newData-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;newData&nbsp;=&nbsp;Copy(newData);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newData&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertIn",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;newCount&nbsp;=&nbsp;l-&#62;count&nbsp;+&nbsp;newData-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;newData-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;newData-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(le&nbsp;&amp;&amp;&nbsp;idx&nbsp;&#62;&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;le-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nle&nbsp;=&nbsp;le-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le-&#62;Next&nbsp;=&nbsp;newData-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newData-&#62;Last-&#62;Next&nbsp;=&nbsp;nle;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;newData-&#62;Allocator-&#62;free(newData);
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count&nbsp;=&nbsp;newCount;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
Inserts the given list at the specified position.

<ol type="1">
<li> Error checking. First argument must be non &nbsp;NULL and read/write. Second must be non &nbsp;NULL .
<div class="p"><!----></div>
</li>

<li> If the position given is exactly the same as the length of the receiving list, the second list is just appended to the first one.
<div class="p"><!----></div>
</li>

<li> Otherwise search the position and insert a copy of the elements in the second list.
<div class="p"><!----></div>
</li>
</ol>
<br />

<div class="p"><!----></div>
<b>Load</b><a 
name="Load+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;List&nbsp;*Load(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;loadFn,void&nbsp;*arg)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i,elemSize;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result,L;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*buf;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r;
&nbsp;&nbsp;&nbsp;&nbsp;guid&nbsp;Guid;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(loadFn&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadFn&nbsp;=&nbsp;DefaultLoadFunction;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg&nbsp;=&nbsp;&amp;elemSize;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fread(&amp;Guid,sizeof(guid),1,stream)&nbsp;&lt;=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_FILE_READ);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(memcmp(&amp;Guid,&amp;ListGuid,sizeof(guid)))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_WRONGFILE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fread(&amp;L,1,sizeof(List),stream)&nbsp;&lt;=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_FILE_READ);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;elemSize&nbsp;=&nbsp;L.ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;=&nbsp;malloc(L.ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;iList.Create(L.ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Flags&nbsp;=&nbsp;L.Flags;
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&nbsp;&lt;&nbsp;L.count;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(loadFn(buf,arg,stream)&nbsp;&lt;=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;CONTAINER_ERROR_FILE_READ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((r=Add(result,buf))&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;free(buf);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",r);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>

<div class="p"><!----></div>
The load function is long and complex. As always, the process starts with error checking. All streams written to by its counterpart <font size="+1"><tt>Save</tt></font> are 
marked with a container specific globally unique identifier (GUID). This ensures that a load function from the list container will not crash if passed a file that belongs to an array or a dictionary, or a totally unrelated file. The guids can be changed to mark the versions of the software and
allow more advanced versions to read older versions.<a 
name="guid41"></a>

<div class="p"><!----></div>
Then, the header object is read, what gives the data to continue the process, since we now know the number of elements and the size of each element.

<div class="p"><!----></div>
A new list is created with the given element size, and we start reading <i>count</i> elements from the stream. Any error provokes the destruction of the elements read so far and a result of NULL.
<br />

<div class="p"><!----></div>
<b>NewIterator</b><a 
name="NewIterator+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;Iterator&nbsp;*NewIterator(List&nbsp;*L)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*result;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.NewIterator",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;L-&#62;Allocator-&#62;malloc(sizeof(struct&nbsp;ListIterator));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("iList.NewIterator",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;it.GetNext&nbsp;=&nbsp;GetNext;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;it.GetPrevious&nbsp;=&nbsp;GetPrevious;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;it.GetFirst&nbsp;=&nbsp;GetFirst;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;it.GetCurrent&nbsp;=&nbsp;GetCurrent;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;L&nbsp;=&nbsp;L;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;timestamp&nbsp;=&nbsp;L-&#62;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;index&nbsp;=&nbsp;(size_t)-1;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Current&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&amp;result-&#62;it;
}

</pre></font>
The creation of a new iterator involves just allocating and initializing values to their defaults.
<br />

<div class="p"><!----></div>
<b>PopFront</b><a 
name="PopFront+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;PopFront(List&nbsp;*l,void&nbsp;*result)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*le;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;Last&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;First-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count--;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(result,&amp;le-&#62;Data,l-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Heap)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.FreeObject(l-&#62;Heap,le);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;l-&#62;Allocator-&#62;free(le);
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
Contrary to most versions of this function, <font size="+1"><tt>PopFront</tt></font> does not return the data of the element but stores it in a pointer that it receives. If the pointer is &nbsp;NULL , the data is just discarded.

<div class="p"><!----></div>
The problem with returning a pointer to the first element, is that the user code should remember to discard it when no longer needed, and it should discard it using the same allocator that the list used to allocate it. That would be a very error prone interface.
<br />

<div class="p"><!----></div>
<b>PushFront</b><a 
name="PushFront+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;PushFront(List&nbsp;*l,void&nbsp;*pdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;

&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;new_link(l,pdata,"Insert");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rvp&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;rvp-&#62;Next&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Last&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count++;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
Lists are a good base to implement a stack. PushFront and PopFront take a constant and small time to complete and they would be much smaller if we would eliminate the error checking.
<br />

<div class="p"><!----></div>
<b>RemoveAt</b><a 
name="RemoveAt+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;RemoveAt(List&nbsp;*l,size_t&nbsp;position)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp,*last,*removed;


&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(position&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;Last&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;First-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(position&nbsp;==&nbsp;l-&#62;count&nbsp;-&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp-&#62;Next&nbsp;!=&nbsp;l-&#62;Last)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(position&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position&nbsp;--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last-&#62;Next&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Heap)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.FreeObject(l-&#62;Heap,removed);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;l-&#62;Allocator-&#62;free(removed);
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;--l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
The operation when <font size="+1"><tt>RemoveAt</tt></font> is called with the index of the last element is equivalent to the <font size="+1"><tt>PopBack</tt></font> function, that is absent in the single linked list interface. After much discussions, we decided that the generic interface would have only Push and Pop, and that each container would fill those functions with the most efficient implementation available for it. For lists, the most efficient implementation is PopFront and PushFront. For arrays, the most efficient is PushBack and PopBack. For double linked lists is either.
<br />

<div class="p"><!----></div>
<b>ReplaceAt</b><a 
name="ReplaceAt+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;ReplaceAt(List&nbsp;*l,size_t&nbsp;position,void&nbsp;*data)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(position&nbsp;==&nbsp;l-&#62;count-1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(position)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;rvp-&#62;Data&nbsp;,&nbsp;data,l-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
After error checking (not shown), position the cursor at the right item, then copy from the given data pointer the element size bytes needed.

<div class="p"><!----></div>
An open issue is whether the "timestamp" field should be changed. Nothing in the list structure has been changed, only the data stored in the container. Any iterators will go on working as advertised even if this function is called to replace many items in the list. In the other hand, if  user programs were making assumptions about the data (for instance a search function doesn't always look again at past items to see if they have been changed) this could bad consequences. As a rule, any change will provoke the incrementing of the "timestamp" counter.
<br />

<div class="p"><!----></div>
<b>Reverse</b><a 
name="Reverse+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Reverse(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*New,*current,*old;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;old&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;New&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(old)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;old;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old&nbsp;=&nbsp;old-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current-&#62;Next&nbsp;=&nbsp;New;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New&nbsp;=&nbsp;current;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;New;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
After the error checking, the list is reversed in place if the count of its element is bigger than 1.<a href="#tthFtNtAHH" name="tthFrefAHH"><sup>77</sup></a>
<br />

<div class="p"><!----></div>
<b>RotateLeft</b><a 
name="RotateLeft+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;RotateLeft(List&nbsp;*l,&nbsp;size_t&nbsp;n)
{
&nbsp;&nbsp;&nbsp;&nbsp;ListElement&nbsp;*rvp,*oldStart,*last=NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NullPtrError("RotateLeft");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ErrorReadOnly(l,"RotateLeft");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2&nbsp;||&nbsp;n&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;%=&nbsp;l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;oldStart&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;oldStart;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;last;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
The <font size="+1"><tt>RotateLeft</tt></font> and the <font size="+1"><tt>RotateRight</tt></font>functions can be implemented without any movement of the stored objects themselves. It suffices to make the list start at another place: <i>n</i> places after the start for left rotates, or n places before the end for right rotates.
<br />

<div class="p"><!----></div>
<b>RotateRight</b><a 
name="RotateRight+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;RotateRight(List&nbsp;*l,&nbsp;size_t&nbsp;n)
{
&nbsp;&nbsp;&nbsp;&nbsp;ListElement&nbsp;*rvp,*oldStart,*last=NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NullPtrError("RotateRight");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ErrorReadOnly(l,"RotateRight");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2&nbsp;||&nbsp;n&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;%=&nbsp;l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;oldStart&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;l-&#62;count&nbsp;-&nbsp;n;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(last&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("RotateRight",CONTAINER_INTERNAL_ERROR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_INTERNAL_ERROR;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;oldStart;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;last;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>

<div class="p"><!----></div>
The <font size="+1"><tt>RotateRight/RotateLeft</tt></font> functions check their arguments to the contrary of their <font size="+1"><tt>ValArray</tt></font> counterparts that do not. This 
implementation shows also a checking of values that <i>should</i> be non-null but could be &nbsp;NULL if there is a memory overwrite or another
similar problem.
<br />

<div class="p"><!----></div>
<b>Save</b><a 
name="Save+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Save(List&nbsp;*L,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(saveFn&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saveFn&nbsp;=&nbsp;DefaultSaveFunction;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg&nbsp;=&nbsp;&amp;L-&#62;ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fwrite(&amp;ListGuid,sizeof(guid),1,stream)&nbsp;&lt;=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EOF;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fwrite(L,1,sizeof(List),stream)&nbsp;&lt;=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EOF;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;&nbsp;L-&#62;count;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*p&nbsp;=&nbsp;rvp-&#62;Data;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(saveFn(p,arg,stream)&nbsp;&lt;=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EOF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
The format of the saved list container is:

<ol type="1">
<li> The GUID of the list container: 128 bytes
<div class="p"><!----></div>
</li>

<li> The Header object
<div class="p"><!----></div>
</li>

<li> The data for all the elements of the list. This is the siz of the container times the element size.
<div class="p"><!----></div>
</li>
</ol>
<br />

<div class="p"><!----></div>
<b>Seek</b><a 
name="Seek+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;void&nbsp;*Seek(Iterator&nbsp;*it,size_t&nbsp;idx)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;


&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;L-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;

&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;li-&#62;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;=&nbsp;li-&#62;L-&#62;count-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index&nbsp;=&nbsp;li-&#62;L-&#62;count-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;li-&#62;L-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(idx&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;li-&#62;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index&nbsp;=&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(idx&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;Current;
}

</pre></font>
This function positions the given iterator at the desired position. Several alternatives are possible, for instance position the iterator at a
given item. This can be obtained now only by calling first <font size="+1"><tt>IndexOf</tt></font>, then <font size="+1"><tt>Seek</tt></font>, what forces to go through the list twice.
<br />

<div class="p"><!----></div>
<b>SetCompareFunction</b><a 
name="SetCompareFunction+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;CompareFunction&nbsp;SetCompareFunction(List&nbsp;*l,CompareFunction&nbsp;fn)
{
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;oldfn&nbsp;=&nbsp;l-&#62;Compare;

&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.SetCompareFunction",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if&nbsp;(fn&nbsp;!=&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&amp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.SetCompareFunction",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTAINER_LIST_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;l-&#62;Compare&nbsp;=&nbsp;fn;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return&nbsp;oldfn;
}

</pre></font>
This function returns the old value of the comparison function and sets it to the new one, if the new one is not &nbsp;NULL . This allows to query the comparison function without changing it, avoiding yet another trivial function like GetComparisonFunction. This is just what in other languages like Objective C or others is called a <i>property</i> of the iList object. Objective C makes all this automatic with its <font size="+1"><tt>synthesize</tt></font> directive.

<div class="p"><!----></div>
In C there isn't any such hand holding and you have to write that code yourself. There are several other functions in the same style like <font size="+1"><tt>SetErrorFunction</tt></font>, <font size="+1"><tt>Size</tt></font> (that returns the <font size="+1"><tt>count</tt></font> field) and <font size="+1"><tt>SetFlags</tt></font>. They aren't listed here but you can look at the code by browsing through the list.c file distributed
with this software.
<br />

<div class="p"><!----></div>
<b>Sizeof</b><a 
name="Sizeof+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;size_t&nbsp;Sizeof(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sizeof(List);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sizeof(List)&nbsp;+&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;ElementSize&nbsp;*&nbsp;l-&#62;count&nbsp;+&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count&nbsp;*sizeof(list_element);
}

</pre></font>
Returns the number of bytes used by the given list, including the data, and all overhead. For lists, this is the size of the header object, and for 
each element the overhead of a pointer to the next element and the size of each stored object. With a &nbsp;NULL list pointer returns the size of the list 
header object, what allows you to allocate buffers containing a header object and use the <font size="+1"><tt>Init</tt></font> function.
<br />

<div class="p"><!----></div>
<b>Sort</b><a 
name="Sort+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Sort(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;**tab;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;
&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;ci;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Sort",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&amp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Sort",CONTAINER_ERROR_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;=&nbsp;l-&#62;Allocator-&#62;malloc(l-&#62;count&nbsp;*&nbsp;sizeof(list_element&nbsp;*));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tab&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Sort",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;l-&#62;count;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tab[i]&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ci.Container&nbsp;=&nbsp;l;
&nbsp;&nbsp;&nbsp;&nbsp;ci.ExtraArgs&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;qsortEx(tab,l-&#62;count,sizeof(list_element&nbsp;*),lcompar,&amp;ci);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;l-&#62;count-1;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tab[i]-&#62;Next&nbsp;=&nbsp;tab[i+1];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;tab[l-&#62;count-1]-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;tab[l-&#62;count-1];
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;tab[0];
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Allocator-&#62;free(tab);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;

}

</pre></font>
This function basically builds an array and calls quicksort, nothing really fancy. Note that it calls a modified version of the library
function quicksort, since it needs to pass a context to it for the comparison function.
The default comparison function is listed below:

<font size=+1><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
static&nbsp;bool&nbsp;lcompar&nbsp;(const&nbsp;void&nbsp;*elem1,&nbsp;const&nbsp;void&nbsp;*elem2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;*ExtraArgs)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*Elem1&nbsp;=&nbsp;*(list_element&nbsp;**)elem1;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*Elem2&nbsp;=&nbsp;*(list_element&nbsp;**)elem2;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*l&nbsp;=&nbsp;(List&nbsp;*)ExtraArgs-&#62;Container;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn&nbsp;=&nbsp;l-&#62;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fn(Elem1-&#62;Data,Elem2-&#62;Data,ExtraArgs);
}

</pre></font>
The default comparison function pulls the list compare function and calls it with the extra arguments needed to
pass a context to it.
<br />

<div class="p"><!----></div>
<b>SplitAfter</b><a 
name="SplitAfter+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;List&nbsp;*SplitAfter(List&nbsp;*l,&nbsp;ListElement&nbsp;*pt)
{
&nbsp;&nbsp;&nbsp;&nbsp;ListElement&nbsp;*pNext;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count=0;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pt&nbsp;==&nbsp;NULL&nbsp;||&nbsp;l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.NullPtrError("iList.SplitAfter");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&amp;CONTAINER_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorReadOnly(l,"SplitAfter");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;pNext&nbsp;=&nbsp;pt-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pNext&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;CreateWithAllocator(l-&#62;ElementSize,&nbsp;l-&#62;Allocator);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;First&nbsp;=&nbsp;pNext;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(pNext)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pNext-&#62;Next&nbsp;==&nbsp;NULL)&nbsp;result-&#62;Last&nbsp;=&nbsp;pNext;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pNext&nbsp;=&nbsp;pNext-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;count&nbsp;=&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;pt-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;pt;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count&nbsp;-=&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
After the normal error checking of arguments, this function gets the next element after the given one. If there is none, it is impossible
to split the list after after the given element since it is the last. We return &nbsp;NULL (lines 15-16).

<div class="p"><!----></div>
If there is an element, it will be the head of the new list. We create a new list (line 17) using the source list allocator
and we set the given element (argument <font size="+1"><tt>pt</tt></font>) as the first one of the new 
list. We then count the elements (lines 20 to 24) in the new list
since we need to fill the "count" field in the new list. This makes this operation much more expensive than it would be
if we didn't maintain a "count" field<a href="#tthFtNtAHI" name="tthFrefAHI"><sup>78</sup></a>.
In lines 27-31 we set the correct fields in the new list, decrease the "count" field in the source list by the number of elements in the new list,
and we note the fact that the input list has been modified in line 31.
<br />

<div class="p"><!----></div>
<b>RotateLeft</b><a 
name="RotateLeft+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
&nbsp;&nbsp;1&nbsp;static&nbsp;int&nbsp;RotateLeft(List&nbsp;*&nbsp;l,&nbsp;size_t&nbsp;n)
&nbsp;&nbsp;2&nbsp;{
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListElement&nbsp;&nbsp;&nbsp;&nbsp;*rvp,&nbsp;*oldStart,&nbsp;*last&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NullPtrError("RotateLeft");
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ErrorReadOnly(l,&nbsp;"RotateLeft");
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2&nbsp;||&nbsp;n&nbsp;==&nbsp;0)
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;%=&nbsp;l-&#62;count;
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldStart&nbsp;=&nbsp;rvp;
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n--;
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;rvp;
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;oldStart;
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;last;
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;25&nbsp;}

</pre></font>

<div class="p"><!----></div>
Rotating a list is very simple: Cut the list at the desired place, and append the list elements from the start up to the cut point at the 
end of the list. 

<div class="p"><!----></div>
After the error checking is done (lines 3-12) we start
a first loop where we find the place to cut: lines 15-19.
Then, we cut (set the previous element's <font size="+1"><tt>Next</tt></font> pointer to&nbsp;NULL in line 21) and append the
elements we cut to the end of the list, updating the list's header.

<div class="p"><!----></div>
<br />
<b>UseHeap</b><a 
name="UseHeap+code for \container41"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;UseHeap(List&nbsp;*L,&nbsp;ContainerAllocator&nbsp;*m)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.UseHeap",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;Heap&nbsp;||&nbsp;L-&#62;count)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("UseHeap",CONTAINER_ERROR_NOT_EMPTY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOT_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(m&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;CurrentAllocator;
&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;Heap&nbsp;=&nbsp;iHeap.Create(L-&#62;ElementSize+sizeof(list_element),&nbsp;m);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function installs a heap to be used by the list. This is very important for huge lists, since performance goes quickly down if you call malloc 
for each element you add to the list. Basically, the heap is just a way to allocate memory in blocks so that malloc calls are reduced.

     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Queues</h3>
Queues are, to use the C++ terminology, <i>adaptor</i> containers, i.e. containers based on other containers, in this case a list. We describe here
an implementation with the objective to show how those adaptors can be implemented, and how you can restrain the interface of the underlying container
with a small cost.

<div class="p"><!----></div>
The data structure used is very simple:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_Queue&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;QueueInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*Items;
}&nbsp;_Queue;

</pre></font>
Just two fields: the interface and the underlying list.
We do not document here some functions of the queue interface that trivially call the corresponding List functions.

<div class="p"><!----></div>
<br />
<b>Back</b><a 
name="Back+code for \container42"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Back(Queue&nbsp;*Q,void&nbsp;*result)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Q&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iQueue.Front",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;iList.Size(Q-&#62;Items);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;iList.CopyElement(Q-&#62;Items,idx-1,result);
}

</pre></font>
Returns the last element of the queue. We do not want to have any errors issued by the underlying list, so we test for &nbsp;NULL . We use the size as an index, except of course when the queue is empty.
<br />

<div class="p"><!----></div>
<b>CreateWithAllocator</b><a 
name="CreateWithAllocator+code for \container42"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;Queue&nbsp;*CreateWithAllocator(size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator)
{
&nbsp;&nbsp;&nbsp;&nbsp;Queue&nbsp;*result&nbsp;=&nbsp;allocator-&#62;malloc(sizeof(Queue));

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Items&nbsp;=&nbsp;iList.CreateWithAllocator(ElementSize,allocator);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result-&#62;Items&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocator-&#62;free(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;&amp;iQueue;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
Using the given allocator, we get memory for the Queue object, then for the list using the given allocator.
<br />

<div class="p"><!----></div>
<b>Finalize</b><a 
name="Finalize+code for \container42"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Finalize(Queue&nbsp;*Q)
{
&nbsp;&nbsp;&nbsp;&nbsp;ContainerAllocator&nbsp;*allocator&nbsp;=&nbsp;iList.GetAllocator(Q-&#62;Items);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(Q-&#62;Items);
&nbsp;&nbsp;&nbsp;&nbsp;allocator-&#62;free(Q);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
We should free the queue header object with the same allocator we used for the list. We obtain it first, before we free the list.
<br />

<div class="p"><!----></div>
<b>Front</b><a 
name="Front+code for \container42"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Front(Queue&nbsp;*Q,void&nbsp;*result)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Q&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iQueue.Front",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;iList.Size(Q-&#62;Items);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;iList.CopyElement(Q-&#62;Items,0,result);
}

</pre></font>
Same as <font size="+1"><tt>Back</tt></font>. We make the error checking to avoid errors when accessing the list.
<br />

<div class="p"><!----></div>
<b>Sizeof</b><a 
name="Sizeof+code for \container42"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;size_t&nbsp;Sizeof(Queue&nbsp;*q)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(q&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;sizeof(Queue);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sizeof(*q)&nbsp;+&nbsp;iList.Sizeof(q-&#62;Items);
}

</pre></font>
If passed a &nbsp;NULL queue, we return the size of the Queue header object. Note that we do not return the size of the underlying list even if it has been allocated and uses up space. An alternative design would have required to take into account the list header as it would have been part of the overhead of the Queue object. But in that case we could never know the size of the Queue itself...

     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;The dictionary</h3>
Dictionary is an instance of a hash table where the key is supposed to contain character strings (names) that are associated with some data. Hash 
tables are normal tables that are indexed by a hash function, i.e. a function that maps character strings into some integer that is used to index the 
table. At each slot of the table we find a linked list of elements that were classified by the hash function into the same slot. If we have a good hash function, i.e. one that spreads evenly the elements across the table, we can have a speed up for searching an element of the order of the table size, in the best case.

<div class="p"><!----></div>
      <h4><a name="tth_sEc4.3.1">
4.3.1</a>&nbsp;&nbsp;Hashing</h4>
One of the important aspects of a dictionary implementation is to use a good hash function, i.e. one that distributes evenly the keys. I have picked
up for this work one of the most used functions of this type. Here is the documentation I found for this function in the Apache runtime:

<div class="p"><!----></div>

<blockquote>This is the popular `times 33' hash algorithm which is used by perl and that also appears in Berkeley DB. This is one of the best
 known hash functions for strings because it is both computed very fast and distributes very well.

<div class="p"><!----></div>
 The originator may be Dan Bernstein but the code in Berkeley DB cites Chris Torek as the source. The best citation I have found
 is "Chris Torek, Hash function for text in C, Usenet message   &lt; 27038@mimsy.umd.edu &gt;  in comp.lang.c , October, 1990." in Rich
 Salz's USENIX 1992 paper about INN which can be found at  <u>http://citeseer.nj.nec.com/salz92internetnews.html</u>.

<div class="p"><!----></div>
    The magic of number 33, i.e. why it works better than many other constants, prime or not, has never been adequately explained by
 anyone. So I try an explanation: if one experimentally tests all  multipliers between 1 and 256 (as I did while writing a low-level
 data structure library some time ago) one detects that even numbers are not useable at all. The remaining 128 odd numbers
 (except for the number 1) work more or less all equally well.  They all distribute in an acceptable way and this way fill a hash
 table with an average percent of approx. 86%.

<div class="p"><!----></div>
   If one compares the chi<sup>2</sup> 
 values of the variants (see Bob Jenkins "Hashing FAQ" at <u>
 http://burtleburtle.net/bob/hash/hashfaq.html</u>  for a description  of chi<sup>2</sup>), the number 33 not even has the best value. 
<div class="p"><!----></div>
 But the
 number 33 and a few other equally good numbers like 17, 31, 63, 127 and 129 have nevertheless a great advantage to the remaining
 numbers in the large set of possible multipliers: their multiply operation can be replaced by a faster operation based on just one
 shift plus either a single addition or subtraction operation. And  because a hash function has to both distribute good <i>and</i> has to
 be very fast to compute, those few numbers should be preferred.

<div class="p"><!----></div>
                 - Ralf S. Engelschall  &lt; rse@engelschall.com &gt; 
                
</blockquote>
Julienne Walker has another twist to this story. She says:<a href="#tthFtNtAHJ" name="tthFrefAHJ"><sup>79</sup></a>

<blockquote>
Bernstein hash

<div class="p"><!----></div>
Dan Bernstein created this algorithm and posted it in a newsgroup. It is known by many as the Chris Torek hash because Chris went a long way toward popularizing it. Since then it has been used successfully by many, but despite that the algorithm itself is not very sound when it comes to avalanche and permutation of the internal state. It has proven very good for small character keys, where it can outperform algorithms that result in a more random distribution.

<div class="p"><!----></div>
Bernstein's hash should be used with caution. It performs very well in practice, for no apparently known reasons (much like how the constant 33 does better than more logical constants for no apparent reason), but in theory it is not up to snuff. Always test this function with sample data for every application to ensure that it does not encounter a degenerate case and cause excessive collisions.
</blockquote>
<br />

<div class="p"><!----></div>
<b>hash</b><a 
name="hash+code for \container43"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;unsigned&nbsp;int&nbsp;hash(const&nbsp;unsigned&nbsp;char&nbsp;*key)
{
&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Hash&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;const&nbsp;unsigned&nbsp;char&nbsp;*p;
		
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(p&nbsp;=&nbsp;key;&nbsp;*p;&nbsp;p++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hash&nbsp;=&nbsp;Hash&nbsp;*&nbsp;33&nbsp;+&nbsp;scatter[*p];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Hash;
}

</pre></font>
Note that I have slightly modified the algorithm by using a scatter table of 256 positions filled with random numbers. The objective is to avoid
that letters that appear frequently in the text would tend to cluster the keys in  the same position.

<div class="p"><!----></div>
This default function may not be the best for the data in the user's application. The library has reserved a field in the dictionary header object for a pointer to a hash function that can be changed by the user.

<div class="p"><!----></div>
      <h4><a name="tth_sEc4.3.2">
4.3.2</a>&nbsp;&nbsp;Creation</h4>
Another important aspect of the dictionary implementation is the decision of how many slots the table should have. I have followed the recommendations of Dave Hanson in his Book "C interfaces and Implementations"<a href="#tthFtNtAIA" name="tthFrefAIA"><sup>80</sup></a>, and I use a small table of primes to decide what size the table should have:
<br />

<div class="p"><!----></div>
<b>Init</b><a 
name="Init+code for \container43"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;Dictionary&nbsp;*Init(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elementsize,size_t&nbsp;hint)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i,allocSiz;
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;unsigned&nbsp;primes[]&nbsp;=&nbsp;{&nbsp;509,&nbsp;509,&nbsp;1021,&nbsp;2053,&nbsp;4093,&nbsp;8191,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16381,&nbsp;32771,&nbsp;65521,&nbsp;131071,&nbsp;0&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;1;&nbsp;primes[i]&nbsp;&lt;&nbsp;hint&nbsp;&amp;&amp;&nbsp;primes[i]&nbsp;&#62;&nbsp;0;&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;allocSiz&nbsp;=&nbsp;sizeof&nbsp;(Dictionary);
&nbsp;&nbsp;&nbsp;&nbsp;memset(Dict,0,allocSiz);
&nbsp;&nbsp;&nbsp;&nbsp;allocSiz&nbsp;=&nbsp;primes[i-1]*sizeof&nbsp;(Dict-&#62;buckets[0]);
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;buckets&nbsp;=&nbsp;CurrentAllocator-&#62;malloc(allocSiz);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict-&#62;buckets&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memset(Dict-&#62;buckets,0,allocSiz);
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;size&nbsp;=&nbsp;primes[i-1];
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;hash&nbsp;=&nbsp;hash;
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;VTable&nbsp;=&nbsp;&amp;iDictionary;
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;ElementSize&nbsp;=&nbsp;elementsize;
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;Allocator&nbsp;=&nbsp;CurrentAllocator;
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;RaiseError&nbsp;=&nbsp;iError.RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Dict;
}

</pre></font>
The primes in the table are the nearest primes to the regular powers of two. Table sizes can range from 509 to more than 130000, what gives a really 
wide range of table sizes. Obviously, bigger tables could be necessary, and other specialized implementations could use the <i>hint</i> parameter
to extend this algorithm or to use a completely different algorithm altogether.

<div class="p"><!----></div>
      <h4><a name="tth_sEc4.3.3">
4.3.3</a>&nbsp;&nbsp;Adding elements</h4>
This operation consists of:

<ul>
<li> hash the key to find a slot
<div class="p"><!----></div>
</li>

<li> go through the list at that slot to see if the key is already there
<div class="p"><!----></div>
</li>

<li> if key is already there replace
<div class="p"><!----></div>
</li>

<li> if key is absent add it in a new list item
<div class="p"><!----></div>
</li>
</ul>
<br />

<div class="p"><!----></div>
<b>Add</b><a 
name="Add+code for \container43"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Add(Dictionary&nbsp;*Dict,const&nbsp;unsigned&nbsp;char&nbsp;*Key,void&nbsp;*Value)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*tmp;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict&nbsp;==&nbsp;NULL)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NullPtrError("Add");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ReadOnlyError(Dict,"Add");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Key&nbsp;==&nbsp;NULL&nbsp;||&nbsp;Value&nbsp;==&nbsp;NULL)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BadArgError(Dict,"Add");
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;(*Dict-&#62;hash)(Key)&nbsp;%&nbsp;Dict-&#62;size;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(p&nbsp;=&nbsp;Dict-&#62;buckets[i];&nbsp;p;&nbsp;p&nbsp;=&nbsp;p-&#62;Next)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strcmp(Key,&nbsp;p-&#62;Key)&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;Dict-&#62;Allocator-&#62;malloc(sizeof(*p)+Dict-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;Dict-&#62;Allocator-&#62;malloc(1+strlen((char&nbsp;*)Key));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL&nbsp;||&nbsp;tmp&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p)&nbsp;Dict-&#62;Allocator-&#62;free(p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tmp)&nbsp;Dict-&#62;Allocator-&#62;free(tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NoMemoryError(Dict,"Add");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&#62;Value&nbsp;=&nbsp;(void&nbsp;*)(p+1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(tmp,Key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&#62;Key&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&#62;Next&nbsp;=&nbsp;Dict-&#62;buckets[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;buckets[i]&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;count++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memcpy((void&nbsp;*)p-&#62;Value,Value,Dict-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}

</pre></font>
Following the logical steps outlined above, we:

<ol type="1">
<li> Call the hash function and use its result modulo the size of the slot table to fetch the list at the indicated slot.
<div class="p"><!----></div>
</li>

<li> See if the key was absent. If that is the case, we need to add a new key. We copy the key and allocate memory for a new list element 
that is initialized afterwards with the copied value of the key and inserted into the list.
<div class="p"><!----></div>
</li>

<li> Copy in the value. If it was a new key, its value is initialized, if the key was already present we overwrite the old contents.
<div class="p"><!----></div>
</li>
</ol>
This function uses strcmp for comparing keys. This has the advantage of simplicity and speed, but in many other contexts a key comparison function 
would be necessary, to allow for keys in Unicode for instance, or for binary keys, for instance a GUID or similar binary data.

<div class="p"><!----></div>
An important design decision was to replace the data associated with a key if the key is already there. This is a decision that has consequences for 
all associative containers, since it must be coherent in all of them. Since the &#207;nsert" function allows for non-destructive insertions, Add was
allowed to replace contents since this is a very common operation for instance in some symbol tables, where &#207;nsert if absent or replace if present"
is used to ensure that a symbol is associated with a certain value. <a href="#tthFtNtAIB" name="tthFrefAIB"><sup>81</sup></a>. At the same time we need a <font size="+1"><tt>Replace</tt></font> function since we want to get an error if the element we want to replace was <b>not</b> found.
A small table makes this clearer

<div class="p"><!----></div>
 
<center>

<table border="1">
<tr><td align="left">Add </td><td align="left">Insert or replace an item for a key </td></tr>
<tr><td align="left">Insert </td><td align="left">Insert, error if the key was present </td></tr>
<tr><td align="left">Replace </td><td align="left">Replace, error if key was absent </td></tr></table>

</center>

<div class="p"><!----></div>
      <h4><a name="tth_sEc4.3.4">
4.3.4</a>&nbsp;&nbsp;Implementing iterators</h4>
Iterators in sequential containers are conceptually easy: just start at the first and stop at the last. In associative containers however things are 
more complicated since there is no obvious way to order them. The solution retained in the sample implementation involves going through all elements
starting at the first element of the slots table, and for each slot go through the linked list of items if any. This guarantees to visit all elements 
in a fixed order. As an example of this here is the <font size="+1"><tt>Apply</tt></font> function that should go through all elements calling the given function for each 
one of them.
<br />

<div class="p"><!----></div>
<b>Apply</b><a 
name="Apply+code for \container43"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Apply(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*apply)(const&nbsp;char&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Value,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;stamp;
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;*p;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NullPtrError("Apply");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(apply&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BadArgError(Dict,"Apply");
&nbsp;&nbsp;&nbsp;&nbsp;stamp&nbsp;=&nbsp;Dict-&#62;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;Dict-&#62;size;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(p&nbsp;=&nbsp;Dict-&#62;buckets[i];&nbsp;p;&nbsp;p&nbsp;=&nbsp;p-&#62;Next)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply(p-&#62;Key,p-&#62;Value,&nbsp;ExtraArgs);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict-&#62;timestamp&nbsp;!=&nbsp;stamp)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>

<div class="p"><!----></div>
As we outlined above, we start at slot zero, going upwards. If we find a non-empty slot, we go through the linked list of items.

<div class="p"><!----></div>
Iterators are implemented using the same algorithm, and need conceptually two indexes to remember their position: a first index for the slots table, 
and another for the position in the list of items at that slot.

<div class="p"><!----></div>
The implementation of the dictionary iterator is as follows:
<a 
name="iterator+Dictionary43"></a>

<font size=+1><pre>
struct&nbsp;DictionaryIterator&nbsp;{
&nbsp;&nbsp;&nbsp;Iterator&nbsp;it;
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;size_t&nbsp;index;
&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;*dl;
&nbsp;&nbsp;&nbsp;size_t&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;Flags;
};

</pre></font>
The <font size="+1"><tt>index</tt></font> field remembers the position in the slot table, and the <font size="+1"><tt>dl</tt></font> field is just a small structure that contains a link to the 
next item in the linked list and a pointer to the key. Storing the list element itself spare us the work of going through all the list to position ourselves at each advance of the cursor in the list.

     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;The bloom filter</h3>
This container is a completely different beast as all other ones we have in the library. It is a probabilistic data structure. It was conceived by
Mr Burton Howard Bloom in 1970 according to D. E Knuth in his Art of Computer Programming.

<div class="p"><!----></div>
Bloom filters are designed to cheaply test if a given element is in a large set. It is possible that the filter says that an element is there
when in fact, it is not. But if the filter says it is <i>not</i> there you can be certain that the element is not in the set.

<div class="p"><!----></div>
You can add elements to the set but not remove them. The more elements you add to the filter, the larger the possibility of getting false positives, i.e.
getting an answer of &#255;es, the element is there" when in fact it is not.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;Debugging malloc</h3>
<a name="Malloc">
</a>
The library provides a sample of how a malloc used for debugging allocation problems could look like. It is designed to be enhanced and even if it
has several important features like detection of double free and buffer overflows, it is not a competitor for the professional versions you can find
in the market like valgrind or similar.
<br />

<div class="p"><!----></div>
<b>Malloc</b><a 
name="Malloc+code for \container45"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;void&nbsp;*Malloc(size_t&nbsp;size)
{
&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;char&nbsp;*r;
&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;size_t&nbsp;*ip&nbsp;=&nbsp;NULL;

&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;ALIGN_DEFAULT(size);
&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;+=&nbsp;3&nbsp;*&nbsp;sizeof(size_t);
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;malloc(size);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;AllocatedMemory&nbsp;+=&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;(size_t&nbsp;*)&nbsp;r;
&nbsp;&nbsp;&nbsp;&nbsp;*ip++&nbsp;=&nbsp;SIGNATURE;
&nbsp;&nbsp;&nbsp;&nbsp;*ip++&nbsp;=&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;memset(ip,&nbsp;0,&nbsp;size&nbsp;-&nbsp;3*sizeof(size_t));
&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;(size_t&nbsp;*)&nbsp;(&amp;r[size&nbsp;-&nbsp;sizeof(size_t)]);
&nbsp;&nbsp;&nbsp;&nbsp;*ip&nbsp;=&nbsp;MAGIC;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(r&nbsp;+&nbsp;2&nbsp;*&nbsp;sizeof(size_t));
}

</pre></font>
The algorithm is as follows:

<ul>
<li> The given size will be aligned to a multiple of <font size="+1"><tt>size_t</tt></font>. It is assumed that this size is the size of a register, and will be 
good for any type of allocation. In some machines this may be completely wrong, for instance for some quantities the Intel processors need an
alignment of 16 bytes, and there is no implementation of <font size="+1"><tt>size_t</tt></font> with that size.
<div class="p"><!----></div>
</li>

<li> We reserve three words more than the requested size to store:

<ol type="1">
<li> The "magic number". This is just an integer that will enable us to ensure that we are dealing with a valid block. Blocks that have this number two 
words below the address passed to our <font size="+1"><tt>Free</tt></font> function will be assumed to be real blocks. There 
is of course a chance that the memory
could contain that number for other reasons, but choosing a value that can't be a pointer and that is high above 100 millions give us a fighting chance 
that the
probability of hitting a bad positive is fairly low.
<div class="p"><!----></div>
</li>

<li> The length of the block. This will allow us to verify that nothing was written beyond the required length of the block.
<div class="p"><!----></div>
</li>

<li> A guard at the end of the block. We will ensure that we can read this quantity when freeing the block.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li> We obtain memory using <font size="+1"><tt>malloc</tt></font>. If not available we just return &nbsp;NULL .
<div class="p"><!----></div>
</li>

<li> We keep a counter of all memory allocated so far. This counter should be zero at program exit. It helps to detect the leaks between two 
operations: it suffices to note the value of the counter before some part of the software and then see if the counter returns to the
same value after the module has finished.
<div class="p"><!----></div>
</li>

<li> We write the two different integers at the start and at the end of the block, together with its size.
<div class="p"><!----></div>
</li>

<li> We set to zero all memory even if the program didn't ask us. This ensures that any error that accesses uninitialized memory will 
always have the same consequences.
<div class="p"><!----></div>
</li>
</ul>
The other functions that complete this memory manager (free, realloc calloc) are not shown here (they are available in the source code 
of the library). They just undo what <font size="+1"><tt>Malloc</tt></font> has built, calling the error functions if they detect a problem.

<div class="p"><!----></div>
This simple system has several drawbacks.

<ul>
<li> If a buffer &#252;nderflow" happens, i.e. something is written to memory <i>before</i> the start of the block, our field "length" could be
wrong. Depending on the resulting contents of the length field after the overwrite we could have a bogus length and access some invalid memory.
<div class="p"><!----></div>
</li>

<li> Memory overwrites <i>after</i> the magic number that guards the end of the block are not detected. This is obviously impossible to detect
unless we would just inspect each memory write, but a few words more after the end of the block could give us some extra security.
<div class="p"><!----></div>
</li>
</ul>
For completeness here is the code of the free function for the debugging malloc sample:
<br />

<div class="p"><!----></div>
<b>Free</b><a 
name="Free+code for \container45"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;void&nbsp;Free(void&nbsp;*pp)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*ip&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;char&nbsp;*p&nbsp;=&nbsp;pp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;-=&nbsp;2&nbsp;*&nbsp;sizeof(size_t);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;(size_t&nbsp;*)&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*ip&nbsp;==&nbsp;SIGNATURE)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ip++&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;*ip;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;(size_t&nbsp;*)&nbsp;(&amp;p[s&nbsp;-&nbsp;sizeof(size_t)]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*ip&nbsp;!=&nbsp;MAGIC)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;overwritten&nbsp;block&nbsp;size&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("Free",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTAINER_ERROR_BUFFEROVERFLOW);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ip&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AllocatedMemory&nbsp;-=&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(p,66,s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Wrong&nbsp;block&nbsp;passed&nbsp;to&nbsp;Free&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("Free",CONTAINER_ERROR_BADPOINTER);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}

</pre></font>

<ul>
<li> Line 6:
If we receive a &nbsp;NULL argument is not an error (C99 standard).
<div class="p"><!----></div>
</li>

<li> Line 8:
We seek to the start of the real block and we point to it with a pointer to int (line 9).
<div class="p"><!----></div>
</li>

<li>
If we find the signature we erase the signature immediately (line 11). This avoids that
we ever process this block again. We get in line 12 the size of the block and we point
to the end of it. If we do not find our magic number it has been erased because our
block was somehow overwritten. We report that and stop any further processing.
<div class="p"><!----></div>
</li>

<li>
If we find our magic number all is OK and we free the block. We set it to zero before
to avoid that its data is used again (line 21).
<div class="p"><!----></div>
</li>

<li>
If we do not find the signature after we seek for it we do nothing but report an error:
the block has been overwritten or we have been handed a bogus pointer to our <font size="+1"><tt>free</tt></font>
function. Since our data is written before the start of the block, the software assumes
that it is a bad pointer since in most cases buffer overflows go beyond the end
of the block. It could be that it is actually a buffer overflow error however.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;The observer interface</h3>
This interface allows arbitrary functions to be called when some interesting event happens.
It supposes several actors that play together:

<ul>
<li> An object that wants to be notified when some event occurs. This object will be represented by
its callback function.
<div class="p"><!----></div>
</li>

<li> An object that emits events and necessary calls the interface to announce them.
<div class="p"><!----></div>
</li>

<li> An associative interface that associates objects with their corresponding
observer functions.
<div class="p"><!----></div>
</li>
</ul>
The observer interface has three entry points:

<ol type="1">
<li> Subscribe. This operation is started by an object that wants to be notified of events
happening in a specific container. It calls the associative interface to be notified
when those events occur.
<div class="p"><!----></div>
</li>

<li> Notify. The container sends events descriptions to the interface. The interface searches
the observer list and if an interested object exists, its associated function is called.
<div class="p"><!----></div>
</li>

<li> Unsubscribe Either the container is going out of scope or the object that receives
the notifications is going out of scope and wants to stop the process. The associative
interface is called to break the event stream. It can be that an either object is no
longer interested in receiving notifications for a specific container without any
change in scope: One of the objects desires to break the relationship.
<div class="p"><!----></div>
</li>
</ol>
The observer object then, is very simple:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_tagObserver&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ObservedObject;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;Callback;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;&nbsp;
}&nbsp;Observer;

</pre></font>
The association is between an observed object (the container) and another unspecified object represented by its
callback here. The flags contain in each bit an event code<a href="#tthFtNtAIC" name="tthFrefAIC"><sup>82</sup></a>. If an observer wants to subscribe to several events
it sets different bits in this field.

<div class="p"><!----></div>
Note that we do not characterize further the observed object: it is just a <font size="+1"><tt>void&nbsp;*</tt></font>. This is not
a great idea since the <font size="+1"><tt>InitObserver</tt></font> function assumes it is a generic container.

<div class="p"><!----></div>
We need a table of this objects because several containers could have several observers defined.

<font size=+1><pre>
static&nbsp;Observer&nbsp;*ObserverVector;
static&nbsp;size_t&nbsp;vsize;

</pre></font>
Now we can start describing the functions themselves
<br />

<div class="p"><!----></div>
<b>Subscribe</b><a 
name="Subscribe+code for \container46"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Subscribe(void&nbsp;*ObservedObject,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback,&nbsp;unsigned&nbsp;flags)
{
&nbsp;&nbsp;&nbsp;&nbsp;Observer&nbsp;result;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;InitObserver(&amp;result,ObservedObject,callback,flags);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;AddObject(&amp;result);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}

</pre></font>
We initialize an observer object, and if that succeeds we add it to the association tables.
We use temporary storage for the initialization because the &#196;ddObserver" function copies
the contents into the table<a href="#tthFtNtAID" name="tthFrefAID"><sup>83</sup></a>.
<br />

<div class="p"><!----></div>
<b>InitObserver</b><a 
name="InitObserver+code for \container46"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;InitObserver(Observer&nbsp;*result,void&nbsp;*ObservedObject,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback,&nbsp;unsigned&nbsp;flags)
{
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainer&nbsp;*gen&nbsp;=&nbsp;ObservedObject;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Subjectflags&nbsp;=&nbsp;gen-&#62;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;Subjectflags&nbsp;|=&nbsp;CONTAINER_HAS_OBSERVER;
&nbsp;&nbsp;&nbsp;&nbsp;gen-&#62;Flags=Subjectflags;
&nbsp;&nbsp;&nbsp;&nbsp;memset(result,0,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;ObservedObject&nbsp;=&nbsp;ObservedObject;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Callback&nbsp;=&nbsp;callback;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Flags&nbsp;=&nbsp;flags;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector&nbsp;==&nbsp;NULL&nbsp;&amp;&amp;&nbsp;initVector()&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function assumes that it receives a container that follows the requirements of generic containers,
i.e. it has a Get/Set flags field. It sets a bit in the flags field that is tested at each function
that modifies the number of elements within the container logic. This means in most machines a bit
test, a very fast operation that should not really affect the speed of the library code in a
significant way.

<div class="p"><!----></div>
A far more important consideration is that the interface is called with a notification for many
functions that the user hasn't subscribed at all. This could be speeded up simply by storing
the flags somewhere in the container, but the sample implementation doesn't go that far. The
reason is that it is assumed that observers are seldom used, and the objects that have an
observer defined are surely heavyweight objects where the slow down caused by the observer
interface is not that significant.

<div class="p"><!----></div>
Of course this assumptions could be very wrong: other, better implementations could decide
otherwise.
<br />

<div class="p"><!----></div>
<b>AddObject</b><a 
name="AddObject+code for \container46"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;&nbsp;AddObject(Observer&nbsp;*ob)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;Observer&nbsp;*tmp;

1:&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;vsize;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[i].ObservedObject==NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(ObserverVector+i,ob,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
2:&nbsp;&nbsp;tmp&nbsp;=&nbsp;realloc(ObserverVector,(vsize+CHUNK_SIZE)*sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tmp&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iObserver.Subscribe",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ObserverVector&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;memset(ObserverVector+vsize+1,0,(CHUNK_SIZE-1)*sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;memcpy(ObserverVector+vsize,ob,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;vsize+=&nbsp;CHUNK_SIZE;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
The AddObject function is responsible for inserting a new association in the existing table.
First (in <b>1:</b> above) it searches for a free slot. If a free slot is available
it copies the new association into it and returns.

<div class="p"><!----></div>
If there isn't any free slot it attempts to enlarge the table (<b>2:</b>). If an error occurs, the
original table is still valid but no more elements can't be added. It reports the error
and returns with the error code.

<div class="p"><!----></div>
Otherwise all went well, and a new element is inserted.
<br />

<div class="p"><!----></div>
<b>Notify</b><a 
name="Notify+code for \container46"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;int&nbsp;Notify(void&nbsp;*ObservedObject,unsigned&nbsp;operation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo1,void&nbsp;*ExtraInfo2)
{
&nbsp;&nbsp;&nbsp;int&nbsp;count=0;
&nbsp;&nbsp;&nbsp;size_t&nbsp;idx&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo[2];

&nbsp;&nbsp;&nbsp;ExtraInfo[0]&nbsp;=&nbsp;ExtraInfo1;
&nbsp;&nbsp;&nbsp;ExtraInfo[1]&nbsp;=&nbsp;ExtraInfo2;
&nbsp;&nbsp;&nbsp;for&nbsp;(idx=0;&nbsp;idx&nbsp;&lt;&nbsp;vsize;idx++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].ObservedObject&nbsp;==&nbsp;ObservedObject)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].Flags&nbsp;&amp;&nbsp;operation)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverVector[idx].Callback(ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation,ExtraInfo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return&nbsp;count;
}

</pre></font>
This is a simple linear search function. We search for an association that has the same
observed object and in the flags field has a bit set that indicates that is interested in this operation.
If both conditions are true we call the registered function.
<br />

<div class="p"><!----></div>
<b>Unsubscribe</b><a 
name="Unsubscribe+code for \container46"></a> <hr />



<font size=+1><pre>[numbers=left,&nbsp;xleftmargin=7mm]
static&nbsp;size_t&nbsp;Unsubscribe(void&nbsp;*ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx,count=0;

1:&nbsp;&nbsp;if&nbsp;(ObservedObject&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(callback&nbsp;==&nbsp;NULL)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(idx=0;&nbsp;idx&lt;vsize;idx++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].Callback&nbsp;==&nbsp;callback)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(ObserverVector+idx,0,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;}
2:&nbsp;&nbsp;if&nbsp;(callback&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(idx=0;idx&lt;vsize;idx++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].ObservedObject&nbsp;==&nbsp;ObservedObject)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(ObserverVector+idx,0,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;}
3:&nbsp;&nbsp;for&nbsp;(idx=0;&nbsp;idx&lt;vsize;idx++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].ObservedObject&nbsp;==&nbsp;ObservedObject&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverVector[idx].Callback&nbsp;==&nbsp;callback)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(ObserverVector+idx,0,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;
}

</pre></font>
Unsubscribe should handle three different situations:

<ul>
<li>The observer object wishes to stop observing. This case is represented by a &nbsp;NULL <font size="+1"><tt>ObservedObject</tt></font> argument meaning that all
observed objects for this callback should be affected. This is handled in the code marked <b>1:</b> above.
<div class="p"><!----></div>
</li>

<li> The observed object (the container) wishes to stop being observed. This case is represented by a &nbsp;NULL <font size="+1"><tt>callback</tt></font> argument, meaning that
all callbacks are affected. This is handled in the code marked <b>2:</b> above.
<div class="p"><!----></div>
</li>

<li> Only a single relationship should be stopped between a single object and a single callback. This is handled in the code marked <b>3:</b> above.
<div class="p"><!----></div>
</li>
</ul>
To erase an item we just set it to zero, supposing that the next time an object subscribes the empty slot will be found and used.
Obviously this method could waste some space in case we ever do only a single relationship in the whole program. The number of slots
that is reserved in the sample implementation is small, to avoid wasting memory in case there are few  observers. More sophisticated
implementations can add features here.

     <h3><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;ValArrays</h3>
<a 
name="ValArrays,code47"></a>
All ValArrays are implemented using a template file that receives its parameters from a small c file. The same is done for the header files, that
are also controlled by a header file. Since header files do not contain any definitions, only declarations, the different headers are grouped into
a single header file that includes the templated file several times. Here is an excerpt of valarray.h:

<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;/**********************************************&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;2&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValArraySize_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;3&nbsp;&nbsp;*************************************************/&nbsp;
&nbsp;&nbsp;4&nbsp;#undef&nbsp;ElementType
&nbsp;&nbsp;5&nbsp;#undef&nbsp;ValArrayInterface
&nbsp;&nbsp;6&nbsp;#undef&nbsp;ElementType
&nbsp;&nbsp;7&nbsp;#undef&nbsp;ValArray
&nbsp;&nbsp;9&nbsp;#undef&nbsp;_ValArray
&nbsp;10&nbsp;#define&nbsp;ValArray&nbsp;ValArraySize_t
&nbsp;11&nbsp;#define&nbsp;ElementType&nbsp;size_t
&nbsp;12&nbsp;#define&nbsp;ValArrayInterface&nbsp;ValArraySize_tInterface
&nbsp;13&nbsp;#define&nbsp;__IS_UNSIGNED__
&nbsp;14&nbsp;#define&nbsp;__IS_INTEGER__
&nbsp;15&nbsp;#include&nbsp;"valarraygen.h"
&nbsp;16&nbsp;#undef&nbsp;__IS_UNSIGNED__
&nbsp;17&nbsp;#undef&nbsp;__IS_INTEGER__
&nbsp;18&nbsp;extern&nbsp;ValArraySize_tInterface&nbsp;iValArraySize_t;
&nbsp;

</pre></font>
Lines 4-9 remove a possible previous definition of the parameters we are going to use for valarraygen.h. Then we start defining the parameters:

<ul>
<li> <font size="+1"><tt>_ValArray</tt></font> is <font size="+1"><tt>ValArraySize_t</tt></font> (line 10)
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>ElementType</tt></font> parameter is the actual type of the elements to be stored into each ValArray.
<div class="p"><!----></div>
</li>

<li> Lines 13 and 14 define symbols used to test for certain attributes within valarraygen.h. Some functions are defined in types that 
correspond to those attributes and omitted in the types where they are not. The attributes defined are:

<ul>
<li> Unsigned. This encloses all unsigned types. In these types bitwise operations are legal.
<div class="p"><!----></div>
</li>

<li> Integer. This encloses all integer types. The <font size="+1"><tt>mod</tt></font> operation is defined for these types.
<div class="p"><!----></div>
</li>

<li> Not Integer implies float. Operations like <font size="+1"><tt>fcmp</tt></font> are defined only for floats.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> All parameters defined, we can include the valarraygen.h file. This file uses the defines above to define the interface data structure.
<div class="p"><!----></div>
</li>

<li> The really end user visible name is at line 19: the name of the interface.
<div class="p"><!----></div>
</li>
</ul>
The valarraygen.h (gen for <b>gen</b>eric) defines the interfaces for all the parameter types.
Here is a small part of it so that you get the idea:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_ValArray&nbsp;ValArray;
typedef&nbsp;struct&nbsp;tagValArray&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(ValArray&nbsp;*AL,ElementType&nbsp;data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(ValArray&nbsp;*AL,ElementType&nbsp;elem);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;snip
}&nbsp;ValArrayInterface;

</pre></font>
In a very similar way, the generic ValArray containers for all basic types are organized in a small parameter file "valarrayint.c", "valarraydouble.c"
and others that make the necessary defines so that the underlying valarraygen.c defines a function for each required basic type.
Programming in valarraygen.c is fairly simple. Here is a function that is parametrized by the <font size="+1"><tt>ElementType</tt></font> macro:

<font size=+1><pre>
static&nbsp;ElementType&nbsp;GetElement(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;idx)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;start=0,incr=1,top=AL-&#62;count;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Slice)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;AL-&#62;Slice-&#62;start;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;=&nbsp;AL-&#62;Slice-&#62;increment;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;=&nbsp;AL-&#62;Slice-&#62;length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;=top&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexError("GetElement");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;MinElementType;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;start+idx*incr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AL-&#62;contents[idx];
}

</pre></font>
We see here:

<ul>
<li> Slice management. All operations in a ValArray are constrained by the current slice, that starts with a slice that encloses the whole array 
(the start is zero, the increment is one, and the length of the slice is the length of the array). When a slice is defined for an array, it will be
used, if not, an implicit slice is used that includes the whole array.
<div class="p"><!----></div>
</li>

<li> Error analysis is simplified for ValArrays, and no &nbsp;NULL checking is done. However hard errors like an index error (trying to index an array beyond
its bounds) are always reported.
<div class="p"><!----></div>
</li>

<li> Contrary to the <font size="+1"><tt>GetElement</tt></font> function in the <font size="+1"><tt>vector</tt></font> container we do not return a pointer to the element but the element
itself. For the basic types this can always be done and is very efficient. For more complex types use <font size="+1"><tt>vector</tt></font> instead of <font size="+1"><tt>ValArray</tt></font>.
<div class="p"><!----></div>
</li>
</ul>
The <font size="+1"><tt>valarraygen.c</tt></font> file can be used to provide for an array of actually <b>any</b> data structure that is small enough to be returned by value.
It suffices to change the <font size="+1"><tt>ElementType</tt></font> to the concerned structure whose definition must be visible to the compiler. In the next chapter we see how this
could be done.

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Building the documentation</h2>
The documentation is written in the <span class="roman">L</span><sup><span class="roman">A</span></sup><span class="roman">T</span><sub><span class="roman">E</span></sub><span class="roman">X</span>markup language. This is an ancient and quite outmoded software written by a certain D. Knuth dozens of
years ago, and as many outmoded and ancient things, it works perfectly in an incredible number of environments and machines, just like the C language.
It produces high quality documents that look the same independently of the environment or machine where they are produced.
Obtaining a version of <span class="roman">T</span><sub><span class="roman">E</span></sub><span class="roman">X</span>and <span class="roman">L</span><sup><span class="roman">A</span></sup><span class="roman">T</span><sub><span class="roman">E</span></sub><span class="roman">X</span>is very easy and it is the reason it has been useful here <a href="#tthFtNtAIE" name="tthFrefAIE"><sup>84</sup></a>
.

<div class="p"><!----></div>
The documentation is stored in a sub-directory of the main sources directory of the sample implementation called <font size="+1"><tt>ccldoc</tt></font>. You will find there
two types of files:


<ul>
<li> <font size="+1"><tt>.png</tt></font> files containing drawings.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>.tex</tt></font> files containing the tex source of the documentation.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>.c</tt></font> files that build auxiliary executables.

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
The main source of the documentation is the <font size="+1"><tt>ccl.tex</tt></font> file. This file includes the <font size="+1"><tt>Introduction.tex</tt></font> tex source file, and all the drawings
and tables.

<div class="p"><!----></div>
All other <font size="+1"><tt>.tex</tt></font> files are <i>generated</i> files that are produced by the <font size="+1"><tt>dotable</tt></font> executable compiled from the <font size="+1"><tt>dotable.c</tt></font>
source file
<a href="#tthFtNtAIF" name="tthFrefAIF"><sup>85</sup></a>. The <font size="+1"><tt>dotable.c</tt></font> source file reads the source code of the library and extracts information about the interfaces, information that
is used to generate the different interface files (<font size="+1"><tt>list.tex</tt></font>, <font size="+1"><tt>vector.tex</tt></font>, etc) and the table of functions at the end of the
documentation. The interfaces are sorted in alphabetical order, then written to disk. For historical reasons, the interfaces are not written in
alphabetical order in the <font size="+1"><tt>ccl.h</tt></font> source file.
<a href="#tthFtNtAIG" name="tthFrefAIG"><sup>86</sup></a>.

<div class="p"><!----></div>
The Makefile builds also the <font size="+1"><tt>ccl.html</tt></font> file, that contains the same text of the documentation but in a form suitable to be displayed by any
web browser. This task is done by the <font size="+1"><tt>tth</tt></font> program that is built from the <font size="+1"><tt>tth.c</tt></font> source file, an adaptation of the program written by
Ian Hutchinson<a href="#tthFtNtAIH" name="tthFrefAIH"><sup>87</sup></a>.

 <h1><a name="tth_chAp10">
Chapter 10 </a><br />Building generic components</h1>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Pre processing a generic file</h2>
If you take the source code of a container like &#228;rraylist", for instance, you will notice that all those "void *&#228;re actually a single type, i.e. the type of the objects being stored in the container.  All generic containers use "void *" as the type under which the objects are stored so that the same code works with many different types.

<div class="p"><!----></div>
Obviously another way is possible. You could actually replace the object type within that code and build a family of functions and types that can be specialized by its type parameter. For instance:

<font size=+1><pre>
struct&nbsp;tag$(TYPE)ArrayInterface;
typedef&nbsp;struct&nbsp;_$(TYPE)Array&nbsp;{
&nbsp;&nbsp;&nbsp;struct&nbsp;tag$(TYPE)ArrayInterface&nbsp;*VTable;&nbsp;
&nbsp;&nbsp;&nbsp;size_t&nbsp;count;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;
&nbsp;&nbsp;&nbsp;$(TYPE)&nbsp;*contents;
&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;
&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;CompareFn;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
}&nbsp;$(TYPE)_Array&nbsp;;

</pre></font>
Now, if we just substitute <b> <font size="+1"><tt>$(TYPE)</tt></font></b> with <b>"double"</b> in the code above, we obtain:

<div class="p"><!----></div>

<font size=+1><pre>
struct&nbsp;tagdoubleArrayInterface;
typedef&nbsp;struct&nbsp;_doubleArray&nbsp;{
&nbsp;&nbsp;&nbsp;struct&nbsp;tagdoubleArrayInterface&nbsp;*VTable;&nbsp;
&nbsp;&nbsp;&nbsp;size_t&nbsp;count;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;
&nbsp;&nbsp;&nbsp;double&nbsp;*contents;
&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;
&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;CompareFn;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
}&nbsp;double_Array&nbsp;;

</pre></font>

<div class="p"><!----></div>
We use the name of the parameter to build a family of names, and we use the name of the type parameter to declare an array of elements of that specific type as the contents of the array. This double usage allows us to build different name spaces for each different array type, so that we can declare arrays of different types without problems.

<div class="p"><!----></div>
Using the same pattern, we can build a family of functions for this container that is specialized to a concrete type of element. For instance we can write:

<div class="p"><!----></div>

<font size=+1><pre>
static&nbsp;int&nbsp;EraseAt($(TYPE)_Array&nbsp;*AL,size_t&nbsp;idx)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(TYPE)&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;=&nbsp;AL-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INDEX;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Flags&nbsp;&amp;&nbsp;AL_READONLY)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;AL-&#62;contents+idx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&lt;&nbsp;(AL-&#62;count-1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove(p,p+1,(AL-&#62;count-idx)*sizeof($(TYPE)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;count--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AL-&#62;count;
}

</pre></font>

<div class="p"><!----></div>
when transformed, the function above becomes:

<div class="p"><!----></div>

<font size=+1><pre>
static&nbsp;int&nbsp;EraseAt(double_Array&nbsp;*AL,size_t&nbsp;idx)
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;=&nbsp;AL-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INDEX;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Flags&nbsp;&amp;&nbsp;AL_READONLY)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-2;
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;AL-&#62;contents+idx;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&lt;&nbsp;(AL-&#62;count-1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove(p,p+1,(AL-&#62;count-idx)*sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;count--;
&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AL-&#62;count;
}

</pre></font>

<div class="p"><!----></div>
Now we can build a simple program in C that will do the substitution work for us. To make things easier, that program should build two files:

<ul>
<li> The header file, that will contain the type definitions for our array.
<div class="p"><!----></div>
</li>

<li> The C source file, containing all the parametrized function definitions.
<div class="p"><!----></div>
</li>
</ul>
We separate the commands to change the name of the file from the rest of the text by introducing in the first positions of a line a sequence of three or more @ signs.  Normally we will have two of those "commands": one for the header file, another for the c file.

<div class="p"><!----></div>
Besides that, our program is just a plain text substitution. No parsing, nor anything else is required. If we write <font size="+1"><tt>"$(TYPE)"</tt></font> within a comment or a character string, it will be changed too.

<font size=+1><pre>
#include&nbsp;&lt;stdlib.h&#62;
#include&nbsp;&lt;string.h&#62;
#include&nbsp;&lt;stdio.h&#62;

#define&nbsp;MAXLINE_LEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2048
#define&nbsp;MAX_FNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1024
#define&nbsp;EXPANSION_LENGTH&nbsp;256

int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;FILE&nbsp;*input,*output=NULL;
&nbsp;&nbsp;&nbsp;char&nbsp;buf[MAXLINE_LEN],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpLine[MAXLINE_LEN+EXPANSION_LENGTH];
&nbsp;&nbsp;&nbsp;char&nbsp;tmpBuf[MAX_FNAME];
&nbsp;&nbsp;&nbsp;char&nbsp;outputFile[MAX_FNAME];
&nbsp;&nbsp;&nbsp;char&nbsp;*TypeDefinition;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;lineno&nbsp;=&nbsp;1;

&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;3)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Usage:&nbsp;%s&nbsp;&lt;template&nbsp;file&nbsp;to&nbsp;expand&#62;&nbsp;&lt;type&nbsp;name&#62;\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EXIT_FAILURE;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;input&nbsp;=&nbsp;fopen(argv[1],"r");
&nbsp;&nbsp;&nbsp;if&nbsp;(input&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Unable&nbsp;to&nbsp;open&nbsp;file&nbsp;'%s'\n",argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EXIT_FAILURE;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;TypeDefinition&nbsp;=&nbsp;argv[2];
&nbsp;&nbsp;&nbsp;while&nbsp;(fgets(buf,sizeof(buf)-1,input))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[0]=='@'&nbsp;&amp;&amp;&nbsp;buf[1]&nbsp;==&nbsp;'@'&nbsp;&amp;&amp;&nbsp;buf[2]&nbsp;==&nbsp;'@')&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i=0,j=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(buf[i]&nbsp;&nbsp;==&nbsp;'@')
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(buf[i]&nbsp;!=&nbsp;0&nbsp;&amp;&amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[i]&nbsp;!=&nbsp;'\n'&nbsp;&amp;&amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;&nbsp;MAX_FNAME-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpBuf[j++]&nbsp;=&nbsp;buf[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpBuf[j]&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strrepl(tmpBuf,"$(TYPE)",TypeDefinition,NULL))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"File&nbsp;name&nbsp;'%s'&nbsp;too&nbsp;long\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpBuf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EXIT_FAILURE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strrepl(tmpBuf,"$(TYPE)",TypeDefinition,outputFile);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output&nbsp;!=&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(output);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;=&nbsp;fopen(outputFile,"w");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Impossible&nbsp;to&nbsp;open&nbsp;'%s'\n",outputFile);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(EXIT_FAILURE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(lineno&nbsp;==&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Error:&nbsp;First&nbsp;line&nbsp;should&nbsp;contain&nbsp;the&nbsp;file&nbsp;name\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Normal&nbsp;lines&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strrepl(buf,"$(TYPE)",TypeDefinition,NULL)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#62;=&nbsp;sizeof(tmpLine))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Line&nbsp;buffer&nbsp;overflow&nbsp;line&nbsp;%d\n",lineno);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strrepl(buf,"$(TYPE)",TypeDefinition,tmpLine);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fwrite(tmpLine,1,strlen(tmpLine),output);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lineno++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(input);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(output);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EXIT_SUCCESS;
}

</pre></font>
The heart of this program is the &#223;trrepl" function that replaces a given character string in a piece of text. If you call it with a &nbsp;NULL output parameter, it will return the number of characters that the replacement would need if any. For completeness, here is the code for strrepl:

<font size=+1><pre>
int&nbsp;strrepl(const&nbsp;char&nbsp;*InputString,&nbsp;const&nbsp;char&nbsp;*StringToFind,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*StringToReplace,&nbsp;char&nbsp;*output)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*offset&nbsp;=&nbsp;NULL,&nbsp;*CurrentPointer&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;insertlen;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;findlen&nbsp;=&nbsp;strlen(StringToFind);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;0;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(StringToReplace)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertlen&nbsp;=&nbsp;strlen(StringToReplace);
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertlen&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output&nbsp;!=&nbsp;InputString)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove(output,InputString,strlen(InputString)+1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputString&nbsp;=&nbsp;output;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;strlen(InputString)+1;

&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*InputString)&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;offset&nbsp;=&nbsp;strstr&nbsp;(!offset&nbsp;?&nbsp;InputString&nbsp;:&nbsp;CurrentPointer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringToFind);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(offset&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CurrentPointer&nbsp;=&nbsp;(offset&nbsp;+&nbsp;(output&nbsp;?&nbsp;insertlen&nbsp;:&nbsp;findlen));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy&nbsp;(offset,&nbsp;(offset&nbsp;+&nbsp;findlen));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove&nbsp;(offset&nbsp;+&nbsp;insertlen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset,&nbsp;strlen&nbsp;(offset)&nbsp;+&nbsp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(insertlen)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy&nbsp;(offset,&nbsp;StringToReplace,&nbsp;insertlen);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;-=&nbsp;findlen;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;insertlen;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>

<div class="p"><!----></div>
And now we are done. The usage of this program is very simple:
 
<font size=+1><pre>
&nbsp;&nbsp;&nbsp;expand&nbsp;&lt;template&nbsp;file&#62;&nbsp;&lt;type&nbsp;name&#62;

</pre></font>

<div class="p"><!----></div>
For instance to substitute by "double" in the template file &#228;rraylist.tpl" we would use:

<div class="p"><!----></div>

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;expand&nbsp;arraylist.tpl&nbsp;double

</pre></font>

<div class="p"><!----></div>
We would obtain doublearray.h and doublearray.c

<div class="p"><!----></div>
BUG: Obviously, this supposes that the type name does NOT contain  any spaces or other characters like '*' or "[  ]". If you want to use types with 
those characters you should substitute them with a "_" for instance, and make a typedef:

<div class="p"><!----></div>
<font size="+1"><tt>typedef long double long_double;</tt></font>

<div class="p"><!----></div>
And use that type ("long_double") as the substitution type.

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Using the pre-processor</h2>
Instead of using a separate program we can try to use the pre-processor to make the grunt of the editing work. This is the path taken by the
sample implementation. We will describe here the <font size="+1"><tt>listgen.c</tt></font> and <font size="+1"><tt>listgen.h</tt></font> files that implement a type-generic list container.

<div class="p"><!----></div>
Each type needs two files:

<ol type="1">
<li> A header file where the data structures are declared. The name of this file is composed from the name of the type and the name of the
container. For instance for a double linked list of integers we would have: <font size="+1"><tt>intdlist.h</tt></font>.
<div class="p"><!----></div>
</li>

<li> An implementation file where the code for the data type resides. The name is the same as the header file but with a <font size="+1"><tt>.c</tt></font> extension
<a href="#tthFtNtAII" name="tthFrefAII"><sup>88</sup></a>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
In the sample implementation the different files (<font size="+1"><tt>intlist.h</tt></font>, <font size="+1"><tt>doublelist.h</tt></font>, etc) are very small files that mainly define a single macro, 
including afterwards a generic file with the bulk of the code. For instance here is the <font size="+1"><tt>intlist.h</tt></font> file:

<font size=+1><pre>
#include&nbsp;"containers.h"
#undef&nbsp;DATA_TYPE
#define&nbsp;DATA_TYPE&nbsp;int&nbsp;//&nbsp;The&nbsp;name&nbsp;of&nbsp;the&nbsp;type
#include&nbsp;"listgen.h"&nbsp;&nbsp;//&nbsp;The&nbsp;generic&nbsp;header&nbsp;file
#undef&nbsp;DATA_TYPE
#undef&nbsp;LIST_TYPE
#undef&nbsp;LIST_TYPE_
#undef&nbsp;INTERFACE
#undef&nbsp;ITERATOR
#undef&nbsp;ITERFACE_NAME
#undef&nbsp;LIST_ELEMENT
#undef&nbsp;LIST_ELEMENT_

</pre></font>
The <font size="+1"><tt>#undef</tt></font> statements allow to include several files of the same type in a source file.

      <h4><a name="tth_sEc2.0.1">
2.0.1</a>&nbsp;&nbsp;The generic header file</h4>
The generic list file above (<font size="+1"><tt>listgen.h</tt></font>) has the following tasks:

<ol type="1">
<li> Define the container data type: <font size="+1"><tt>[type][container]</tt></font> in this case <font size="+1"><tt>intList</tt></font>. Since we are defining a list, we define a list element 
component:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;LIST_ELEMENT&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;LIST_ELEMENT&nbsp;*Next;
&nbsp;&nbsp;&nbsp;&nbsp;DATA_TYPE&nbsp;Data;
}&nbsp;LIST_ELEMENT;

</pre></font>
This will be expanded by the pre processor to:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;intListElement&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;intListElement&nbsp;*Next;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Data;
}&nbsp;intListElement;

</pre></font>
<div class="p"><!----></div>
</li>

<li> Define the interface structure (the function table) using generic notation:

<font size=+1><pre>
struct&nbsp;INTERFACE_STRUCT_INTERNAL_NAME(DATA_TYPE)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;LIST_TYPE&nbsp;*L);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;LIST_TYPE&nbsp;*L);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(LIST_TYPE&nbsp;*L,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;LIST_TYPE&nbsp;*L,const&nbsp;DATA_TYPE&nbsp;element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(LIST_TYPE&nbsp;*L,const&nbsp;DATA_TYPE);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(LIST_TYPE&nbsp;*l,const&nbsp;DATA_TYPE);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...
};

</pre></font>
This will be translated into:

<font size=+1><pre>
struct&nbsp;__intListInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;intList&nbsp;*L);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;intList&nbsp;*L);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(intList&nbsp;*L,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(intList&nbsp;*L);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;intList&nbsp;*L,const&nbsp;int&nbsp;element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(intList&nbsp;*L,const&nbsp;int);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(intList&nbsp;*l,const&nbsp;int);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...
};

</pre></font>
<div class="p"><!----></div>
</li>
</ol>

      <h4><a name="tth_sEc2.0.2">
2.0.2</a>&nbsp;&nbsp;The implementation file</h4>
There are two possibilities: 


<ul>
<li> Replicate all code of the container. This has the advantage of sparing an extra call instruction at run time and making possible use of
specialized code tailored to the specific data type being compiled.
<div class="p"><!----></div>
</li>

<li> Make a thin translation layer to reuse the code of the container. This has the advantage of minimizing the source code, making bug fixing
easier since the bugs will be fixed in only one place and not in many different specializations. 

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
This first edition of the sample implementation has chosen the second strategy since the code is new, and probably a lot of changes will be necessary
before it stabilizes. In general we have three types of functions:


<ul>
<li> Functions where the signature has changed: instead of working with a <font size="+1"><tt>void&nbsp;*</tt></font> they receive the concrete data type of the container specialization. This allows for compile time checking of arguments, what is a very good improvement over the generic <font size="+1"><tt>void&nbsp;*</tt></font> functions.
An example of those functions looks like this:

<font size=+1><pre>
static&nbsp;int&nbsp;Add(LIST_TYPE&nbsp;*&nbsp;l,&nbsp;const&nbsp;DATA_TYPE&nbsp;elem)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;iList.Add((List&nbsp;*)l,&amp;elem);
}

</pre></font>
<div class="p"><!----></div>
</li>

<li> Functions that have the same signature and are replaced by the equivalent functions of the generic container at the creation of the new
container.
<div class="p"><!----></div>
</li>

<li> Functions that for performance reasons are rewritten in a generic way, i.e. their body is present in the specialized container. An example
is the quick sort function, that receives an expression parameter in the form of a compile time macro that is expanded in the body of the
function. This enables a big performance boost: Instead of the sorting function calling a function that does a <font size="+1"><tt>memcmp</tt></font> of the data, the
comparison expression is used, avoiding two function calls of overhead at each comparison.

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
The implementation file receives several other optional parameters.
<a 
name="COMPARE\_EXPRESSION20"></a> 

<font size=+1><pre>
#define&nbsp;COMPARE_EXPRESSION(a,&nbsp;b)&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((*b)-&#62;Data&nbsp;&#62;&nbsp;(*a)-&#62;Data&nbsp;?&nbsp;-1&nbsp;:&nbsp;(*b)-&#62;Data&nbsp;!=&nbsp;(*a)-&#62;Data)

</pre></font>

<div class="p"><!----></div>
This expression is used to return -1 for a  &lt;  b, zero for equality and 1 for a  &gt;  b<a href="#tthFtNtAIJ" name="tthFrefAIJ"><sup>89</sup></a>. 
<BR CLEAR=LEFT><BR><BR>


<center>

 <h1><a name="tth_chAp11">
Chapter 11 </a><br />API Overview</h1>
</center>

<br />
<a 
name="API Overview00"></a>

<div class="p"><!----></div>
Here is a table of all functions of the library. It indicates which functions are implemented in each container. Some containers are fused 
together since they implement exactly the same functions: all the <font size="+1"><tt>ValArray</tt></font> containers are displayed in a single column, the containers 
<font size="+1"><tt>StringList</tt></font> and <font size="+1"><tt>wStringList</tt></font> share the same column also.



<font size="-3">


<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table border="1">
<tr><td width="118"><font size="-4"><b>Function</b></font>  </td><td align="center"><font size="-4"><b>List</b></font> </td><td align="center"><font size="-4"><b>Dlist</b></font> </td><td align="center"><font size="-4"><b>Vector</b></font> </td><td align="center"><font size="-4"><b>Val</b></font> </td><td align="center"><font size="-4"><b>Bit-</b></font> </td><td align="center"><font size="-4"><b>String</b></font> </td><td align="center"><font size="-4"><b>Queue</b></font> </td><td align="center"><font size="-4"><b>Deque</b></font> </td><td align="center"><font size="-4"><b>Dict.</b></font> </td><td align="center"><font size="-4"><b>Hash</b></font> </td><td align="center"><font size="-4"><b>Tree</b></font> </td><td align="center"><font size="-4"><b>Priority</b></font> </td><td align="center"><font size="-4"><b>Stream</b></font> 
</td></tr>
<tr><td width="118"><font size="-4"><b>Name</b></font></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"><font size="-4"><b>array</b></font> </td><td align="center"><font size="-4"><b>string</b></font> </td><td align="center"><font size="-4"><b>collection</b></font> </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"><font size="-4"><b>table</b></font> </td><td align="center"><font size="-4"><b>map</b></font> </td><td align="center"><font size="-4"><b>queue</b></font> </td><td align="center"><font size="-4"><b>buffer</b></font>
</td></tr>
<tr><td width="118"></td></tr>
<tr><td></td></tr>
<tr><td width="118">

<div class="p"><!----></div>
Abs                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Accumulate          	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Add                 	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">AddRange            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">And                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">AndAssign           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">AndScalar           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Append              	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Apply               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Back                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">BitBlockCount       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">BitLeftShift        	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">BitRightShift       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">CastToArray         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Clear               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td width="118">Compare             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">CompareEqual        	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">CompareEqualScalar  	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">CompareScalar       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Contains            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Copy                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">CopyBits            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">CopyElement         	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">CopyTo              	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Create              	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td width="118">CreateFromFile      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">CreateSequence      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">CreateWithAllocator 	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td width="118">Dequeue             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">DivideBy            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">DivideByScalar      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">DivideScalarBy      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Enqueue             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Equal               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">Erase               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">EraseAll            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">EraseAt             	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">EraseRange          	</td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">FCompare            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">FillSequential      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Finalize            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td width="118">Find                	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">FindFirst           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">FindNext            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">FindText            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">FindTextIndex       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">FindTextPositions   	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">FirstElement        	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">ForEach             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Fprintf             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Front               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">GetAllocator        	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetCapacity         	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetData             	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">GetElement          	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetElementSize      	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetFlags            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetHeap             	</td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetKeys             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetLoadFactor       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetPosition         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">GetRange            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">GetSlice            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">IndexIn             	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">IndexOf             	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Init                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">InitIterator        	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">InitWithAllocator   	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">InitializeWith      	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Insert              	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">InsertAt            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">InsertIn            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Inverse             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">LastElement         	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">LessEqual           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Load                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Max                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Memset              	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Min                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Mismatch            	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Mod                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">ModScalar           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">MultiplyWith        	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">MultiplyWithScalar  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">NewIterator         	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Not                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">NotAssign           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Or                  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">OrAssign            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">OrScalar            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Pop                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">PopBack             	</td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">PopFront            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">PopulationCount     	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Print               	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Product             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Push                	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">PushBack            	</td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">PushFront           	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Read                	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">ReadFromFile        	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">RemoveRange         	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Replace             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">ReplaceAt           	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Reserve             	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">ResetSlice          	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Resize              	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">Reverse             	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">RotateLeft          	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">RotateRight         	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Save                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Search              	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SearchWithKey       	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Select              	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SelectCopy          	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetCapacity         	</td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetCompareFunction  	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetDestructor       	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetElement          	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetElementData      	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetErrorFunction    	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetFlags            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetHashFunction     	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SetPosition         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">SetSlice            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Size                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td width="118">Sizeof              	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">SizeofIterator      	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Sort                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Splice              	</td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SplitAfter          	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">StringToBitString   	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SubtractFrom        	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SubtractFromScalar  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">SubtractScalarFrom  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SumScalarTo         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">SumTo               	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Union               	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td></tr>
<tr><td width="118">UseHeap             	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Write               	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">WriteToFile         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td width="118">Xor                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">XorAssign           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">XorScalar           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">Totals              	</td><td align="center">56</td><td align="center">57</td><td align="center">60</td><td align="center">94</td><td align="center">56</td><td align="center">66</td><td align="center">11</td><td align="center">28</td><td align="center">35</td><td align="center">26</td><td align="center">28</td><td align="center">14</td><td align="center">15</td></tr>
<tr><td width="118">Total APIs          	</td><td align="center">546 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td width="118">

<div class="p"><!----></div>
</tr><tr><td></td></tr></table>
</center>
<div class="p"><!----></div>
</font><a name="tth_sEcindex"></a>

<h2> Index (showing section)</h2>

<table width="100%"><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Abs</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Abs+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Accumulate</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Accumulate+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Add</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Add+\container11">1.1</a>, 
		<a href="#Add+\container32">3.2</a>, 
		<a href="#Add+\container42">4.2</a>, 
		<a href="#Add+\container62">6.2</a>, 
		<a href="#Add+\container82">8.2</a>, 
		<a href="#Add+\container113">11.3</a>, 
		<a href="#Add+\container122">12.2</a>, 
		<a href="#Add+\container143">14.3</a>, 
		<a href="#Add+\container152">15.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Add+code for \container41">4.1</a>, 
		<a href="#Add+code for \container43">4.3</a></dd>
 <dt><b></b></dt>
	<dd>AddError</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#AddError+\container40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>AddObject</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#AddObject+code for \container46">4.6</a></dd>
 <dt><b></b></dt>
	<dd>AddRange</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#AddRange+\container11">1.1</a>, 
		<a href="#AddRange+\container32">3.2</a>, 
		<a href="#AddRange+\container52">5.2</a>, 
		<a href="#AddRange+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#AddRange+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Advance</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Advance+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>Alloc</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Alloc+\container30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>Allocator, <a href="#Allocator160">16.0</a></dd>
 <dt><b></b></dt>
	<dd>And</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#And+\container12">1.2</a>, 
		<a href="#And+\container42">4.2</a>, 
		<a href="#And+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>AndAssign</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#AndAssign+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>API Overview, <a href="#API Overview00">0.0</a></dd>
 <dt><b></b></dt>
	<dd>Append</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Append+\container11">1.1</a>, 
		<a href="#Append+\container32">3.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Append+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Apply</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Apply+\container11">1.1</a>, 
		<a href="#Apply+\container32">3.2</a>, 
		<a href="#Apply+\container62">6.2</a>, 
		<a href="#Apply+\container82">8.2</a>, 
		<a href="#Apply+\container101">10.1</a>, 
		<a href="#Apply+\container132">13.2</a>, 
		<a href="#Apply+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Apply+code for \container41">4.1</a>, 
		<a href="#Apply+code for \container43">4.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; general, <a href="#Apply+general122">12.2</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Back</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Back+\container11">1.1</a>, 
		<a href="#Back+\container32">3.2</a>, 
		<a href="#Back+\container92">9.2</a>, 
		<a href="#Back+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Back+code for \container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>BitBlockCount</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#BitBlockCount+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>BitLeftShift</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#BitLeftShift+\container42">4.2</a>, 
		<a href="#BitLeftShift+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>BitRightShift</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#BitRightShift+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>BitString, <a href="#BitString40">4.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure definition, 
		<a href="#BitString+structure definition39">3.9</a></dd>
 <dt><b></b></dt>
	<dd>Bloomfilter, <a href="#Bloomfilter120">12.0</a></dd>
 <dt><b></b></dt>
	<dd>Buffers, <a href="#Buffers150">15.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>CalculateSpace</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CalculateSpace+\container122">12.2</a></dd>
 <dt><b></b></dt>
	<dd>Calloc</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Calloc+\container30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>CastToArray</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CastToArray+\container52">5.2</a>, 
		<a href="#CastToArray+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>Change</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Change+\container21">2.1</a></dd>
 <dt><b></b></dt>
	<dd>Clear, <a href="#Clear20">2.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Clear+\container11">1.1</a>, 
		<a href="#Clear+\container12">1.2</a>, 
		<a href="#Clear+\container22">2.2</a>, 
		<a href="#Clear+\container30">3.0</a>, 
		<a href="#Clear+\container32">3.2</a>, 
		<a href="#Clear+\container62">6.2</a>, 
		<a href="#Clear+\container82">8.2</a>, 
		<a href="#Clear+\container101">10.1</a>, 
		<a href="#Clear+\container113">11.3</a>, 
		<a href="#Clear+\container122">12.2</a>, 
		<a href="#Clear+\container132">13.2</a>, 
		<a href="#Clear+\container143">14.3</a>, 
		<a href="#Clear+\container151">15.1</a>, 
		<a href="#Clear+\container152">15.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Clear+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Compare</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Compare+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>COMPARE_EXPRESSION, <a href="#COMPARE\_EXPRESSION20">2.0</a></dd>
 <dt><b></b></dt>
	<dd>CompareEqual</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CompareEqual+\container32">3.2</a>, 
		<a href="#CompareEqual+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>CompareEqualScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CompareEqualScalar+\container32">3.2</a>, 
		<a href="#CompareEqualScalar+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>CompareFunction, <a href="#CompareFunction72">7.2</a></dd>
 <dt><b></b></dt>
	<dd>CompareScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CompareScalar+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Contains</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Contains+\container11">1.1</a>, 
		<a href="#Contains+\container32">3.2</a>, 
		<a href="#Contains+\container62">6.2</a>, 
		<a href="#Contains+\container101">10.1</a>, 
		<a href="#Contains+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Contains+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Copy</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Copy+\container11">1.1</a>, 
		<a href="#Copy+\container12">1.2</a>, 
		<a href="#Copy+\container32">3.2</a>, 
		<a href="#Copy+\container62">6.2</a>, 
		<a href="#Copy+\container82">8.2</a>, 
		<a href="#Copy+\container101">10.1</a>, 
		<a href="#Copy+\container113">11.3</a>, 
		<a href="#Copy+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Copy+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>CopyBits</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CopyBits+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>CopyElement</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CopyElement+\container11">1.1</a>, 
		<a href="#CopyElement+\container32">3.2</a>, 
		<a href="#CopyElement+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#CopyElement+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>CopyTo</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CopyTo+\container32">3.2</a>, 
		<a href="#CopyTo+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Create, <a href="#Create10">1.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Create+\container11">1.1</a>, 
		<a href="#Create+\container12">1.2</a>, 
		<a href="#Create+\container22">2.2</a>, 
		<a href="#Create+\container30">3.0</a>, 
		<a href="#Create+\container32">3.2</a>, 
		<a href="#Create+\container62">6.2</a>, 
		<a href="#Create+\container82">8.2</a>, 
		<a href="#Create+\container101">10.1</a>, 
		<a href="#Create+\container113">11.3</a>, 
		<a href="#Create+\container122">12.2</a>, 
		<a href="#Create+\container132">13.2</a>, 
		<a href="#Create+\container143">14.3</a>, 
		<a href="#Create+\container151">15.1</a>, 
		<a href="#Create+\container152">15.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Create+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>CreateFromFile</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CreateFromFile+\container52">5.2</a>, 
		<a href="#CreateFromFile+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>CreateFromMask</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CreateFromMask+\container12">1.2</a></dd>
 <dt><b></b></dt>
	<dd>CreateSequence</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CreateSequence+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>CreateWith Allocator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , 
		<a href="#CreateWith Allocator+\container132">13.2</a></dd>
 <dt><b></b></dt>
	<dd>CreateWithAllocator, <a href="#CreateWithAllocator62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#CreateWithAllocator+\container11">1.1</a>, 
		<a href="#CreateWithAllocator+\container32">3.2</a>, 
		<a href="#CreateWithAllocator+\container151">15.1</a>, 
		<a href="#CreateWithAllocator+\container152">15.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#CreateWithAllocator+code for \container41">4.1</a>, 
		<a href="#CreateWithAllocator+code for \container42">4.2</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>DefaultListCompareFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#DefaultListCompareFunction+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>DefaultListLoadFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#DefaultListLoadFunction+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>DefaultSaveFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#DefaultSaveFunction+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>DeleteIterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#DeleteIterator+\container11">1.1</a>, 
		<a href="#DeleteIterator+\container32">3.2</a>, 
		<a href="#DeleteIterator+\container62">6.2</a>, 
		<a href="#DeleteIterator+\container82">8.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#DeleteIterator+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Deque, <a href="#Deque100">10.0</a></dd>
 <dt><b></b></dt>
	<dd>DestructorFunction, <a href="#DestructorFunction76">7.6</a></dd>
 <dt><b></b></dt>
	<dd>Dictionary, <a href="#Dictionary60">6.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure definition, 
		<a href="#Dictionary+structure definition36">3.6</a></dd>
 <dt><b></b></dt>
	<dd>DivideBy</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#DivideBy+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>DivideByScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#DivideByScalar+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>DivideScalarBy</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#DivideScalarBy+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Dlist, <a href="#Dlist20">2.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure definition, 
		<a href="#Dlist+structure definition34">3.4</a></dd>
 <dt><b></b></dt>
	<dd>Download</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; source, <a href="#Download+source30">3.0</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>EmptyErrorFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#EmptyErrorFunction+\container40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>Equal</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Equal+\container11">1.1</a>, 
		<a href="#Equal+\container32">3.2</a>, 
		<a href="#Equal+\container62">6.2</a>, 
		<a href="#Equal+\container101">10.1</a>, 
		<a href="#Equal+\container113">11.3</a>, 
		<a href="#Equal+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Equal+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Erase</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Erase+\container11">1.1</a>, 
		<a href="#Erase+\container32">3.2</a>, 
		<a href="#Erase+\container62">6.2</a>, 
		<a href="#Erase+\container82">8.2</a>, 
		<a href="#Erase+\container101">10.1</a>, 
		<a href="#Erase+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Erase+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>EraseAll</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#EraseAll+\container11">1.1</a>, 
		<a href="#EraseAll+\container32">3.2</a>, 
		<a href="#EraseAll+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>EraseAt</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#EraseAt+\container11">1.1</a>, 
		<a href="#EraseAt+\container32">3.2</a>, 
		<a href="#EraseAt+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>EraseRange</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#EraseRange+\container11">1.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#EraseRange+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>error-codes, <a href="#error-codes41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>ErrorFunction, <a href="#ErrorFunction75">7.5</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>FCompare</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#FCompare+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>FillSequential</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#FillSequential+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Finalize, <a href="#Finalize20">2.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Finalize+\container11">1.1</a>, 
		<a href="#Finalize+\container12">1.2</a>, 
		<a href="#Finalize+\container22">2.2</a>, 
		<a href="#Finalize+\container30">3.0</a>, 
		<a href="#Finalize+\container32">3.2</a>, 
		<a href="#Finalize+\container62">6.2</a>, 
		<a href="#Finalize+\container101">10.1</a>, 
		<a href="#Finalize+\container113">11.3</a>, 
		<a href="#Finalize+\container122">12.2</a>, 
		<a href="#Finalize+\container132">13.2</a>, 
		<a href="#Finalize+\container143">14.3</a>, 
		<a href="#Finalize+\container151">15.1</a>, 
		<a href="#Finalize+\container152">15.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Finalize+code for \container41">4.1</a>, 
		<a href="#Finalize+code for \container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>Find</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Find+\container122">12.2</a></dd>
 <dt><b></b></dt>
	<dd>FindFirst</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#FindFirst+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>FindNext</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#FindNext+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>FindTextPositions</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#FindTextPositions+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>FirstElement</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#FirstElement+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>ForEach</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#ForEach+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Fprintf</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Fprintf+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Free</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Free+code for \container45">4.5</a></dd>
 <dt><b></b></dt>
	<dd>FreeObject</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#FreeObject+\container22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>Front</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Front+\container11">1.1</a>, 
		<a href="#Front+\container32">3.2</a>, 
		<a href="#Front+\container52">5.2</a>, 
		<a href="#Front+\container92">9.2</a>, 
		<a href="#Front+\container101">10.1</a>, 
		<a href="#Front+\container113">11.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Front+code for \container42">4.2</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Generic Container</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#Generic Container+structure31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>GetAllocator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetAllocator+\container11">1.1</a>, 
		<a href="#GetAllocator+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>GetCapacity</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetCapacity+\container32">3.2</a>, 
		<a href="#GetCapacity+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>GetCurrent</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetCurrent+\container21">2.1</a>, 
		<a href="#GetCurrent+\container52">5.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#GetCurrent+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>GetData</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetData+\container32">3.2</a>, 
		<a href="#GetData+\container42">4.2</a>, 
		<a href="#GetData+\container92">9.2</a>, 
		<a href="#GetData+\container143">14.3</a>, 
		<a href="#GetData+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>GetElement</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetElement+\container11">1.1</a>, 
		<a href="#GetElement+\container32">3.2</a>, 
		<a href="#GetElement+\container62">6.2</a>, 
		<a href="#GetElement+\container82">8.2</a>, 
		<a href="#GetElement+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>GetElementData</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetElementData+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>GetElementSize</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetElementSize+\container11">1.1</a>, 
		<a href="#GetElementSize+\container32">3.2</a>, 
		<a href="#GetElementSize+\container62">6.2</a>, 
		<a href="#GetElementSize+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>GetFirst</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetFirst+\container52">5.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#GetFirst+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>GetFlags</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetFlags+\container62">6.2</a>, 
		<a href="#GetFlags+\container82">8.2</a>, 
		<a href="#GetFlags+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#GetFlags+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>GetFlags / SetFlags</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetFlags / SetFlags+\container11">1.1</a>, 
		<a href="#GetFlags / SetFlags+\container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>GetLast</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetLast+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>GetLoadFactor</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetLoadFactor+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>GetNext</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetNext+\container52">5.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#GetNext+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>GetPosition</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetPosition+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>GetPrevious</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetPrevious+\container52">5.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#GetPrevious+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>GetRange, <a href="#GetRange50">5.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetRange+\container11">1.1</a>, 
		<a href="#GetRange+\container32">3.2</a>, 
		<a href="#GetRange+\container42">4.2</a>, 
		<a href="#GetRange+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#GetRange+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>GetSlice</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#GetSlice+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>guid, <a href="#guid41">4.1</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>hash</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#hash+code for \container43">4.3</a></dd>
 <dt><b></b></dt>
	<dd>HashTable, <a href="#HashTable80">8.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>iAssociativeContainer, <a href="#iAssociativeContainer163">16.3</a></dd>
 <dt><b></b></dt>
	<dd>iBitString, <a href="#iBitString41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>iDeque, <a href="#iDeque101">10.1</a></dd>
 <dt><b></b></dt>
	<dd>iDictionary, <a href="#iDictionary61">6.1</a></dd>
 <dt><b></b></dt>
	<dd>iDlist, <a href="#iDlist20">2.0</a></dd>
 <dt><b></b></dt>
	<dd>iError, <a href="#iError40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>iGenericContainer, <a href="#iGenericContainer161">16.1</a></dd>
 <dt><b></b></dt>
	<dd>iHashTable, <a href="#iHashTable81">8.1</a></dd>
 <dt><b></b></dt>
	<dd>iHeap, <a href="#iHeap22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>iList, <a href="#iList10">1.0</a></dd>
 <dt><b></b></dt>
	<dd>IndexIn</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#IndexIn+\container32">3.2</a>, 
		<a href="#IndexIn+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>IndexOf</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#IndexOf+\container11">1.1</a>, 
		<a href="#IndexOf+\container32">3.2</a>, 
		<a href="#IndexOf+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#IndexOf+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Infinite arrays, <a href="#Infinite arrays30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>Init</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Init+\container11">1.1</a>, 
		<a href="#Init+\container52">5.2</a>, 
		<a href="#Init+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Init+code for \container41">4.1</a>, 
		<a href="#Init+code for \container43">4.3</a></dd>
 <dt><b></b></dt>
	<dd>InitHeap</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#InitHeap+\container22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>InitializeWith</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#InitializeWith+\container11">1.1</a>, 
		<a href="#InitializeWith+\container42">4.2</a>, 
		<a href="#InitializeWith+\container62">6.2</a>, 
		<a href="#InitializeWith+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>InitObserver</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#InitObserver+code for \container46">4.6</a></dd>
 <dt><b></b></dt>
	<dd>InitWithAllocator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#InitWithAllocator+\container11">1.1</a>, 
		<a href="#InitWithAllocator+\container52">5.2</a>, 
		<a href="#InitWithAllocator+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#InitWithAllocator+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Insert</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Insert+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>InsertAt</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#InsertAt+\container11">1.1</a>, 
		<a href="#InsertAt+\container32">3.2</a>, 
		<a href="#InsertAt+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#InsertAt+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>InsertIn</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#InsertIn+\container11">1.1</a>, 
		<a href="#InsertIn+\container32">3.2</a>, 
		<a href="#InsertIn+\container52">5.2</a>, 
		<a href="#InsertIn+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#InsertIn+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Inverse</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Inverse+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>iPool, <a href="#iPool30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>iSequentiaContainer, <a href="#iSequentiaContainer162">16.2</a></dd>
 <dt><b></b></dt>
	<dd>istrCollection, <a href="#istrCollection50">5.0</a></dd>
 <dt><b></b></dt>
	<dd>iSuffixTree, <a href="#iSuffixTree130">13.0</a></dd>
 <dt><b></b></dt>
	<dd>Iterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#Iterator+structure310">3.10</a></dd>
 <dt><b></b></dt>
	<dd>iterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Dictionary, <a href="#iterator+Dictionary43">4.3</a></dd>
 <dt><b></b></dt>
	<dd>Iterators</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; General, <a href="#Iterators+General123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>iTreeMap, <a href="#iTreeMap70">7.0</a></dd>
 <dt><b></b></dt>
	<dd>iValArray, <a href="#iValArray140">14.0</a></dd>
 <dt><b></b></dt>
	<dd>iVector, <a href="#iVector30">3.0</a>, <a href="#iVector31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>iWstrCollection, <a href="#iWstrCollection50">5.0</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>LastElement</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#LastElement+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>List, <a href="#List06">0.6</a></dd>
 <dt><b></b></dt>
	<dd>ListIterator, <a href="#ListIterator310">3.10</a></dd>
 <dt><b></b></dt>
	<dd>lists</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code, <a href="#lists+code41">4.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; double linked, <a href="#lists+double linked20">2.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; single linked, <a href="#lists+single linked10">1.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#lists+structure33">3.3</a></dd>
 <dt><b></b></dt>
	<dd>Load</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Load+\container11">1.1</a>, 
		<a href="#Load+\container32">3.2</a>, 
		<a href="#Load+\container62">6.2</a>, 
		<a href="#Load+\container82">8.2</a>, 
		<a href="#Load+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Load+code for \container41">4.1</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Malloc</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Malloc+code for \container45">4.5</a></dd>
 <dt><b></b></dt>
	<dd>mapcar, <a href="#mapcar30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>mapcon, <a href="#mapcon30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>Mask</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure definition, 
		<a href="#Mask+structure definition38">3.8</a></dd>
 <dt><b></b></dt>
	<dd>Max</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Max+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Memset</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Memset+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Merge</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Merge+\container82">8.2</a></dd>
 <dt><b></b></dt>
	<dd>Min</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Min+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Mismatch</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Mismatch+\container32">3.2</a>, 
		<a href="#Mismatch+\container52">5.2</a>, 
		<a href="#Mismatch+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>MoveBack</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#MoveBack+\container20">2.0</a></dd>
 <dt><b></b></dt>
	<dd>MultiplyWith</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#MultiplyWith+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>MultiplyWithScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#MultiplyWithScalar+\container143">14.3</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>NewIterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#NewIterator+\container11">1.1</a>, 
		<a href="#NewIterator+\container32">3.2</a>, 
		<a href="#NewIterator+\container62">6.2</a>, 
		<a href="#NewIterator+\container82">8.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#NewIterator+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>newObject</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#newObject+\container22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>NextElement</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#NextElement+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>Not</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Not+\container12">1.2</a>, 
		<a href="#Not+\container42">4.2</a>, 
		<a href="#Not+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>NotAssign</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#NotAssign+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>Notify</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Notify+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Notify+code for \container46">4.6</a></dd>
 <dt><b></b></dt>
	<dd>NullPtrError</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#NullPtrError+\container40">4.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>observer, <a href="#observer60">6.0</a></dd>
 <dt><b></b></dt>
	<dd>ObserverFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#ObserverFunction+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>Or</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Or+\container12">1.2</a>, 
		<a href="#Or+\container42">4.2</a>, 
		<a href="#Or+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>OrAssign</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#OrAssign+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>OrScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#OrScalar+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Overlay</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Overlay+\container82">8.2</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>PeekFront</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#PeekFront+\container152">15.2</a></dd>
 <dt><b></b></dt>
	<dd>Pop</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Pop+\container113">11.3</a></dd>
 <dt><b></b></dt>
	<dd>PopBack</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#PopBack+\container20">2.0</a>, 
		<a href="#PopBack+\container32">3.2</a>, 
		<a href="#PopBack+\container52">5.2</a>, 
		<a href="#PopBack+\container101">10.1</a>, 
		<a href="#PopBack+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>PopFront</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#PopFront+\container11">1.1</a>, 
		<a href="#PopFront+\container101">10.1</a>, 
		<a href="#PopFront+\container152">15.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#PopFront+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>PopulationCount</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#PopulationCount+\container12">1.2</a>, 
		<a href="#PopulationCount+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>PreviousElement</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#PreviousElement+\container20">2.0</a></dd>
 <dt><b></b></dt>
	<dd>Print</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Print+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>Priority queues, <a href="#Priority queues110">11.0</a></dd>
 <dt><b></b></dt>
	<dd>Product</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Product+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Push</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Push+\container113">11.3</a></dd>
 <dt><b></b></dt>
	<dd>PushBack</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#PushBack+\container20">2.0</a>, 
		<a href="#PushBack+\container101">10.1</a></dd>
 <dt><b></b></dt>
	<dd>PushFront</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#PushFront+\container11">1.1</a>, 
		<a href="#PushFront+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#PushFront+code for \container41">4.1</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Queue, <a href="#Queue90">9.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>RaiseError</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#RaiseError+\container40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>Read</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Read+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>ReadFromFile</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#ReadFromFile+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>ReadFunction, <a href="#ReadFunction74">7.4</a></dd>
 <dt><b></b></dt>
	<dd>RemoveAt</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#RemoveAt+\container42">4.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#RemoveAt+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>RemoveRange</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#RemoveRange+\container11">1.1</a>, 
		<a href="#RemoveRange+\container32">3.2</a>, 
		<a href="#RemoveRange+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>Replace</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Replace+\container52">5.2</a>, 
		<a href="#Replace+\container82">8.2</a></dd>
 <dt><b></b></dt>
	<dd>ReplaceAt</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#ReplaceAt+\container11">1.1</a>, 
		<a href="#ReplaceAt+\container32">3.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#ReplaceAt+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Reserve</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Reserve+\container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>ResetSlice</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#ResetSlice+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Resize</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Resize+\container32">3.2</a>, 
		<a href="#Resize+\container82">8.2</a>, 
		<a href="#Resize+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>Reverse</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Reverse+\container11">1.1</a>, 
		<a href="#Reverse+\container32">3.2</a>, 
		<a href="#Reverse+\container42">4.2</a>, 
		<a href="#Reverse+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Reverse+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>RotateLeft</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#RotateLeft+\container11">1.1</a>, 
		<a href="#RotateLeft+\container32">3.2</a>, 
		<a href="#RotateLeft+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#RotateLeft+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>RotateRight</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#RotateRight+\container11">1.1</a>, 
		<a href="#RotateRight+\container32">3.2</a>, 
		<a href="#RotateRight+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#RotateRight+code for \container41">4.1</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Save</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Save+\container11">1.1</a>, 
		<a href="#Save+\container32">3.2</a>, 
		<a href="#Save+\container62">6.2</a>, 
		<a href="#Save+\container82">8.2</a>, 
		<a href="#Save+\container101">10.1</a>, 
		<a href="#Save+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Save+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>SaveFunction, <a href="#SaveFunction73">7.3</a></dd>
 <dt><b></b></dt>
	<dd>SearchWithKey</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SearchWithKey+\container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>Seek</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Seek+\container52">5.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Seek+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Select</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Select+\container11">1.1</a>, 
		<a href="#Select+\container32">3.2</a>, 
		<a href="#Select+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>SelectCopy</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SelectCopy+\container11">1.1</a>, 
		<a href="#SelectCopy+\container32">3.2</a>, 
		<a href="#SelectCopy+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Set</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Set+\container12">1.2</a>, 
		<a href="#Set+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>SetCapacity</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SetCapacity+\container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>SetCompareFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SetCompareFunction+\container11">1.1</a>, 
		<a href="#SetCompareFunction+\container32">3.2</a>, 
		<a href="#SetCompareFunction+\container52">5.2</a>, 
		<a href="#SetCompareFunction+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#SetCompareFunction+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>SetDestructor</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SetDestructor+\container11">1.1</a>, 
		<a href="#SetDestructor+\container32">3.2</a>, 
		<a href="#SetDestructor+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>SetElementData</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SetElementData+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>SetErrorFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SetErrorFunction+\container11">1.1</a>, 
		<a href="#SetErrorFunction+\container32">3.2</a>, 
		<a href="#SetErrorFunction+\container40">4.0</a>, 
		<a href="#SetErrorFunction+\container62">6.2</a>, 
		<a href="#SetErrorFunction+\container82">8.2</a></dd>
 <dt><b></b></dt>
	<dd>SetHashFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SetHashFunction+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>SetPosition</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SetPosition+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>SetSlice</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SetSlice+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>Size, <a href="#Size140">14.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Size+\container11">1.1</a>, 
		<a href="#Size+\container12">1.2</a>, 
		<a href="#Size+\container32">3.2</a>, 
		<a href="#Size+\container62">6.2</a>, 
		<a href="#Size+\container82">8.2</a>, 
		<a href="#Size+\container113">11.3</a>, 
		<a href="#Size+\container143">14.3</a>, 
		<a href="#Size+\container151">15.1</a>, 
		<a href="#Size+\container152">15.2</a></dd>
 <dt><b></b></dt>
	<dd>Sizeof</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Sizeof+\container11">1.1</a>, 
		<a href="#Sizeof+\container12">1.2</a>, 
		<a href="#Sizeof+\container22">2.2</a>, 
		<a href="#Sizeof+\container32">3.2</a>, 
		<a href="#Sizeof+\container62">6.2</a>, 
		<a href="#Sizeof+\container82">8.2</a>, 
		<a href="#Sizeof+\container113">11.3</a>, 
		<a href="#Sizeof+\container143">14.3</a>, 
		<a href="#Sizeof+\container152">15.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Sizeof+code for \container41">4.1</a>, 
		<a href="#Sizeof+code for \container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>SizeofIterator, <a href="#SizeofIterator152">15.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SizeofIterator+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>Sort</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Sort+\container11">1.1</a>, 
		<a href="#Sort+\container32">3.2</a>, 
		<a href="#Sort+\container143">14.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Sort+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>Splice</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Splice+\container20">2.0</a></dd>
 <dt><b></b></dt>
	<dd>SplitAfter</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SplitAfter+\container11">1.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#SplitAfter+code for \container41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>strCollection</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#strCollection+structure37">3.7</a></dd>
 <dt><b></b></dt>
	<dd>StrError</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#StrError+\container40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>StringCompareFn, <a href="#StringCompareFn52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>StringToBitString</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#StringToBitString+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>Subscribe</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Subscribe+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Subscribe+code for \container46">4.6</a></dd>
 <dt><b></b></dt>
	<dd>SubtractFrom</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SubtractFrom+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>SubtractFromScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SubtractFromScalar+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>SubtractScalarFrom</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SubtractScalarFrom+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>SuffixTree, <a href="#SuffixTree130">13.0</a></dd>
 <dt><b></b></dt>
	<dd>SumTo</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SumTo+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>SumToScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#SumToScalar+\container143">14.3</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>TreeMap, <a href="#TreeMap70">7.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Unsubscribe</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Unsubscribe+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#Unsubscribe+code for \container46">4.6</a></dd>
 <dt><b></b></dt>
	<dd>UseHeap</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#UseHeap+\container11">1.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for , 
		<a href="#UseHeap+code for \container41">4.1</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>ValArray, <a href="#ValArray140">14.0</a></dd>
 <dt><b></b></dt>
	<dd>ValArrays,code, <a href="#ValArrays,code47">4.7</a></dd>
 <dt><b></b></dt>
	<dd>Vector, <a href="#Vector31">3.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#Vector+structure35">3.5</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Write</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Write+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>WriteToFile</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#WriteToFile+\container52">5.2</a>, 
		<a href="#WriteToFile+\container151">15.1</a></dd>
 <dt><b></b></dt>
	<dd>WstrCollection, <a href="#WstrCollection50">5.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Xor</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#Xor+\container42">4.2</a>, 
		<a href="#Xor+\container143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>XorAssign</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#XorAssign+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>XorScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; , <a href="#XorScalar+\container143">14.3</a></dd>
</dl></td></tr></table>


<BR CLEAR=LEFT><BR><BR>

<center>
Epilogue
</center>
It took the committee less than one hour to reject all these years of work. Here is what the committee published about it:

<div class="p"><!----></div>
N1625 is a proposal on adding a container library to the C Standard. 

<div class="p"><!----></div>
Does an existing implementation exist? 
Yes, and is freely available. Jacob Navia is the compiler implementer, and presented his proposal.

<div class="p"><!----></div>
Bill Seymour: Why do this in C? C is a good language that will be around for a long time. Having a container library can solve many problems for those who use C by providing facilities that do not exist today. C is not an “overcomplicated moving target” language.

<div class="p"><!----></div>
Blaine sees the proposal as inventing objects. Does C need objects? Blaine does not think so. Is there a way to have a simple object system? Is there anything the language to do to help this out? 
This proposal does not address changes to the languages.

<div class="p"><!----></div>
David K is concerned about the implementation. If C++ can do this faster, why do it? 

<div class="p"><!----></div>
PJ: Since the implementation is freely available, why standardize it?

<div class="p"><!----></div>
Rajan asked if Jacob would be willing to make this work a TS? Jacobs sees a real need to standardize it, and sees a lot of work still needed. He sees creating a standard as only a starting point to create a much better implementation.

<div class="p"><!----></div>
Blaine believes it would be very difficult to implement this and get performance improvements from one compiler vendor to another w/o having language support.

<div class="p"><!----></div>
Prosser points out that the proposal is really insufficient to do what he already does today.

<div class="p"><!----></div>
Parks points out that for his environment, C and C++ need to be able to work together, and see this as a divergent path for his projects.
In general, the thrust of this proposal is to provide a C library for containers so that a user does not have to use C++. 

<div class="p"><!----></div>
Should Jacob continue this work?
<div class="p"><!----></div>
Blaine sees this as a good solution for those who do not want to use C++. It’s a large library, and will have to meet other concerns, such as threading.

<div class="p"><!----></div>
Roger: Is there a large audience in pure C solutions?

<div class="p"><!----></div>
Clark: If this model becomes popular in the next ten years, that would be great, but we would like to see a demand before we jump into it.
Which comes first: A standard approach, or an existing market approach? Jacobs sees common approaches to problems such as this will not be adopted by the market without involvement by the Standards Committee. Everyone will continue to develop their own approach because there is no standard.

<div class="p"><!----></div>
PJ points out that for practical purposes, most shops are using a mix of C and C++, and that is the most likely scenario going forward. More and more use of a mix of C and C++ is the trend being taken by industry. As such, there is not likely a large audience for a C only solution.

<div class="p"><!----></div>
Jacob believes his approach can achieve the same performance as C++.

<div class="p"><!----></div>
Parks is not convinced the market of C programmers is as concerned about this problem as much as they do about other problems we are working on.

<div class="p"><!----></div>
Mike points out that his experience is that those who are writing in C only write in C.
In summary, most believe the proposal is very thorough and well thought out. The question is the value of doing something is C solely for the sake of providing a competing approach to C++ that can be used by those who prefer C over C++.

<div class="p"><!----></div>
Do we want to encourage Jacob to continue working on this effort?
<div class="p"><!----></div>
Are we willing to help with this work? Jacob cannot do all this work alone.
<div class="p"><!----></div>
Are we interested in seeing this work progress? That implies we want to see it come back.
<div class="p"><!----></div>
Straw Poll: Does the committee want to pursue a library based container proposal in the near term?
<div class="p"><!----></div>
 Yes - 4, No – 12, Abstain – 3

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>Hgold</a>,
version 4.05 (hacked by jacob navia).<br />On 30 Mar 2016, 13:39.</small>
</html>
